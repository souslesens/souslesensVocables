import {
    _ as _extends,
    r as reactExports,
    R as React,
    j as jsxRuntimeExports,
    a as _objectWithoutPropertiesLoose,
    b as reactDomExports,
    c as _inheritsLoose,
    d as React$1,
    T as TransitionGroupContext,
    e as Transition,
    f as commonjsGlobal,
    g as getAugmentedNamespace,
    h as createRoot,
} from "./client-1fbea0c8.js";
const common = {
    black: "#000",
    white: "#fff",
};
const common$1 = common;
const red = {
    50: "#ffebee",
    100: "#ffcdd2",
    200: "#ef9a9a",
    300: "#e57373",
    400: "#ef5350",
    500: "#f44336",
    600: "#e53935",
    700: "#d32f2f",
    800: "#c62828",
    900: "#b71c1c",
    A100: "#ff8a80",
    A200: "#ff5252",
    A400: "#ff1744",
    A700: "#d50000",
};
const red$1 = red;
const pink = {
    50: "#fce4ec",
    100: "#f8bbd0",
    200: "#f48fb1",
    300: "#f06292",
    400: "#ec407a",
    500: "#e91e63",
    600: "#d81b60",
    700: "#c2185b",
    800: "#ad1457",
    900: "#880e4f",
    A100: "#ff80ab",
    A200: "#ff4081",
    A400: "#f50057",
    A700: "#c51162",
};
const pink$1 = pink;
const purple = {
    50: "#f3e5f5",
    100: "#e1bee7",
    200: "#ce93d8",
    300: "#ba68c8",
    400: "#ab47bc",
    500: "#9c27b0",
    600: "#8e24aa",
    700: "#7b1fa2",
    800: "#6a1b9a",
    900: "#4a148c",
    A100: "#ea80fc",
    A200: "#e040fb",
    A400: "#d500f9",
    A700: "#aa00ff",
};
const purple$1 = purple;
const blue = {
    50: "#e3f2fd",
    100: "#bbdefb",
    200: "#90caf9",
    300: "#64b5f6",
    400: "#42a5f5",
    500: "#2196f3",
    600: "#1e88e5",
    700: "#1976d2",
    800: "#1565c0",
    900: "#0d47a1",
    A100: "#82b1ff",
    A200: "#448aff",
    A400: "#2979ff",
    A700: "#2962ff",
};
const blue$1 = blue;
const lightBlue = {
    50: "#e1f5fe",
    100: "#b3e5fc",
    200: "#81d4fa",
    300: "#4fc3f7",
    400: "#29b6f6",
    500: "#03a9f4",
    600: "#039be5",
    700: "#0288d1",
    800: "#0277bd",
    900: "#01579b",
    A100: "#80d8ff",
    A200: "#40c4ff",
    A400: "#00b0ff",
    A700: "#0091ea",
};
const lightBlue$1 = lightBlue;
const green = {
    50: "#e8f5e9",
    100: "#c8e6c9",
    200: "#a5d6a7",
    300: "#81c784",
    400: "#66bb6a",
    500: "#4caf50",
    600: "#43a047",
    700: "#388e3c",
    800: "#2e7d32",
    900: "#1b5e20",
    A100: "#b9f6ca",
    A200: "#69f0ae",
    A400: "#00e676",
    A700: "#00c853",
};
const green$1 = green;
const orange = {
    50: "#fff3e0",
    100: "#ffe0b2",
    200: "#ffcc80",
    300: "#ffb74d",
    400: "#ffa726",
    500: "#ff9800",
    600: "#fb8c00",
    700: "#f57c00",
    800: "#ef6c00",
    900: "#e65100",
    A100: "#ffd180",
    A200: "#ffab40",
    A400: "#ff9100",
    A700: "#ff6d00",
};
const orange$1 = orange;
const grey = {
    50: "#fafafa",
    100: "#f5f5f5",
    200: "#eeeeee",
    300: "#e0e0e0",
    400: "#bdbdbd",
    500: "#9e9e9e",
    600: "#757575",
    700: "#616161",
    800: "#424242",
    900: "#212121",
    A100: "#f5f5f5",
    A200: "#eeeeee",
    A400: "#bdbdbd",
    A700: "#616161",
};
const grey$1 = grey;
function isPlainObject(item) {
    return item !== null && typeof item === "object" && item.constructor === Object;
}
function deepClone(source) {
    if (!isPlainObject(source)) {
        return source;
    }
    const output = {};
    Object.keys(source).forEach((key) => {
        output[key] = deepClone(source[key]);
    });
    return output;
}
function deepmerge(
    target,
    source,
    options = {
        clone: true,
    }
) {
    const output = options.clone ? _extends({}, target) : target;
    if (isPlainObject(target) && isPlainObject(source)) {
        Object.keys(source).forEach((key) => {
            if (key === "__proto__") {
                return;
            }
            if (isPlainObject(source[key]) && key in target && isPlainObject(target[key])) {
                output[key] = deepmerge(target[key], source[key], options);
            } else if (options.clone) {
                output[key] = isPlainObject(source[key]) ? deepClone(source[key]) : source[key];
            } else {
                output[key] = source[key];
            }
        });
    }
    return output;
}
function formatMuiErrorMessage(code) {
    let url = "https://mui.com/production-error/?code=" + code;
    for (let i = 1; i < arguments.length; i += 1) {
        url += "&args[]=" + encodeURIComponent(arguments[i]);
    }
    return "Minified MUI error #" + code + "; visit " + url + " for the full message.";
}
var reactIs_production_min$1 = {};
/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b$1 = Symbol.for("react.element"),
    c$1 = Symbol.for("react.portal"),
    d$1 = Symbol.for("react.fragment"),
    e$1 = Symbol.for("react.strict_mode"),
    f$1 = Symbol.for("react.profiler"),
    g$1 = Symbol.for("react.provider"),
    h$1 = Symbol.for("react.context"),
    k$1 = Symbol.for("react.server_context"),
    l$1 = Symbol.for("react.forward_ref"),
    m$1 = Symbol.for("react.suspense"),
    n$1 = Symbol.for("react.suspense_list"),
    p$1 = Symbol.for("react.memo"),
    q$1 = Symbol.for("react.lazy"),
    t$1 = Symbol.for("react.offscreen"),
    u;
u = Symbol.for("react.module.reference");
function v$1(a) {
    if ("object" === typeof a && null !== a) {
        var r2 = a.$$typeof;
        switch (r2) {
            case b$1:
                switch (((a = a.type), a)) {
                    case d$1:
                    case f$1:
                    case e$1:
                    case m$1:
                    case n$1:
                        return a;
                    default:
                        switch (((a = a && a.$$typeof), a)) {
                            case k$1:
                            case h$1:
                            case l$1:
                            case q$1:
                            case p$1:
                            case g$1:
                                return a;
                            default:
                                return r2;
                        }
                }
            case c$1:
                return r2;
        }
    }
}
reactIs_production_min$1.ContextConsumer = h$1;
reactIs_production_min$1.ContextProvider = g$1;
reactIs_production_min$1.Element = b$1;
reactIs_production_min$1.ForwardRef = l$1;
reactIs_production_min$1.Fragment = d$1;
reactIs_production_min$1.Lazy = q$1;
reactIs_production_min$1.Memo = p$1;
reactIs_production_min$1.Portal = c$1;
reactIs_production_min$1.Profiler = f$1;
reactIs_production_min$1.StrictMode = e$1;
reactIs_production_min$1.Suspense = m$1;
reactIs_production_min$1.SuspenseList = n$1;
reactIs_production_min$1.isAsyncMode = function () {
    return false;
};
reactIs_production_min$1.isConcurrentMode = function () {
    return false;
};
reactIs_production_min$1.isContextConsumer = function (a) {
    return v$1(a) === h$1;
};
reactIs_production_min$1.isContextProvider = function (a) {
    return v$1(a) === g$1;
};
reactIs_production_min$1.isElement = function (a) {
    return "object" === typeof a && null !== a && a.$$typeof === b$1;
};
reactIs_production_min$1.isForwardRef = function (a) {
    return v$1(a) === l$1;
};
reactIs_production_min$1.isFragment = function (a) {
    return v$1(a) === d$1;
};
reactIs_production_min$1.isLazy = function (a) {
    return v$1(a) === q$1;
};
reactIs_production_min$1.isMemo = function (a) {
    return v$1(a) === p$1;
};
reactIs_production_min$1.isPortal = function (a) {
    return v$1(a) === c$1;
};
reactIs_production_min$1.isProfiler = function (a) {
    return v$1(a) === f$1;
};
reactIs_production_min$1.isStrictMode = function (a) {
    return v$1(a) === e$1;
};
reactIs_production_min$1.isSuspense = function (a) {
    return v$1(a) === m$1;
};
reactIs_production_min$1.isSuspenseList = function (a) {
    return v$1(a) === n$1;
};
reactIs_production_min$1.isValidElementType = function (a) {
    return "string" === typeof a ||
        "function" === typeof a ||
        a === d$1 ||
        a === f$1 ||
        a === e$1 ||
        a === m$1 ||
        a === n$1 ||
        a === t$1 ||
        ("object" === typeof a &&
            null !== a &&
            (a.$$typeof === q$1 || a.$$typeof === p$1 || a.$$typeof === g$1 || a.$$typeof === h$1 || a.$$typeof === l$1 || a.$$typeof === u || void 0 !== a.getModuleId))
        ? true
        : false;
};
reactIs_production_min$1.typeOf = v$1;
function capitalize(string) {
    if (typeof string !== "string") {
        throw new Error(formatMuiErrorMessage(7));
    }
    return string.charAt(0).toUpperCase() + string.slice(1);
}
function createChainedFunction(...funcs) {
    return funcs.reduce(
        (acc, func) => {
            if (func == null) {
                return acc;
            }
            return function chainedFunction(...args) {
                acc.apply(this, args);
                func.apply(this, args);
            };
        },
        () => {}
    );
}
function debounce$1(func, wait = 166) {
    let timeout;
    function debounced(...args) {
        const later = () => {
            func.apply(this, args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    }
    debounced.clear = () => {
        clearTimeout(timeout);
    };
    return debounced;
}
function deprecatedPropType(validator, reason) {
    {
        return () => null;
    }
}
function isMuiElement(element, muiNames) {
    var _muiName, _element$type;
    return (
        /* @__PURE__ */ reactExports.isValidElement(element) &&
        muiNames.indexOf(
            // For server components `muiName` is avaialble in element.type._payload.value.muiName
            // relevant info - https://github.com/facebook/react/blob/2807d781a08db8e9873687fccc25c0f12b4fb3d4/packages/react/src/ReactLazy.js#L45
            // eslint-disable-next-line no-underscore-dangle
            (_muiName = element.type.muiName) != null
                ? _muiName
                : (_element$type = element.type) == null || (_element$type = _element$type._payload) == null || (_element$type = _element$type.value) == null
                ? void 0
                : _element$type.muiName
        ) !== -1
    );
}
function ownerDocument(node2) {
    return (node2 && node2.ownerDocument) || document;
}
function ownerWindow(node2) {
    const doc = ownerDocument(node2);
    return doc.defaultView || window;
}
function requirePropFactory(componentNameInError, Component) {
    {
        return () => null;
    }
}
function setRef(ref, value) {
    if (typeof ref === "function") {
        ref(value);
    } else if (ref) {
        ref.current = value;
    }
}
const useEnhancedEffect = typeof window !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
const useEnhancedEffect$1 = useEnhancedEffect;
let globalId = 0;
function useGlobalId(idOverride) {
    const [defaultId, setDefaultId] = reactExports.useState(idOverride);
    const id = idOverride || defaultId;
    reactExports.useEffect(() => {
        if (defaultId == null) {
            globalId += 1;
            setDefaultId(`mui-${globalId}`);
        }
    }, [defaultId]);
    return id;
}
const maybeReactUseId = React["useId".toString()];
function useId(idOverride) {
    if (maybeReactUseId !== void 0) {
        const reactId = maybeReactUseId();
        return idOverride != null ? idOverride : reactId;
    }
    return useGlobalId(idOverride);
}
function unsupportedProp(props, propName, componentName, location2, propFullName) {
    {
        return null;
    }
}
function useControlled({ controlled, default: defaultProp, name, state = "value" }) {
    const { current: isControlled } = reactExports.useRef(controlled !== void 0);
    const [valueState, setValue] = reactExports.useState(defaultProp);
    const value = isControlled ? controlled : valueState;
    const setValueIfUncontrolled = reactExports.useCallback((newValue) => {
        if (!isControlled) {
            setValue(newValue);
        }
    }, []);
    return [value, setValueIfUncontrolled];
}
function useEventCallback(fn2) {
    const ref = reactExports.useRef(fn2);
    useEnhancedEffect$1(() => {
        ref.current = fn2;
    });
    return reactExports.useCallback(
        (...args) =>
            // @ts-expect-error hide `this`
            // tslint:disable-next-line:ban-comma-operator
            (0, ref.current)(...args),
        []
    );
}
function useForkRef(...refs) {
    return reactExports.useMemo(() => {
        if (refs.every((ref) => ref == null)) {
            return null;
        }
        return (instance) => {
            refs.forEach((ref) => {
                setRef(ref, instance);
            });
        };
    }, refs);
}
let hadKeyboardEvent = true;
let hadFocusVisibleRecently = false;
let hadFocusVisibleRecentlyTimeout;
const inputTypesWhitelist = {
    text: true,
    search: true,
    url: true,
    tel: true,
    email: true,
    password: true,
    number: true,
    date: true,
    month: true,
    week: true,
    time: true,
    datetime: true,
    "datetime-local": true,
};
function focusTriggersKeyboardModality(node2) {
    const { type, tagName } = node2;
    if (tagName === "INPUT" && inputTypesWhitelist[type] && !node2.readOnly) {
        return true;
    }
    if (tagName === "TEXTAREA" && !node2.readOnly) {
        return true;
    }
    if (node2.isContentEditable) {
        return true;
    }
    return false;
}
function handleKeyDown(event) {
    if (event.metaKey || event.altKey || event.ctrlKey) {
        return;
    }
    hadKeyboardEvent = true;
}
function handlePointerDown() {
    hadKeyboardEvent = false;
}
function handleVisibilityChange() {
    if (this.visibilityState === "hidden") {
        if (hadFocusVisibleRecently) {
            hadKeyboardEvent = true;
        }
    }
}
function prepare(doc) {
    doc.addEventListener("keydown", handleKeyDown, true);
    doc.addEventListener("mousedown", handlePointerDown, true);
    doc.addEventListener("pointerdown", handlePointerDown, true);
    doc.addEventListener("touchstart", handlePointerDown, true);
    doc.addEventListener("visibilitychange", handleVisibilityChange, true);
}
function isFocusVisible(event) {
    const { target } = event;
    try {
        return target.matches(":focus-visible");
    } catch (error) {}
    return hadKeyboardEvent || focusTriggersKeyboardModality(target);
}
function useIsFocusVisible() {
    const ref = reactExports.useCallback((node2) => {
        if (node2 != null) {
            prepare(node2.ownerDocument);
        }
    }, []);
    const isFocusVisibleRef = reactExports.useRef(false);
    function handleBlurVisible() {
        if (isFocusVisibleRef.current) {
            hadFocusVisibleRecently = true;
            window.clearTimeout(hadFocusVisibleRecentlyTimeout);
            hadFocusVisibleRecentlyTimeout = window.setTimeout(() => {
                hadFocusVisibleRecently = false;
            }, 100);
            isFocusVisibleRef.current = false;
            return true;
        }
        return false;
    }
    function handleFocusVisible(event) {
        if (isFocusVisible(event)) {
            isFocusVisibleRef.current = true;
            return true;
        }
        return false;
    }
    return {
        isFocusVisibleRef,
        onFocus: handleFocusVisible,
        onBlur: handleBlurVisible,
        ref,
    };
}
function getScrollbarSize(doc) {
    const documentWidth = doc.documentElement.clientWidth;
    return Math.abs(window.innerWidth - documentWidth);
}
let cachedType;
function detectScrollType() {
    if (cachedType) {
        return cachedType;
    }
    const dummy = document.createElement("div");
    const container2 = document.createElement("div");
    container2.style.width = "10px";
    container2.style.height = "1px";
    dummy.appendChild(container2);
    dummy.dir = "rtl";
    dummy.style.fontSize = "14px";
    dummy.style.width = "4px";
    dummy.style.height = "1px";
    dummy.style.position = "absolute";
    dummy.style.top = "-1000px";
    dummy.style.overflow = "scroll";
    document.body.appendChild(dummy);
    cachedType = "reverse";
    if (dummy.scrollLeft > 0) {
        cachedType = "default";
    } else {
        dummy.scrollLeft = 1;
        if (dummy.scrollLeft === 0) {
            cachedType = "negative";
        }
    }
    document.body.removeChild(dummy);
    return cachedType;
}
function getNormalizedScrollLeft(element, direction) {
    const scrollLeft = element.scrollLeft;
    if (direction !== "rtl") {
        return scrollLeft;
    }
    const type = detectScrollType();
    switch (type) {
        case "negative":
            return element.scrollWidth - element.clientWidth + scrollLeft;
        case "reverse":
            return element.scrollWidth - element.clientWidth - scrollLeft;
        default:
            return scrollLeft;
    }
}
const usePreviousProps = (value) => {
    const ref = reactExports.useRef({});
    reactExports.useEffect(() => {
        ref.current = value;
    });
    return ref.current;
};
const usePreviousProps$1 = usePreviousProps;
function resolveProps(defaultProps2, props) {
    const output = _extends({}, props);
    Object.keys(defaultProps2).forEach((propName) => {
        if (propName.toString().match(/^(components|slots)$/)) {
            output[propName] = _extends({}, defaultProps2[propName], output[propName]);
        } else if (propName.toString().match(/^(componentsProps|slotProps)$/)) {
            const defaultSlotProps = defaultProps2[propName] || {};
            const slotProps = props[propName];
            output[propName] = {};
            if (!slotProps || !Object.keys(slotProps)) {
                output[propName] = defaultSlotProps;
            } else if (!defaultSlotProps || !Object.keys(defaultSlotProps)) {
                output[propName] = slotProps;
            } else {
                output[propName] = _extends({}, slotProps);
                Object.keys(defaultSlotProps).forEach((slotPropName) => {
                    output[propName][slotPropName] = resolveProps(defaultSlotProps[slotPropName], slotProps[slotPropName]);
                });
            }
        } else if (output[propName] === void 0) {
            output[propName] = defaultProps2[propName];
        }
    });
    return output;
}
function composeClasses(slots, getUtilityClass, classes = void 0) {
    const output = {};
    Object.keys(slots).forEach(
        // `Object.keys(slots)` can't be wider than `T` because we infer `T` from `slots`.
        // @ts-expect-error https://github.com/microsoft/TypeScript/pull/12253#issuecomment-263132208
        (slot) => {
            output[slot] = slots[slot]
                .reduce((acc, key) => {
                    if (key) {
                        const utilityClass = getUtilityClass(key);
                        if (utilityClass !== "") {
                            acc.push(utilityClass);
                        }
                        if (classes && classes[key]) {
                            acc.push(classes[key]);
                        }
                    }
                    return acc;
                }, [])
                .join(" ");
        }
    );
    return output;
}
const defaultGenerator = (componentName) => componentName;
const createClassNameGenerator = () => {
    let generate = defaultGenerator;
    return {
        configure(generator) {
            generate = generator;
        },
        generate(componentName) {
            return generate(componentName);
        },
        reset() {
            generate = defaultGenerator;
        },
    };
};
const ClassNameGenerator = createClassNameGenerator();
const ClassNameGenerator$1 = ClassNameGenerator;
const globalStateClassesMapping = {
    active: "active",
    checked: "checked",
    completed: "completed",
    disabled: "disabled",
    error: "error",
    expanded: "expanded",
    focused: "focused",
    focusVisible: "focusVisible",
    open: "open",
    readOnly: "readOnly",
    required: "required",
    selected: "selected",
};
function generateUtilityClass(componentName, slot, globalStatePrefix = "Mui") {
    const globalStateClass = globalStateClassesMapping[slot];
    return globalStateClass ? `${globalStatePrefix}-${globalStateClass}` : `${ClassNameGenerator$1.generate(componentName)}-${slot}`;
}
function generateUtilityClasses(componentName, slots, globalStatePrefix = "Mui") {
    const result = {};
    slots.forEach((slot) => {
        result[slot] = generateUtilityClass(componentName, slot, globalStatePrefix);
    });
    return result;
}
const THEME_ID = "$$material";
function memoize$1(fn2) {
    var cache = /* @__PURE__ */ Object.create(null);
    return function (arg) {
        if (cache[arg] === void 0) cache[arg] = fn2(arg);
        return cache[arg];
    };
}
var reactPropsRegex =
    /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
var isPropValid = /* @__PURE__ */ memoize$1(
    function (prop) {
        return reactPropsRegex.test(prop) || (prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91);
    }
    /* Z+1 */
);
function sheetForTag(tag) {
    if (tag.sheet) {
        return tag.sheet;
    }
    for (var i = 0; i < document.styleSheets.length; i++) {
        if (document.styleSheets[i].ownerNode === tag) {
            return document.styleSheets[i];
        }
    }
}
function createStyleElement(options) {
    var tag = document.createElement("style");
    tag.setAttribute("data-emotion", options.key);
    if (options.nonce !== void 0) {
        tag.setAttribute("nonce", options.nonce);
    }
    tag.appendChild(document.createTextNode(""));
    tag.setAttribute("data-s", "");
    return tag;
}
var StyleSheet = /* @__PURE__ */ (function () {
    function StyleSheet2(options) {
        var _this = this;
        this._insertTag = function (tag) {
            var before;
            if (_this.tags.length === 0) {
                if (_this.insertionPoint) {
                    before = _this.insertionPoint.nextSibling;
                } else if (_this.prepend) {
                    before = _this.container.firstChild;
                } else {
                    before = _this.before;
                }
            } else {
                before = _this.tags[_this.tags.length - 1].nextSibling;
            }
            _this.container.insertBefore(tag, before);
            _this.tags.push(tag);
        };
        this.isSpeedy = options.speedy === void 0 ? true : options.speedy;
        this.tags = [];
        this.ctr = 0;
        this.nonce = options.nonce;
        this.key = options.key;
        this.container = options.container;
        this.prepend = options.prepend;
        this.insertionPoint = options.insertionPoint;
        this.before = null;
    }
    var _proto = StyleSheet2.prototype;
    _proto.hydrate = function hydrate(nodes) {
        nodes.forEach(this._insertTag);
    };
    _proto.insert = function insert(rule) {
        if (this.ctr % (this.isSpeedy ? 65e3 : 1) === 0) {
            this._insertTag(createStyleElement(this));
        }
        var tag = this.tags[this.tags.length - 1];
        if (this.isSpeedy) {
            var sheet = sheetForTag(tag);
            try {
                sheet.insertRule(rule, sheet.cssRules.length);
            } catch (e2) {}
        } else {
            tag.appendChild(document.createTextNode(rule));
        }
        this.ctr++;
    };
    _proto.flush = function flush() {
        this.tags.forEach(function (tag) {
            return tag.parentNode && tag.parentNode.removeChild(tag);
        });
        this.tags = [];
        this.ctr = 0;
    };
    return StyleSheet2;
})();
var MS = "-ms-";
var MOZ = "-moz-";
var WEBKIT = "-webkit-";
var COMMENT = "comm";
var RULESET = "rule";
var DECLARATION = "decl";
var IMPORT = "@import";
var KEYFRAMES = "@keyframes";
var LAYER = "@layer";
var abs = Math.abs;
var from = String.fromCharCode;
var assign = Object.assign;
function hash$2(value, length2) {
    return charat(value, 0) ^ 45 ? (((((((length2 << 2) ^ charat(value, 0)) << 2) ^ charat(value, 1)) << 2) ^ charat(value, 2)) << 2) ^ charat(value, 3) : 0;
}
function trim(value) {
    return value.trim();
}
function match(value, pattern) {
    return (value = pattern.exec(value)) ? value[0] : value;
}
function replace(value, pattern, replacement) {
    return value.replace(pattern, replacement);
}
function indexof(value, search) {
    return value.indexOf(search);
}
function charat(value, index) {
    return value.charCodeAt(index) | 0;
}
function substr(value, begin, end2) {
    return value.slice(begin, end2);
}
function strlen(value) {
    return value.length;
}
function sizeof(value) {
    return value.length;
}
function append(value, array) {
    return array.push(value), value;
}
function combine(array, callback) {
    return array.map(callback).join("");
}
var line = 1;
var column = 1;
var length = 0;
var position = 0;
var character = 0;
var characters = "";
function node(value, root2, parent, type, props, children, length2) {
    return { value, root: root2, parent, type, props, children, line, column, length: length2, return: "" };
}
function copy(root2, props) {
    return assign(node("", null, null, "", null, null, 0), root2, { length: -root2.length }, props);
}
function char() {
    return character;
}
function prev() {
    character = position > 0 ? charat(characters, --position) : 0;
    if ((column--, character === 10)) (column = 1), line--;
    return character;
}
function next() {
    character = position < length ? charat(characters, position++) : 0;
    if ((column++, character === 10)) (column = 1), line++;
    return character;
}
function peek() {
    return charat(characters, position);
}
function caret() {
    return position;
}
function slice(begin, end2) {
    return substr(characters, begin, end2);
}
function token(type) {
    switch (type) {
        case 0:
        case 9:
        case 10:
        case 13:
        case 32:
            return 5;
        case 33:
        case 43:
        case 44:
        case 47:
        case 62:
        case 64:
        case 126:
        case 59:
        case 123:
        case 125:
            return 4;
        case 58:
            return 3;
        case 34:
        case 39:
        case 40:
        case 91:
            return 2;
        case 41:
        case 93:
            return 1;
    }
    return 0;
}
function alloc(value) {
    return (line = column = 1), (length = strlen((characters = value))), (position = 0), [];
}
function dealloc(value) {
    return (characters = ""), value;
}
function delimit(type) {
    return trim(slice(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)));
}
function whitespace(type) {
    while ((character = peek()))
        if (character < 33) next();
        else break;
    return token(type) > 2 || token(character) > 3 ? "" : " ";
}
function escaping(index, count) {
    while (--count && next()) if (character < 48 || character > 102 || (character > 57 && character < 65) || (character > 70 && character < 97)) break;
    return slice(index, caret() + (count < 6 && peek() == 32 && next() == 32));
}
function delimiter(type) {
    while (next())
        switch (character) {
            case type:
                return position;
            case 34:
            case 39:
                if (type !== 34 && type !== 39) delimiter(character);
                break;
            case 40:
                if (type === 41) delimiter(type);
                break;
            case 92:
                next();
                break;
        }
    return position;
}
function commenter(type, index) {
    while (next())
        if (type + character === 47 + 10) break;
        else if (type + character === 42 + 42 && peek() === 47) break;
    return "/*" + slice(index, position - 1) + "*" + from(type === 47 ? type : next());
}
function identifier(index) {
    while (!token(peek())) next();
    return slice(index, position);
}
function compile(value) {
    return dealloc(parse("", null, null, null, [""], (value = alloc(value)), 0, [0], value));
}
function parse(value, root2, parent, rule, rules, rulesets, pseudo, points, declarations) {
    var index = 0;
    var offset2 = 0;
    var length2 = pseudo;
    var atrule = 0;
    var property = 0;
    var previous = 0;
    var variable = 1;
    var scanning = 1;
    var ampersand = 1;
    var character2 = 0;
    var type = "";
    var props = rules;
    var children = rulesets;
    var reference2 = rule;
    var characters2 = type;
    while (scanning)
        switch (((previous = character2), (character2 = next()))) {
            case 40:
                if (previous != 108 && charat(characters2, length2 - 1) == 58) {
                    if (indexof((characters2 += replace(delimit(character2), "&", "&\f")), "&\f") != -1) ampersand = -1;
                    break;
                }
            case 34:
            case 39:
            case 91:
                characters2 += delimit(character2);
                break;
            case 9:
            case 10:
            case 13:
            case 32:
                characters2 += whitespace(previous);
                break;
            case 92:
                characters2 += escaping(caret() - 1, 7);
                continue;
            case 47:
                switch (peek()) {
                    case 42:
                    case 47:
                        append(comment(commenter(next(), caret()), root2, parent), declarations);
                        break;
                    default:
                        characters2 += "/";
                }
                break;
            case 123 * variable:
                points[index++] = strlen(characters2) * ampersand;
            case 125 * variable:
            case 59:
            case 0:
                switch (character2) {
                    case 0:
                    case 125:
                        scanning = 0;
                    case 59 + offset2:
                        if (ampersand == -1) characters2 = replace(characters2, /\f/g, "");
                        if (property > 0 && strlen(characters2) - length2)
                            append(
                                property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1) : declaration(replace(characters2, " ", "") + ";", rule, parent, length2 - 2),
                                declarations
                            );
                        break;
                    case 59:
                        characters2 += ";";
                    default:
                        append((reference2 = ruleset(characters2, root2, parent, index, offset2, rules, points, type, (props = []), (children = []), length2)), rulesets);
                        if (character2 === 123)
                            if (offset2 === 0) parse(characters2, root2, reference2, reference2, props, rulesets, length2, points, children);
                            else
                                switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                                    case 100:
                                    case 108:
                                    case 109:
                                    case 115:
                                        parse(
                                            value,
                                            reference2,
                                            reference2,
                                            rule && append(ruleset(value, reference2, reference2, 0, 0, rules, points, type, rules, (props = []), length2), children),
                                            rules,
                                            children,
                                            length2,
                                            points,
                                            rule ? props : children
                                        );
                                        break;
                                    default:
                                        parse(characters2, reference2, reference2, reference2, [""], children, 0, points, children);
                                }
                }
                (index = offset2 = property = 0), (variable = ampersand = 1), (type = characters2 = ""), (length2 = pseudo);
                break;
            case 58:
                (length2 = 1 + strlen(characters2)), (property = previous);
            default:
                if (variable < 1) {
                    if (character2 == 123) --variable;
                    else if (character2 == 125 && variable++ == 0 && prev() == 125) continue;
                }
                switch (((characters2 += from(character2)), character2 * variable)) {
                    case 38:
                        ampersand = offset2 > 0 ? 1 : ((characters2 += "\f"), -1);
                        break;
                    case 44:
                        (points[index++] = (strlen(characters2) - 1) * ampersand), (ampersand = 1);
                        break;
                    case 64:
                        if (peek() === 45) characters2 += delimit(next());
                        (atrule = peek()), (offset2 = length2 = strlen((type = characters2 += identifier(caret())))), character2++;
                        break;
                    case 45:
                        if (previous === 45 && strlen(characters2) == 2) variable = 0;
                }
        }
    return rulesets;
}
function ruleset(value, root2, parent, index, offset2, rules, points, type, props, children, length2) {
    var post = offset2 - 1;
    var rule = offset2 === 0 ? rules : [""];
    var size = sizeof(rule);
    for (var i = 0, j = 0, k2 = 0; i < index; ++i)
        for (var x2 = 0, y2 = substr(value, post + 1, (post = abs((j = points[i])))), z2 = value; x2 < size; ++x2)
            if ((z2 = trim(j > 0 ? rule[x2] + " " + y2 : replace(y2, /&\f/g, rule[x2])))) props[k2++] = z2;
    return node(value, root2, parent, offset2 === 0 ? RULESET : type, props, children, length2);
}
function comment(value, root2, parent) {
    return node(value, root2, parent, COMMENT, from(char()), substr(value, 2, -2), 0);
}
function declaration(value, root2, parent, length2) {
    return node(value, root2, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2);
}
function serialize(children, callback) {
    var output = "";
    var length2 = sizeof(children);
    for (var i = 0; i < length2; i++) output += callback(children[i], i, children, callback) || "";
    return output;
}
function stringify(element, index, children, callback) {
    switch (element.type) {
        case LAYER:
            if (element.children.length) break;
        case IMPORT:
        case DECLARATION:
            return (element.return = element.return || element.value);
        case COMMENT:
            return "";
        case KEYFRAMES:
            return (element.return = element.value + "{" + serialize(element.children, callback) + "}");
        case RULESET:
            element.value = element.props.join(",");
    }
    return strlen((children = serialize(element.children, callback))) ? (element.return = element.value + "{" + children + "}") : "";
}
function middleware(collection) {
    var length2 = sizeof(collection);
    return function (element, index, children, callback) {
        var output = "";
        for (var i = 0; i < length2; i++) output += collection[i](element, index, children, callback) || "";
        return output;
    };
}
function rulesheet(callback) {
    return function (element) {
        if (!element.root) {
            if ((element = element.return)) callback(element);
        }
    };
}
var identifierWithPointTracking = function identifierWithPointTracking2(begin, points, index) {
    var previous = 0;
    var character2 = 0;
    while (true) {
        previous = character2;
        character2 = peek();
        if (previous === 38 && character2 === 12) {
            points[index] = 1;
        }
        if (token(character2)) {
            break;
        }
        next();
    }
    return slice(begin, position);
};
var toRules = function toRules2(parsed, points) {
    var index = -1;
    var character2 = 44;
    do {
        switch (token(character2)) {
            case 0:
                if (character2 === 38 && peek() === 12) {
                    points[index] = 1;
                }
                parsed[index] += identifierWithPointTracking(position - 1, points, index);
                break;
            case 2:
                parsed[index] += delimit(character2);
                break;
            case 4:
                if (character2 === 44) {
                    parsed[++index] = peek() === 58 ? "&\f" : "";
                    points[index] = parsed[index].length;
                    break;
                }
            default:
                parsed[index] += from(character2);
        }
    } while ((character2 = next()));
    return parsed;
};
var getRules = function getRules2(value, points) {
    return dealloc(toRules(alloc(value), points));
};
var fixedElements = /* @__PURE__ */ new WeakMap();
var compat = function compat2(element) {
    if (
        element.type !== "rule" ||
        !element.parent || // positive .length indicates that this rule contains pseudo
        // negative .length indicates that this rule has been already prefixed
        element.length < 1
    ) {
        return;
    }
    var value = element.value,
        parent = element.parent;
    var isImplicitRule = element.column === parent.column && element.line === parent.line;
    while (parent.type !== "rule") {
        parent = parent.parent;
        if (!parent) return;
    }
    if (element.props.length === 1 && value.charCodeAt(0) !== 58 && !fixedElements.get(parent)) {
        return;
    }
    if (isImplicitRule) {
        return;
    }
    fixedElements.set(element, true);
    var points = [];
    var rules = getRules(value, points);
    var parentRules = parent.props;
    for (var i = 0, k2 = 0; i < rules.length; i++) {
        for (var j = 0; j < parentRules.length; j++, k2++) {
            element.props[k2] = points[i] ? rules[i].replace(/&\f/g, parentRules[j]) : parentRules[j] + " " + rules[i];
        }
    }
};
var removeLabel = function removeLabel2(element) {
    if (element.type === "decl") {
        var value = element.value;
        if (
            // charcode for l
            value.charCodeAt(0) === 108 && // charcode for b
            value.charCodeAt(2) === 98
        ) {
            element["return"] = "";
            element.value = "";
        }
    }
};
function prefix(value, length2) {
    switch (hash$2(value, length2)) {
        case 5103:
            return WEBKIT + "print-" + value + value;
        case 5737:
        case 4201:
        case 3177:
        case 3433:
        case 1641:
        case 4457:
        case 2921:
        case 5572:
        case 6356:
        case 5844:
        case 3191:
        case 6645:
        case 3005:
        case 6391:
        case 5879:
        case 5623:
        case 6135:
        case 4599:
        case 4855:
        case 4215:
        case 6389:
        case 5109:
        case 5365:
        case 5621:
        case 3829:
            return WEBKIT + value + value;
        case 5349:
        case 4246:
        case 4810:
        case 6968:
        case 2756:
            return WEBKIT + value + MOZ + value + MS + value + value;
        case 6828:
        case 4268:
            return WEBKIT + value + MS + value + value;
        case 6165:
            return WEBKIT + value + MS + "flex-" + value + value;
        case 5187:
            return WEBKIT + value + replace(value, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value;
        case 5443:
            return WEBKIT + value + MS + "flex-item-" + replace(value, /flex-|-self/, "") + value;
        case 4675:
            return WEBKIT + value + MS + "flex-line-pack" + replace(value, /align-content|flex-|-self/, "") + value;
        case 5548:
            return WEBKIT + value + MS + replace(value, "shrink", "negative") + value;
        case 5292:
            return WEBKIT + value + MS + replace(value, "basis", "preferred-size") + value;
        case 6060:
            return WEBKIT + "box-" + replace(value, "-grow", "") + WEBKIT + value + MS + replace(value, "grow", "positive") + value;
        case 4554:
            return WEBKIT + replace(value, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value;
        case 6187:
            return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value, "") + value;
        case 5495:
        case 3959:
            return replace(value, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
        case 4968:
            return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + value + value;
        case 4095:
        case 3583:
        case 4068:
        case 2532:
            return replace(value, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value;
        case 8116:
        case 7059:
        case 5753:
        case 5535:
        case 5445:
        case 5701:
        case 4933:
        case 4677:
        case 5533:
        case 5789:
        case 5021:
        case 4765:
            if (strlen(value) - 1 - length2 > 6)
                switch (charat(value, length2 + 1)) {
                    case 109:
                        if (charat(value, length2 + 4) !== 45) break;
                    case 102:
                        return replace(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value, length2 + 3) == 108 ? "$3" : "$2-$3")) + value;
                    case 115:
                        return ~indexof(value, "stretch") ? prefix(replace(value, "stretch", "fill-available"), length2) + value : value;
                }
            break;
        case 4949:
            if (charat(value, length2 + 1) !== 115) break;
        case 6444:
            switch (charat(value, strlen(value) - 3 - (~indexof(value, "!important") && 10))) {
                case 107:
                    return replace(value, ":", ":" + WEBKIT) + value;
                case 101:
                    return replace(value, /(.+:)([^;!]+)(;|!.+)?/, "$1" + WEBKIT + (charat(value, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value;
            }
            break;
        case 5936:
            switch (charat(value, length2 + 11)) {
                case 114:
                    return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
                case 108:
                    return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
                case 45:
                    return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
            }
            return WEBKIT + value + MS + value + value;
    }
    return value;
}
var prefixer = function prefixer2(element, index, children, callback) {
    if (element.length > -1) {
        if (!element["return"])
            switch (element.type) {
                case DECLARATION:
                    element["return"] = prefix(element.value, element.length);
                    break;
                case KEYFRAMES:
                    return serialize(
                        [
                            copy(element, {
                                value: replace(element.value, "@", "@" + WEBKIT),
                            }),
                        ],
                        callback
                    );
                case RULESET:
                    if (element.length)
                        return combine(element.props, function (value) {
                            switch (match(value, /(::plac\w+|:read-\w+)/)) {
                                case ":read-only":
                                case ":read-write":
                                    return serialize(
                                        [
                                            copy(element, {
                                                props: [replace(value, /:(read-\w+)/, ":" + MOZ + "$1")],
                                            }),
                                        ],
                                        callback
                                    );
                                case "::placeholder":
                                    return serialize(
                                        [
                                            copy(element, {
                                                props: [replace(value, /:(plac\w+)/, ":" + WEBKIT + "input-$1")],
                                            }),
                                            copy(element, {
                                                props: [replace(value, /:(plac\w+)/, ":" + MOZ + "$1")],
                                            }),
                                            copy(element, {
                                                props: [replace(value, /:(plac\w+)/, MS + "input-$1")],
                                            }),
                                        ],
                                        callback
                                    );
                            }
                            return "";
                        });
            }
    }
};
var defaultStylisPlugins = [prefixer];
var createCache = function createCache2(options) {
    var key = options.key;
    if (key === "css") {
        var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])");
        Array.prototype.forEach.call(ssrStyles, function (node2) {
            var dataEmotionAttribute = node2.getAttribute("data-emotion");
            if (dataEmotionAttribute.indexOf(" ") === -1) {
                return;
            }
            document.head.appendChild(node2);
            node2.setAttribute("data-s", "");
        });
    }
    var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;
    var inserted = {};
    var container2;
    var nodesToHydrate = [];
    {
        container2 = options.container || document.head;
        Array.prototype.forEach.call(
            // this means we will ignore elements which don't have a space in them which
            // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
            document.querySelectorAll('style[data-emotion^="' + key + ' "]'),
            function (node2) {
                var attrib = node2.getAttribute("data-emotion").split(" ");
                for (var i = 1; i < attrib.length; i++) {
                    inserted[attrib[i]] = true;
                }
                nodesToHydrate.push(node2);
            }
        );
    }
    var _insert;
    var omnipresentPlugins = [compat, removeLabel];
    {
        var currentSheet;
        var finalizingPlugins = [
            stringify,
            rulesheet(function (rule) {
                currentSheet.insert(rule);
            }),
        ];
        var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
        var stylis = function stylis2(styles2) {
            return serialize(compile(styles2), serializer);
        };
        _insert = function insert(selector, serialized, sheet, shouldCache) {
            currentSheet = sheet;
            stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
            if (shouldCache) {
                cache.inserted[serialized.name] = true;
            }
        };
    }
    var cache = {
        key,
        sheet: new StyleSheet({
            key,
            container: container2,
            nonce: options.nonce,
            speedy: options.speedy,
            prepend: options.prepend,
            insertionPoint: options.insertionPoint,
        }),
        nonce: options.nonce,
        inserted,
        registered: {},
        insert: _insert,
    };
    cache.sheet.hydrate(nodesToHydrate);
    return cache;
};
var reactIs$1 = { exports: {} };
var reactIs_production_min = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b = "function" === typeof Symbol && Symbol.for,
    c = b ? Symbol.for("react.element") : 60103,
    d = b ? Symbol.for("react.portal") : 60106,
    e = b ? Symbol.for("react.fragment") : 60107,
    f = b ? Symbol.for("react.strict_mode") : 60108,
    g = b ? Symbol.for("react.profiler") : 60114,
    h = b ? Symbol.for("react.provider") : 60109,
    k = b ? Symbol.for("react.context") : 60110,
    l = b ? Symbol.for("react.async_mode") : 60111,
    m = b ? Symbol.for("react.concurrent_mode") : 60111,
    n = b ? Symbol.for("react.forward_ref") : 60112,
    p = b ? Symbol.for("react.suspense") : 60113,
    q = b ? Symbol.for("react.suspense_list") : 60120,
    r$3 = b ? Symbol.for("react.memo") : 60115,
    t = b ? Symbol.for("react.lazy") : 60116,
    v = b ? Symbol.for("react.block") : 60121,
    w = b ? Symbol.for("react.fundamental") : 60117,
    x = b ? Symbol.for("react.responder") : 60118,
    y = b ? Symbol.for("react.scope") : 60119;
function z$1(a) {
    if ("object" === typeof a && null !== a) {
        var u2 = a.$$typeof;
        switch (u2) {
            case c:
                switch (((a = a.type), a)) {
                    case l:
                    case m:
                    case e:
                    case g:
                    case f:
                    case p:
                        return a;
                    default:
                        switch (((a = a && a.$$typeof), a)) {
                            case k:
                            case n:
                            case t:
                            case r$3:
                            case h:
                                return a;
                            default:
                                return u2;
                        }
                }
            case d:
                return u2;
        }
    }
}
function A(a) {
    return z$1(a) === m;
}
reactIs_production_min.AsyncMode = l;
reactIs_production_min.ConcurrentMode = m;
reactIs_production_min.ContextConsumer = k;
reactIs_production_min.ContextProvider = h;
reactIs_production_min.Element = c;
reactIs_production_min.ForwardRef = n;
reactIs_production_min.Fragment = e;
reactIs_production_min.Lazy = t;
reactIs_production_min.Memo = r$3;
reactIs_production_min.Portal = d;
reactIs_production_min.Profiler = g;
reactIs_production_min.StrictMode = f;
reactIs_production_min.Suspense = p;
reactIs_production_min.isAsyncMode = function (a) {
    return A(a) || z$1(a) === l;
};
reactIs_production_min.isConcurrentMode = A;
reactIs_production_min.isContextConsumer = function (a) {
    return z$1(a) === k;
};
reactIs_production_min.isContextProvider = function (a) {
    return z$1(a) === h;
};
reactIs_production_min.isElement = function (a) {
    return "object" === typeof a && null !== a && a.$$typeof === c;
};
reactIs_production_min.isForwardRef = function (a) {
    return z$1(a) === n;
};
reactIs_production_min.isFragment = function (a) {
    return z$1(a) === e;
};
reactIs_production_min.isLazy = function (a) {
    return z$1(a) === t;
};
reactIs_production_min.isMemo = function (a) {
    return z$1(a) === r$3;
};
reactIs_production_min.isPortal = function (a) {
    return z$1(a) === d;
};
reactIs_production_min.isProfiler = function (a) {
    return z$1(a) === g;
};
reactIs_production_min.isStrictMode = function (a) {
    return z$1(a) === f;
};
reactIs_production_min.isSuspense = function (a) {
    return z$1(a) === p;
};
reactIs_production_min.isValidElementType = function (a) {
    return (
        "string" === typeof a ||
        "function" === typeof a ||
        a === e ||
        a === m ||
        a === g ||
        a === f ||
        a === p ||
        a === q ||
        ("object" === typeof a &&
            null !== a &&
            (a.$$typeof === t || a.$$typeof === r$3 || a.$$typeof === h || a.$$typeof === k || a.$$typeof === n || a.$$typeof === w || a.$$typeof === x || a.$$typeof === y || a.$$typeof === v))
    );
};
reactIs_production_min.typeOf = z$1;
{
    reactIs$1.exports = reactIs_production_min;
}
var reactIsExports = reactIs$1.exports;
var reactIs = reactIsExports;
var FORWARD_REF_STATICS = {
    $$typeof: true,
    render: true,
    defaultProps: true,
    displayName: true,
    propTypes: true,
};
var MEMO_STATICS = {
    $$typeof: true,
    compare: true,
    defaultProps: true,
    displayName: true,
    propTypes: true,
    type: true,
};
var TYPE_STATICS = {};
TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
var isBrowser = true;
function getRegisteredStyles(registered, registeredStyles, classNames) {
    var rawClassName = "";
    classNames.split(" ").forEach(function (className) {
        if (registered[className] !== void 0) {
            registeredStyles.push(registered[className] + ";");
        } else {
            rawClassName += className + " ";
        }
    });
    return rawClassName;
}
var registerStyles = function registerStyles2(cache, serialized, isStringTag2) {
    var className = cache.key + "-" + serialized.name;
    if (
        // we only need to add the styles to the registered cache if the
        // class name could be used further down
        // the tree but if it's a string tag, we know it won't
        // so we don't have to add it to registered cache.
        // this improves memory usage since we can avoid storing the whole style string
        (isStringTag2 === false || // we need to always store it if we're in compat mode and
            // in node since emotion-server relies on whether a style is in
            // the registered cache to know whether a style is global or not
            // also, note that this check will be dead code eliminated in the browser
            isBrowser === false) &&
        cache.registered[className] === void 0
    ) {
        cache.registered[className] = serialized.styles;
    }
};
var insertStyles = function insertStyles2(cache, serialized, isStringTag2) {
    registerStyles(cache, serialized, isStringTag2);
    var className = cache.key + "-" + serialized.name;
    if (cache.inserted[serialized.name] === void 0) {
        var current = serialized;
        do {
            cache.insert(serialized === current ? "." + className : "", current, cache.sheet, true);
            current = current.next;
        } while (current !== void 0);
    }
};
function murmur2(str) {
    var h2 = 0;
    var k2,
        i = 0,
        len = str.length;
    for (; len >= 4; ++i, len -= 4) {
        k2 = (str.charCodeAt(i) & 255) | ((str.charCodeAt(++i) & 255) << 8) | ((str.charCodeAt(++i) & 255) << 16) | ((str.charCodeAt(++i) & 255) << 24);
        k2 = /* Math.imul(k, m): */ (k2 & 65535) * 1540483477 + (((k2 >>> 16) * 59797) << 16);
        k2 ^= /* k >>> r: */ k2 >>> 24;
        h2 = /* Math.imul(k, m): */ ((k2 & 65535) * 1540483477 + (((k2 >>> 16) * 59797) << 16)) /* Math.imul(h, m): */ ^ ((h2 & 65535) * 1540483477 + (((h2 >>> 16) * 59797) << 16));
    }
    switch (len) {
        case 3:
            h2 ^= (str.charCodeAt(i + 2) & 255) << 16;
        case 2:
            h2 ^= (str.charCodeAt(i + 1) & 255) << 8;
        case 1:
            h2 ^= str.charCodeAt(i) & 255;
            h2 = /* Math.imul(h, m): */ (h2 & 65535) * 1540483477 + (((h2 >>> 16) * 59797) << 16);
    }
    h2 ^= h2 >>> 13;
    h2 = /* Math.imul(h, m): */ (h2 & 65535) * 1540483477 + (((h2 >>> 16) * 59797) << 16);
    return ((h2 ^ (h2 >>> 15)) >>> 0).toString(36);
}
var unitlessKeys = {
    animationIterationCount: 1,
    borderImageOutset: 1,
    borderImageSlice: 1,
    borderImageWidth: 1,
    boxFlex: 1,
    boxFlexGroup: 1,
    boxOrdinalGroup: 1,
    columnCount: 1,
    columns: 1,
    flex: 1,
    flexGrow: 1,
    flexPositive: 1,
    flexShrink: 1,
    flexNegative: 1,
    flexOrder: 1,
    gridRow: 1,
    gridRowEnd: 1,
    gridRowSpan: 1,
    gridRowStart: 1,
    gridColumn: 1,
    gridColumnEnd: 1,
    gridColumnSpan: 1,
    gridColumnStart: 1,
    msGridRow: 1,
    msGridRowSpan: 1,
    msGridColumn: 1,
    msGridColumnSpan: 1,
    fontWeight: 1,
    lineHeight: 1,
    opacity: 1,
    order: 1,
    orphans: 1,
    tabSize: 1,
    widows: 1,
    zIndex: 1,
    zoom: 1,
    WebkitLineClamp: 1,
    // SVG-related properties
    fillOpacity: 1,
    floodOpacity: 1,
    stopOpacity: 1,
    strokeDasharray: 1,
    strokeDashoffset: 1,
    strokeMiterlimit: 1,
    strokeOpacity: 1,
    strokeWidth: 1,
};
var hyphenateRegex = /[A-Z]|^ms/g;
var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
var isCustomProperty = function isCustomProperty2(property) {
    return property.charCodeAt(1) === 45;
};
var isProcessableValue = function isProcessableValue2(value) {
    return value != null && typeof value !== "boolean";
};
var processStyleName = /* @__PURE__ */ memoize$1(function (styleName) {
    return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, "-$&").toLowerCase();
});
var processStyleValue = function processStyleValue2(key, value) {
    switch (key) {
        case "animation":
        case "animationName": {
            if (typeof value === "string") {
                return value.replace(animationRegex, function (match2, p1, p2) {
                    cursor = {
                        name: p1,
                        styles: p2,
                        next: cursor,
                    };
                    return p1;
                });
            }
        }
    }
    if (unitlessKeys[key] !== 1 && !isCustomProperty(key) && typeof value === "number" && value !== 0) {
        return value + "px";
    }
    return value;
};
var noComponentSelectorMessage = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
function handleInterpolation(mergedProps, registered, interpolation) {
    if (interpolation == null) {
        return "";
    }
    if (interpolation.__emotion_styles !== void 0) {
        return interpolation;
    }
    switch (typeof interpolation) {
        case "boolean": {
            return "";
        }
        case "object": {
            if (interpolation.anim === 1) {
                cursor = {
                    name: interpolation.name,
                    styles: interpolation.styles,
                    next: cursor,
                };
                return interpolation.name;
            }
            if (interpolation.styles !== void 0) {
                var next2 = interpolation.next;
                if (next2 !== void 0) {
                    while (next2 !== void 0) {
                        cursor = {
                            name: next2.name,
                            styles: next2.styles,
                            next: cursor,
                        };
                        next2 = next2.next;
                    }
                }
                var styles2 = interpolation.styles + ";";
                return styles2;
            }
            return createStringFromObject(mergedProps, registered, interpolation);
        }
        case "function": {
            if (mergedProps !== void 0) {
                var previousCursor = cursor;
                var result = interpolation(mergedProps);
                cursor = previousCursor;
                return handleInterpolation(mergedProps, registered, result);
            }
            break;
        }
    }
    if (registered == null) {
        return interpolation;
    }
    var cached = registered[interpolation];
    return cached !== void 0 ? cached : interpolation;
}
function createStringFromObject(mergedProps, registered, obj) {
    var string = "";
    if (Array.isArray(obj)) {
        for (var i = 0; i < obj.length; i++) {
            string += handleInterpolation(mergedProps, registered, obj[i]) + ";";
        }
    } else {
        for (var _key in obj) {
            var value = obj[_key];
            if (typeof value !== "object") {
                if (registered != null && registered[value] !== void 0) {
                    string += _key + "{" + registered[value] + "}";
                } else if (isProcessableValue(value)) {
                    string += processStyleName(_key) + ":" + processStyleValue(_key, value) + ";";
                }
            } else {
                if (_key === "NO_COMPONENT_SELECTOR" && false) {
                    throw new Error(noComponentSelectorMessage);
                }
                if (Array.isArray(value) && typeof value[0] === "string" && (registered == null || registered[value[0]] === void 0)) {
                    for (var _i = 0; _i < value.length; _i++) {
                        if (isProcessableValue(value[_i])) {
                            string += processStyleName(_key) + ":" + processStyleValue(_key, value[_i]) + ";";
                        }
                    }
                } else {
                    var interpolated = handleInterpolation(mergedProps, registered, value);
                    switch (_key) {
                        case "animation":
                        case "animationName": {
                            string += processStyleName(_key) + ":" + interpolated + ";";
                            break;
                        }
                        default: {
                            string += _key + "{" + interpolated + "}";
                        }
                    }
                }
            }
        }
    }
    return string;
}
var labelPattern = /label:\s*([^\s;\n{]+)\s*(;|$)/g;
var cursor;
var serializeStyles = function serializeStyles2(args, registered, mergedProps) {
    if (args.length === 1 && typeof args[0] === "object" && args[0] !== null && args[0].styles !== void 0) {
        return args[0];
    }
    var stringMode = true;
    var styles2 = "";
    cursor = void 0;
    var strings = args[0];
    if (strings == null || strings.raw === void 0) {
        stringMode = false;
        styles2 += handleInterpolation(mergedProps, registered, strings);
    } else {
        styles2 += strings[0];
    }
    for (var i = 1; i < args.length; i++) {
        styles2 += handleInterpolation(mergedProps, registered, args[i]);
        if (stringMode) {
            styles2 += strings[i];
        }
    }
    labelPattern.lastIndex = 0;
    var identifierName = "";
    var match2;
    while ((match2 = labelPattern.exec(styles2)) !== null) {
        identifierName +=
            "-" + // $FlowFixMe we know it's not null
            match2[1];
    }
    var name = murmur2(styles2) + identifierName;
    return {
        name,
        styles: styles2,
        next: cursor,
    };
};
var syncFallback = function syncFallback2(create) {
    return create();
};
var useInsertionEffect = React["useInsertionEffect"] ? React["useInsertionEffect"] : false;
var useInsertionEffectAlwaysWithSyncFallback = useInsertionEffect || syncFallback;
var useInsertionEffectWithLayoutFallback = useInsertionEffect || reactExports.useLayoutEffect;
var EmotionCacheContext = /* @__PURE__ */ reactExports.createContext(
    // we're doing this to avoid preconstruct's dead code elimination in this one case
    // because this module is primarily intended for the browser and node
    // but it's also required in react native and similar environments sometimes
    // and we could have a special build just for that
    // but this is much easier and the native packages
    // might use a different theme context in the future anyway
    typeof HTMLElement !== "undefined"
        ? /* @__PURE__ */ createCache({
              key: "css",
          })
        : null
);
EmotionCacheContext.Provider;
var withEmotionCache = function withEmotionCache2(func) {
    return /* @__PURE__ */ reactExports.forwardRef(function (props, ref) {
        var cache = reactExports.useContext(EmotionCacheContext);
        return func(props, cache, ref);
    });
};
var ThemeContext = /* @__PURE__ */ reactExports.createContext({});
var Global = /* @__PURE__ */ withEmotionCache(function (props, cache) {
    var styles2 = props.styles;
    var serialized = serializeStyles([styles2], void 0, reactExports.useContext(ThemeContext));
    var sheetRef = reactExports.useRef();
    useInsertionEffectWithLayoutFallback(
        function () {
            var key = cache.key + "-global";
            var sheet = new cache.sheet.constructor({
                key,
                nonce: cache.sheet.nonce,
                container: cache.sheet.container,
                speedy: cache.sheet.isSpeedy,
            });
            var rehydrating = false;
            var node2 = document.querySelector('style[data-emotion="' + key + " " + serialized.name + '"]');
            if (cache.sheet.tags.length) {
                sheet.before = cache.sheet.tags[0];
            }
            if (node2 !== null) {
                rehydrating = true;
                node2.setAttribute("data-emotion", key);
                sheet.hydrate([node2]);
            }
            sheetRef.current = [sheet, rehydrating];
            return function () {
                sheet.flush();
            };
        },
        [cache]
    );
    useInsertionEffectWithLayoutFallback(
        function () {
            var sheetRefCurrent = sheetRef.current;
            var sheet = sheetRefCurrent[0],
                rehydrating = sheetRefCurrent[1];
            if (rehydrating) {
                sheetRefCurrent[1] = false;
                return;
            }
            if (serialized.next !== void 0) {
                insertStyles(cache, serialized.next, true);
            }
            if (sheet.tags.length) {
                var element = sheet.tags[sheet.tags.length - 1].nextElementSibling;
                sheet.before = element;
                sheet.flush();
            }
            cache.insert("", serialized, sheet, false);
        },
        [cache, serialized.name]
    );
    return null;
});
function css() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
    }
    return serializeStyles(args);
}
var keyframes = function keyframes2() {
    var insertable = css.apply(void 0, arguments);
    var name = "animation-" + insertable.name;
    return {
        name,
        styles: "@keyframes " + name + "{" + insertable.styles + "}",
        anim: 1,
        toString: function toString() {
            return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
        },
    };
};
var testOmitPropsOnStringTag = isPropValid;
var testOmitPropsOnComponent = function testOmitPropsOnComponent2(key) {
    return key !== "theme";
};
var getDefaultShouldForwardProp = function getDefaultShouldForwardProp2(tag) {
    return typeof tag === "string" && // 96 is one less than the char code
        // for "a" so this is checking that
        // it's a lowercase character
        tag.charCodeAt(0) > 96
        ? testOmitPropsOnStringTag
        : testOmitPropsOnComponent;
};
var composeShouldForwardProps = function composeShouldForwardProps2(tag, options, isReal) {
    var shouldForwardProp2;
    if (options) {
        var optionsShouldForwardProp = options.shouldForwardProp;
        shouldForwardProp2 =
            tag.__emotion_forwardProp && optionsShouldForwardProp
                ? function (propName) {
                      return tag.__emotion_forwardProp(propName) && optionsShouldForwardProp(propName);
                  }
                : optionsShouldForwardProp;
    }
    if (typeof shouldForwardProp2 !== "function" && isReal) {
        shouldForwardProp2 = tag.__emotion_forwardProp;
    }
    return shouldForwardProp2;
};
var Insertion = function Insertion2(_ref) {
    var cache = _ref.cache,
        serialized = _ref.serialized,
        isStringTag2 = _ref.isStringTag;
    registerStyles(cache, serialized, isStringTag2);
    useInsertionEffectAlwaysWithSyncFallback(function () {
        return insertStyles(cache, serialized, isStringTag2);
    });
    return null;
};
var createStyled$1 = function createStyled(tag, options) {
    var isReal = tag.__emotion_real === tag;
    var baseTag = (isReal && tag.__emotion_base) || tag;
    var identifierName;
    var targetClassName;
    if (options !== void 0) {
        identifierName = options.label;
        targetClassName = options.target;
    }
    var shouldForwardProp2 = composeShouldForwardProps(tag, options, isReal);
    var defaultShouldForwardProp = shouldForwardProp2 || getDefaultShouldForwardProp(baseTag);
    var shouldUseAs = !defaultShouldForwardProp("as");
    return function () {
        var args = arguments;
        var styles2 = isReal && tag.__emotion_styles !== void 0 ? tag.__emotion_styles.slice(0) : [];
        if (identifierName !== void 0) {
            styles2.push("label:" + identifierName + ";");
        }
        if (args[0] == null || args[0].raw === void 0) {
            styles2.push.apply(styles2, args);
        } else {
            styles2.push(args[0][0]);
            var len = args.length;
            var i = 1;
            for (; i < len; i++) {
                styles2.push(args[i], args[0][i]);
            }
        }
        var Styled = withEmotionCache(function (props, cache, ref) {
            var FinalTag = (shouldUseAs && props.as) || baseTag;
            var className = "";
            var classInterpolations = [];
            var mergedProps = props;
            if (props.theme == null) {
                mergedProps = {};
                for (var key in props) {
                    mergedProps[key] = props[key];
                }
                mergedProps.theme = reactExports.useContext(ThemeContext);
            }
            if (typeof props.className === "string") {
                className = getRegisteredStyles(cache.registered, classInterpolations, props.className);
            } else if (props.className != null) {
                className = props.className + " ";
            }
            var serialized = serializeStyles(styles2.concat(classInterpolations), cache.registered, mergedProps);
            className += cache.key + "-" + serialized.name;
            if (targetClassName !== void 0) {
                className += " " + targetClassName;
            }
            var finalShouldForwardProp = shouldUseAs && shouldForwardProp2 === void 0 ? getDefaultShouldForwardProp(FinalTag) : defaultShouldForwardProp;
            var newProps = {};
            for (var _key in props) {
                if (shouldUseAs && _key === "as") continue;
                if (
                    // $FlowFixMe
                    finalShouldForwardProp(_key)
                ) {
                    newProps[_key] = props[_key];
                }
            }
            newProps.className = className;
            newProps.ref = ref;
            return /* @__PURE__ */ reactExports.createElement(
                reactExports.Fragment,
                null,
                /* @__PURE__ */ reactExports.createElement(Insertion, {
                    cache,
                    serialized,
                    isStringTag: typeof FinalTag === "string",
                }),
                /* @__PURE__ */ reactExports.createElement(FinalTag, newProps)
            );
        });
        Styled.displayName = identifierName !== void 0 ? identifierName : "Styled(" + (typeof baseTag === "string" ? baseTag : baseTag.displayName || baseTag.name || "Component") + ")";
        Styled.defaultProps = tag.defaultProps;
        Styled.__emotion_real = Styled;
        Styled.__emotion_base = baseTag;
        Styled.__emotion_styles = styles2;
        Styled.__emotion_forwardProp = shouldForwardProp2;
        Object.defineProperty(Styled, "toString", {
            value: function value() {
                if (targetClassName === void 0 && false) {
                    return "NO_COMPONENT_SELECTOR";
                }
                return "." + targetClassName;
            },
        });
        Styled.withComponent = function (nextTag, nextOptions) {
            return createStyled(
                nextTag,
                _extends({}, options, nextOptions, {
                    shouldForwardProp: composeShouldForwardProps(Styled, nextOptions, true),
                })
            ).apply(void 0, styles2);
        };
        return Styled;
    };
};
const createStyled$2 = createStyled$1;
var tags = [
    "a",
    "abbr",
    "address",
    "area",
    "article",
    "aside",
    "audio",
    "b",
    "base",
    "bdi",
    "bdo",
    "big",
    "blockquote",
    "body",
    "br",
    "button",
    "canvas",
    "caption",
    "cite",
    "code",
    "col",
    "colgroup",
    "data",
    "datalist",
    "dd",
    "del",
    "details",
    "dfn",
    "dialog",
    "div",
    "dl",
    "dt",
    "em",
    "embed",
    "fieldset",
    "figcaption",
    "figure",
    "footer",
    "form",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "head",
    "header",
    "hgroup",
    "hr",
    "html",
    "i",
    "iframe",
    "img",
    "input",
    "ins",
    "kbd",
    "keygen",
    "label",
    "legend",
    "li",
    "link",
    "main",
    "map",
    "mark",
    "marquee",
    "menu",
    "menuitem",
    "meta",
    "meter",
    "nav",
    "noscript",
    "object",
    "ol",
    "optgroup",
    "option",
    "output",
    "p",
    "param",
    "picture",
    "pre",
    "progress",
    "q",
    "rp",
    "rt",
    "ruby",
    "s",
    "samp",
    "script",
    "section",
    "select",
    "small",
    "source",
    "span",
    "strong",
    "style",
    "sub",
    "summary",
    "sup",
    "table",
    "tbody",
    "td",
    "textarea",
    "tfoot",
    "th",
    "thead",
    "time",
    "title",
    "tr",
    "track",
    "u",
    "ul",
    "var",
    "video",
    "wbr",
    // SVG
    "circle",
    "clipPath",
    "defs",
    "ellipse",
    "foreignObject",
    "g",
    "image",
    "line",
    "linearGradient",
    "mask",
    "path",
    "pattern",
    "polygon",
    "polyline",
    "radialGradient",
    "rect",
    "stop",
    "svg",
    "text",
    "tspan",
];
var newStyled = createStyled$2.bind();
tags.forEach(function (tagName) {
    newStyled[tagName] = newStyled(tagName);
});
const emStyled = newStyled;
function isEmpty$4(obj) {
    return obj === void 0 || obj === null || Object.keys(obj).length === 0;
}
function GlobalStyles$2(props) {
    const { styles: styles2, defaultTheme: defaultTheme2 = {} } = props;
    const globalStyles = typeof styles2 === "function" ? (themeInput) => styles2(isEmpty$4(themeInput) ? defaultTheme2 : themeInput) : styles2;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Global, {
        styles: globalStyles,
    });
}
/**
 * @mui/styled-engine v5.14.12
 *
 * @license MIT
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
function styled$3(tag, options) {
    const stylesFactory = emStyled(tag, options);
    return stylesFactory;
}
const internal_processStyles = (tag, processor) => {
    if (Array.isArray(tag.__emotion_styles)) {
        tag.__emotion_styles = processor(tag.__emotion_styles);
    }
};
const _excluded$17 = ["values", "unit", "step"];
const sortBreakpointsValues = (values2) => {
    const breakpointsAsArray =
        Object.keys(values2).map((key) => ({
            key,
            val: values2[key],
        })) || [];
    breakpointsAsArray.sort((breakpoint1, breakpoint2) => breakpoint1.val - breakpoint2.val);
    return breakpointsAsArray.reduce((acc, obj) => {
        return _extends({}, acc, {
            [obj.key]: obj.val,
        });
    }, {});
};
function createBreakpoints(breakpoints) {
    const {
            // The breakpoint **start** at this value.
            // For instance with the first breakpoint xs: [xs, sm).
            values: values2 = {
                xs: 0,
                // phone
                sm: 600,
                // tablet
                md: 900,
                // small laptop
                lg: 1200,
                // desktop
                xl: 1536,
                // large screen
            },
            unit = "px",
            step = 5,
        } = breakpoints,
        other = _objectWithoutPropertiesLoose(breakpoints, _excluded$17);
    const sortedValues = sortBreakpointsValues(values2);
    const keys = Object.keys(sortedValues);
    function up(key) {
        const value = typeof values2[key] === "number" ? values2[key] : key;
        return `@media (min-width:${value}${unit})`;
    }
    function down(key) {
        const value = typeof values2[key] === "number" ? values2[key] : key;
        return `@media (max-width:${value - step / 100}${unit})`;
    }
    function between(start2, end2) {
        const endIndex = keys.indexOf(end2);
        return `@media (min-width:${typeof values2[start2] === "number" ? values2[start2] : start2}${unit}) and (max-width:${
            (endIndex !== -1 && typeof values2[keys[endIndex]] === "number" ? values2[keys[endIndex]] : end2) - step / 100
        }${unit})`;
    }
    function only(key) {
        if (keys.indexOf(key) + 1 < keys.length) {
            return between(key, keys[keys.indexOf(key) + 1]);
        }
        return up(key);
    }
    function not(key) {
        const keyIndex = keys.indexOf(key);
        if (keyIndex === 0) {
            return up(keys[1]);
        }
        if (keyIndex === keys.length - 1) {
            return down(keys[keyIndex]);
        }
        return between(key, keys[keys.indexOf(key) + 1]).replace("@media", "@media not all and");
    }
    return _extends(
        {
            keys,
            values: sortedValues,
            up,
            down,
            between,
            only,
            not,
            unit,
        },
        other
    );
}
const shape = {
    borderRadius: 4,
};
const shape$1 = shape;
function merge(acc, item) {
    if (!item) {
        return acc;
    }
    return deepmerge(acc, item, {
        clone: false,
        // No need to clone deep, it's way faster.
    });
}
const values$1 = {
    xs: 0,
    // phone
    sm: 600,
    // tablet
    md: 900,
    // small laptop
    lg: 1200,
    // desktop
    xl: 1536,
    // large screen
};
const defaultBreakpoints = {
    // Sorted ASC by size. That's important.
    // It can't be configured as it's used statically for propTypes.
    keys: ["xs", "sm", "md", "lg", "xl"],
    up: (key) => `@media (min-width:${values$1[key]}px)`,
};
function handleBreakpoints(props, propValue, styleFromPropValue) {
    const theme = props.theme || {};
    if (Array.isArray(propValue)) {
        const themeBreakpoints = theme.breakpoints || defaultBreakpoints;
        return propValue.reduce((acc, item, index) => {
            acc[themeBreakpoints.up(themeBreakpoints.keys[index])] = styleFromPropValue(propValue[index]);
            return acc;
        }, {});
    }
    if (typeof propValue === "object") {
        const themeBreakpoints = theme.breakpoints || defaultBreakpoints;
        return Object.keys(propValue).reduce((acc, breakpoint) => {
            if (Object.keys(themeBreakpoints.values || values$1).indexOf(breakpoint) !== -1) {
                const mediaKey = themeBreakpoints.up(breakpoint);
                acc[mediaKey] = styleFromPropValue(propValue[breakpoint], breakpoint);
            } else {
                const cssKey = breakpoint;
                acc[cssKey] = propValue[cssKey];
            }
            return acc;
        }, {});
    }
    const output = styleFromPropValue(propValue);
    return output;
}
function createEmptyBreakpointObject(breakpointsInput = {}) {
    var _breakpointsInput$key;
    const breakpointsInOrder =
        (_breakpointsInput$key = breakpointsInput.keys) == null
            ? void 0
            : _breakpointsInput$key.reduce((acc, key) => {
                  const breakpointStyleKey = breakpointsInput.up(key);
                  acc[breakpointStyleKey] = {};
                  return acc;
              }, {});
    return breakpointsInOrder || {};
}
function removeUnusedBreakpoints(breakpointKeys, style2) {
    return breakpointKeys.reduce((acc, key) => {
        const breakpointOutput = acc[key];
        const isBreakpointUnused = !breakpointOutput || Object.keys(breakpointOutput).length === 0;
        if (isBreakpointUnused) {
            delete acc[key];
        }
        return acc;
    }, style2);
}
function mergeBreakpointsInOrder(breakpointsInput, ...styles2) {
    const emptyBreakpoints = createEmptyBreakpointObject(breakpointsInput);
    const mergedOutput = [emptyBreakpoints, ...styles2].reduce((prev2, next2) => deepmerge(prev2, next2), {});
    return removeUnusedBreakpoints(Object.keys(emptyBreakpoints), mergedOutput);
}
function computeBreakpointsBase(breakpointValues, themeBreakpoints) {
    if (typeof breakpointValues !== "object") {
        return {};
    }
    const base = {};
    const breakpointsKeys = Object.keys(themeBreakpoints);
    if (Array.isArray(breakpointValues)) {
        breakpointsKeys.forEach((breakpoint, i) => {
            if (i < breakpointValues.length) {
                base[breakpoint] = true;
            }
        });
    } else {
        breakpointsKeys.forEach((breakpoint) => {
            if (breakpointValues[breakpoint] != null) {
                base[breakpoint] = true;
            }
        });
    }
    return base;
}
function resolveBreakpointValues({ values: breakpointValues, breakpoints: themeBreakpoints, base: customBase }) {
    const base = customBase || computeBreakpointsBase(breakpointValues, themeBreakpoints);
    const keys = Object.keys(base);
    if (keys.length === 0) {
        return breakpointValues;
    }
    let previous;
    return keys.reduce((acc, breakpoint, i) => {
        if (Array.isArray(breakpointValues)) {
            acc[breakpoint] = breakpointValues[i] != null ? breakpointValues[i] : breakpointValues[previous];
            previous = i;
        } else if (typeof breakpointValues === "object") {
            acc[breakpoint] = breakpointValues[breakpoint] != null ? breakpointValues[breakpoint] : breakpointValues[previous];
            previous = breakpoint;
        } else {
            acc[breakpoint] = breakpointValues;
        }
        return acc;
    }, {});
}
function getPath(obj, path, checkVars = true) {
    if (!path || typeof path !== "string") {
        return null;
    }
    if (obj && obj.vars && checkVars) {
        const val = `vars.${path}`.split(".").reduce((acc, item) => (acc && acc[item] ? acc[item] : null), obj);
        if (val != null) {
            return val;
        }
    }
    return path.split(".").reduce((acc, item) => {
        if (acc && acc[item] != null) {
            return acc[item];
        }
        return null;
    }, obj);
}
function getStyleValue$1(themeMapping, transform, propValueFinal, userValue = propValueFinal) {
    let value;
    if (typeof themeMapping === "function") {
        value = themeMapping(propValueFinal);
    } else if (Array.isArray(themeMapping)) {
        value = themeMapping[propValueFinal] || userValue;
    } else {
        value = getPath(themeMapping, propValueFinal) || userValue;
    }
    if (transform) {
        value = transform(value, userValue, themeMapping);
    }
    return value;
}
function style$3(options) {
    const { prop, cssProperty = options.prop, themeKey, transform } = options;
    const fn2 = (props) => {
        if (props[prop] == null) {
            return null;
        }
        const propValue = props[prop];
        const theme = props.theme;
        const themeMapping = getPath(theme, themeKey) || {};
        const styleFromPropValue = (propValueFinal) => {
            let value = getStyleValue$1(themeMapping, transform, propValueFinal);
            if (propValueFinal === value && typeof propValueFinal === "string") {
                value = getStyleValue$1(themeMapping, transform, `${prop}${propValueFinal === "default" ? "" : capitalize(propValueFinal)}`, propValueFinal);
            }
            if (cssProperty === false) {
                return value;
            }
            return {
                [cssProperty]: value,
            };
        };
        return handleBreakpoints(props, propValue, styleFromPropValue);
    };
    fn2.propTypes = {};
    fn2.filterProps = [prop];
    return fn2;
}
function memoize(fn2) {
    const cache = {};
    return (arg) => {
        if (cache[arg] === void 0) {
            cache[arg] = fn2(arg);
        }
        return cache[arg];
    };
}
const properties = {
    m: "margin",
    p: "padding",
};
const directions = {
    t: "Top",
    r: "Right",
    b: "Bottom",
    l: "Left",
    x: ["Left", "Right"],
    y: ["Top", "Bottom"],
};
const aliases = {
    marginX: "mx",
    marginY: "my",
    paddingX: "px",
    paddingY: "py",
};
const getCssProperties = memoize((prop) => {
    if (prop.length > 2) {
        if (aliases[prop]) {
            prop = aliases[prop];
        } else {
            return [prop];
        }
    }
    const [a, b2] = prop.split("");
    const property = properties[a];
    const direction = directions[b2] || "";
    return Array.isArray(direction) ? direction.map((dir) => property + dir) : [property + direction];
});
const marginKeys = [
    "m",
    "mt",
    "mr",
    "mb",
    "ml",
    "mx",
    "my",
    "margin",
    "marginTop",
    "marginRight",
    "marginBottom",
    "marginLeft",
    "marginX",
    "marginY",
    "marginInline",
    "marginInlineStart",
    "marginInlineEnd",
    "marginBlock",
    "marginBlockStart",
    "marginBlockEnd",
];
const paddingKeys = [
    "p",
    "pt",
    "pr",
    "pb",
    "pl",
    "px",
    "py",
    "padding",
    "paddingTop",
    "paddingRight",
    "paddingBottom",
    "paddingLeft",
    "paddingX",
    "paddingY",
    "paddingInline",
    "paddingInlineStart",
    "paddingInlineEnd",
    "paddingBlock",
    "paddingBlockStart",
    "paddingBlockEnd",
];
[...marginKeys, ...paddingKeys];
function createUnaryUnit(theme, themeKey, defaultValue, propName) {
    var _getPath;
    const themeSpacing = (_getPath = getPath(theme, themeKey, false)) != null ? _getPath : defaultValue;
    if (typeof themeSpacing === "number") {
        return (abs2) => {
            if (typeof abs2 === "string") {
                return abs2;
            }
            return themeSpacing * abs2;
        };
    }
    if (Array.isArray(themeSpacing)) {
        return (abs2) => {
            if (typeof abs2 === "string") {
                return abs2;
            }
            return themeSpacing[abs2];
        };
    }
    if (typeof themeSpacing === "function") {
        return themeSpacing;
    }
    return () => void 0;
}
function createUnarySpacing(theme) {
    return createUnaryUnit(theme, "spacing", 8);
}
function getValue(transformer, propValue) {
    if (typeof propValue === "string" || propValue == null) {
        return propValue;
    }
    const abs2 = Math.abs(propValue);
    const transformed = transformer(abs2);
    if (propValue >= 0) {
        return transformed;
    }
    if (typeof transformed === "number") {
        return -transformed;
    }
    return `-${transformed}`;
}
function getStyleFromPropValue(cssProperties, transformer) {
    return (propValue) =>
        cssProperties.reduce((acc, cssProperty) => {
            acc[cssProperty] = getValue(transformer, propValue);
            return acc;
        }, {});
}
function resolveCssProperty(props, keys, prop, transformer) {
    if (keys.indexOf(prop) === -1) {
        return null;
    }
    const cssProperties = getCssProperties(prop);
    const styleFromPropValue = getStyleFromPropValue(cssProperties, transformer);
    const propValue = props[prop];
    return handleBreakpoints(props, propValue, styleFromPropValue);
}
function style$2(props, keys) {
    const transformer = createUnarySpacing(props.theme);
    return Object.keys(props)
        .map((prop) => resolveCssProperty(props, keys, prop, transformer))
        .reduce(merge, {});
}
function margin(props) {
    return style$2(props, marginKeys);
}
margin.propTypes = {};
margin.filterProps = marginKeys;
function padding(props) {
    return style$2(props, paddingKeys);
}
padding.propTypes = {};
padding.filterProps = paddingKeys;
function createSpacing(spacingInput = 8) {
    if (spacingInput.mui) {
        return spacingInput;
    }
    const transform = createUnarySpacing({
        spacing: spacingInput,
    });
    const spacing = (...argsInput) => {
        const args = argsInput.length === 0 ? [1] : argsInput;
        return args
            .map((argument) => {
                const output = transform(argument);
                return typeof output === "number" ? `${output}px` : output;
            })
            .join(" ");
    };
    spacing.mui = true;
    return spacing;
}
function compose(...styles2) {
    const handlers = styles2.reduce((acc, style2) => {
        style2.filterProps.forEach((prop) => {
            acc[prop] = style2;
        });
        return acc;
    }, {});
    const fn2 = (props) => {
        return Object.keys(props).reduce((acc, prop) => {
            if (handlers[prop]) {
                return merge(acc, handlers[prop](props));
            }
            return acc;
        }, {});
    };
    fn2.propTypes = {};
    fn2.filterProps = styles2.reduce((acc, style2) => acc.concat(style2.filterProps), []);
    return fn2;
}
function borderTransform(value) {
    if (typeof value !== "number") {
        return value;
    }
    return `${value}px solid`;
}
const border = style$3({
    prop: "border",
    themeKey: "borders",
    transform: borderTransform,
});
const borderTop = style$3({
    prop: "borderTop",
    themeKey: "borders",
    transform: borderTransform,
});
const borderRight = style$3({
    prop: "borderRight",
    themeKey: "borders",
    transform: borderTransform,
});
const borderBottom = style$3({
    prop: "borderBottom",
    themeKey: "borders",
    transform: borderTransform,
});
const borderLeft = style$3({
    prop: "borderLeft",
    themeKey: "borders",
    transform: borderTransform,
});
const borderColor = style$3({
    prop: "borderColor",
    themeKey: "palette",
});
const borderTopColor = style$3({
    prop: "borderTopColor",
    themeKey: "palette",
});
const borderRightColor = style$3({
    prop: "borderRightColor",
    themeKey: "palette",
});
const borderBottomColor = style$3({
    prop: "borderBottomColor",
    themeKey: "palette",
});
const borderLeftColor = style$3({
    prop: "borderLeftColor",
    themeKey: "palette",
});
const borderRadius = (props) => {
    if (props.borderRadius !== void 0 && props.borderRadius !== null) {
        const transformer = createUnaryUnit(props.theme, "shape.borderRadius", 4);
        const styleFromPropValue = (propValue) => ({
            borderRadius: getValue(transformer, propValue),
        });
        return handleBreakpoints(props, props.borderRadius, styleFromPropValue);
    }
    return null;
};
borderRadius.propTypes = {};
borderRadius.filterProps = ["borderRadius"];
compose(border, borderTop, borderRight, borderBottom, borderLeft, borderColor, borderTopColor, borderRightColor, borderBottomColor, borderLeftColor, borderRadius);
const gap = (props) => {
    if (props.gap !== void 0 && props.gap !== null) {
        const transformer = createUnaryUnit(props.theme, "spacing", 8);
        const styleFromPropValue = (propValue) => ({
            gap: getValue(transformer, propValue),
        });
        return handleBreakpoints(props, props.gap, styleFromPropValue);
    }
    return null;
};
gap.propTypes = {};
gap.filterProps = ["gap"];
const columnGap = (props) => {
    if (props.columnGap !== void 0 && props.columnGap !== null) {
        const transformer = createUnaryUnit(props.theme, "spacing", 8);
        const styleFromPropValue = (propValue) => ({
            columnGap: getValue(transformer, propValue),
        });
        return handleBreakpoints(props, props.columnGap, styleFromPropValue);
    }
    return null;
};
columnGap.propTypes = {};
columnGap.filterProps = ["columnGap"];
const rowGap = (props) => {
    if (props.rowGap !== void 0 && props.rowGap !== null) {
        const transformer = createUnaryUnit(props.theme, "spacing", 8);
        const styleFromPropValue = (propValue) => ({
            rowGap: getValue(transformer, propValue),
        });
        return handleBreakpoints(props, props.rowGap, styleFromPropValue);
    }
    return null;
};
rowGap.propTypes = {};
rowGap.filterProps = ["rowGap"];
const gridColumn = style$3({
    prop: "gridColumn",
});
const gridRow = style$3({
    prop: "gridRow",
});
const gridAutoFlow = style$3({
    prop: "gridAutoFlow",
});
const gridAutoColumns = style$3({
    prop: "gridAutoColumns",
});
const gridAutoRows = style$3({
    prop: "gridAutoRows",
});
const gridTemplateColumns = style$3({
    prop: "gridTemplateColumns",
});
const gridTemplateRows = style$3({
    prop: "gridTemplateRows",
});
const gridTemplateAreas = style$3({
    prop: "gridTemplateAreas",
});
const gridArea = style$3({
    prop: "gridArea",
});
compose(gap, columnGap, rowGap, gridColumn, gridRow, gridAutoFlow, gridAutoColumns, gridAutoRows, gridTemplateColumns, gridTemplateRows, gridTemplateAreas, gridArea);
function paletteTransform(value, userValue) {
    if (userValue === "grey") {
        return userValue;
    }
    return value;
}
const color = style$3({
    prop: "color",
    themeKey: "palette",
    transform: paletteTransform,
});
const bgcolor = style$3({
    prop: "bgcolor",
    cssProperty: "backgroundColor",
    themeKey: "palette",
    transform: paletteTransform,
});
const backgroundColor = style$3({
    prop: "backgroundColor",
    themeKey: "palette",
    transform: paletteTransform,
});
compose(color, bgcolor, backgroundColor);
function sizingTransform(value) {
    return value <= 1 && value !== 0 ? `${value * 100}%` : value;
}
const width = style$3({
    prop: "width",
    transform: sizingTransform,
});
const maxWidth = (props) => {
    if (props.maxWidth !== void 0 && props.maxWidth !== null) {
        const styleFromPropValue = (propValue) => {
            var _props$theme, _props$theme2;
            const breakpoint =
                ((_props$theme = props.theme) == null || (_props$theme = _props$theme.breakpoints) == null || (_props$theme = _props$theme.values) == null ? void 0 : _props$theme[propValue]) ||
                values$1[propValue];
            if (!breakpoint) {
                return {
                    maxWidth: sizingTransform(propValue),
                };
            }
            if (((_props$theme2 = props.theme) == null || (_props$theme2 = _props$theme2.breakpoints) == null ? void 0 : _props$theme2.unit) !== "px") {
                return {
                    maxWidth: `${breakpoint}${props.theme.breakpoints.unit}`,
                };
            }
            return {
                maxWidth: breakpoint,
            };
        };
        return handleBreakpoints(props, props.maxWidth, styleFromPropValue);
    }
    return null;
};
maxWidth.filterProps = ["maxWidth"];
const minWidth = style$3({
    prop: "minWidth",
    transform: sizingTransform,
});
const height = style$3({
    prop: "height",
    transform: sizingTransform,
});
const maxHeight = style$3({
    prop: "maxHeight",
    transform: sizingTransform,
});
const minHeight = style$3({
    prop: "minHeight",
    transform: sizingTransform,
});
style$3({
    prop: "size",
    cssProperty: "width",
    transform: sizingTransform,
});
style$3({
    prop: "size",
    cssProperty: "height",
    transform: sizingTransform,
});
const boxSizing = style$3({
    prop: "boxSizing",
});
compose(width, maxWidth, minWidth, height, maxHeight, minHeight, boxSizing);
const defaultSxConfig = {
    // borders
    border: {
        themeKey: "borders",
        transform: borderTransform,
    },
    borderTop: {
        themeKey: "borders",
        transform: borderTransform,
    },
    borderRight: {
        themeKey: "borders",
        transform: borderTransform,
    },
    borderBottom: {
        themeKey: "borders",
        transform: borderTransform,
    },
    borderLeft: {
        themeKey: "borders",
        transform: borderTransform,
    },
    borderColor: {
        themeKey: "palette",
    },
    borderTopColor: {
        themeKey: "palette",
    },
    borderRightColor: {
        themeKey: "palette",
    },
    borderBottomColor: {
        themeKey: "palette",
    },
    borderLeftColor: {
        themeKey: "palette",
    },
    borderRadius: {
        themeKey: "shape.borderRadius",
        style: borderRadius,
    },
    // palette
    color: {
        themeKey: "palette",
        transform: paletteTransform,
    },
    bgcolor: {
        themeKey: "palette",
        cssProperty: "backgroundColor",
        transform: paletteTransform,
    },
    backgroundColor: {
        themeKey: "palette",
        transform: paletteTransform,
    },
    // spacing
    p: {
        style: padding,
    },
    pt: {
        style: padding,
    },
    pr: {
        style: padding,
    },
    pb: {
        style: padding,
    },
    pl: {
        style: padding,
    },
    px: {
        style: padding,
    },
    py: {
        style: padding,
    },
    padding: {
        style: padding,
    },
    paddingTop: {
        style: padding,
    },
    paddingRight: {
        style: padding,
    },
    paddingBottom: {
        style: padding,
    },
    paddingLeft: {
        style: padding,
    },
    paddingX: {
        style: padding,
    },
    paddingY: {
        style: padding,
    },
    paddingInline: {
        style: padding,
    },
    paddingInlineStart: {
        style: padding,
    },
    paddingInlineEnd: {
        style: padding,
    },
    paddingBlock: {
        style: padding,
    },
    paddingBlockStart: {
        style: padding,
    },
    paddingBlockEnd: {
        style: padding,
    },
    m: {
        style: margin,
    },
    mt: {
        style: margin,
    },
    mr: {
        style: margin,
    },
    mb: {
        style: margin,
    },
    ml: {
        style: margin,
    },
    mx: {
        style: margin,
    },
    my: {
        style: margin,
    },
    margin: {
        style: margin,
    },
    marginTop: {
        style: margin,
    },
    marginRight: {
        style: margin,
    },
    marginBottom: {
        style: margin,
    },
    marginLeft: {
        style: margin,
    },
    marginX: {
        style: margin,
    },
    marginY: {
        style: margin,
    },
    marginInline: {
        style: margin,
    },
    marginInlineStart: {
        style: margin,
    },
    marginInlineEnd: {
        style: margin,
    },
    marginBlock: {
        style: margin,
    },
    marginBlockStart: {
        style: margin,
    },
    marginBlockEnd: {
        style: margin,
    },
    // display
    displayPrint: {
        cssProperty: false,
        transform: (value) => ({
            "@media print": {
                display: value,
            },
        }),
    },
    display: {},
    overflow: {},
    textOverflow: {},
    visibility: {},
    whiteSpace: {},
    // flexbox
    flexBasis: {},
    flexDirection: {},
    flexWrap: {},
    justifyContent: {},
    alignItems: {},
    alignContent: {},
    order: {},
    flex: {},
    flexGrow: {},
    flexShrink: {},
    alignSelf: {},
    justifyItems: {},
    justifySelf: {},
    // grid
    gap: {
        style: gap,
    },
    rowGap: {
        style: rowGap,
    },
    columnGap: {
        style: columnGap,
    },
    gridColumn: {},
    gridRow: {},
    gridAutoFlow: {},
    gridAutoColumns: {},
    gridAutoRows: {},
    gridTemplateColumns: {},
    gridTemplateRows: {},
    gridTemplateAreas: {},
    gridArea: {},
    // positions
    position: {},
    zIndex: {
        themeKey: "zIndex",
    },
    top: {},
    right: {},
    bottom: {},
    left: {},
    // shadows
    boxShadow: {
        themeKey: "shadows",
    },
    // sizing
    width: {
        transform: sizingTransform,
    },
    maxWidth: {
        style: maxWidth,
    },
    minWidth: {
        transform: sizingTransform,
    },
    height: {
        transform: sizingTransform,
    },
    maxHeight: {
        transform: sizingTransform,
    },
    minHeight: {
        transform: sizingTransform,
    },
    boxSizing: {},
    // typography
    fontFamily: {
        themeKey: "typography",
    },
    fontSize: {
        themeKey: "typography",
    },
    fontStyle: {
        themeKey: "typography",
    },
    fontWeight: {
        themeKey: "typography",
    },
    letterSpacing: {},
    textTransform: {},
    lineHeight: {},
    textAlign: {},
    typography: {
        cssProperty: false,
        themeKey: "typography",
    },
};
const defaultSxConfig$1 = defaultSxConfig;
function objectsHaveSameKeys(...objects) {
    const allKeys = objects.reduce((keys, object) => keys.concat(Object.keys(object)), []);
    const union = new Set(allKeys);
    return objects.every((object) => union.size === Object.keys(object).length);
}
function callIfFn(maybeFn, arg) {
    return typeof maybeFn === "function" ? maybeFn(arg) : maybeFn;
}
function unstable_createStyleFunctionSx() {
    function getThemeValue(prop, val, theme, config) {
        const props = {
            [prop]: val,
            theme,
        };
        const options = config[prop];
        if (!options) {
            return {
                [prop]: val,
            };
        }
        const { cssProperty = prop, themeKey, transform, style: style2 } = options;
        if (val == null) {
            return null;
        }
        if (themeKey === "typography" && val === "inherit") {
            return {
                [prop]: val,
            };
        }
        const themeMapping = getPath(theme, themeKey) || {};
        if (style2) {
            return style2(props);
        }
        const styleFromPropValue = (propValueFinal) => {
            let value = getStyleValue$1(themeMapping, transform, propValueFinal);
            if (propValueFinal === value && typeof propValueFinal === "string") {
                value = getStyleValue$1(themeMapping, transform, `${prop}${propValueFinal === "default" ? "" : capitalize(propValueFinal)}`, propValueFinal);
            }
            if (cssProperty === false) {
                return value;
            }
            return {
                [cssProperty]: value,
            };
        };
        return handleBreakpoints(props, val, styleFromPropValue);
    }
    function styleFunctionSx2(props) {
        var _theme$unstable_sxCon;
        const { sx, theme = {} } = props || {};
        if (!sx) {
            return null;
        }
        const config = (_theme$unstable_sxCon = theme.unstable_sxConfig) != null ? _theme$unstable_sxCon : defaultSxConfig$1;
        function traverse(sxInput) {
            let sxObject = sxInput;
            if (typeof sxInput === "function") {
                sxObject = sxInput(theme);
            } else if (typeof sxInput !== "object") {
                return sxInput;
            }
            if (!sxObject) {
                return null;
            }
            const emptyBreakpoints = createEmptyBreakpointObject(theme.breakpoints);
            const breakpointsKeys = Object.keys(emptyBreakpoints);
            let css2 = emptyBreakpoints;
            Object.keys(sxObject).forEach((styleKey) => {
                const value = callIfFn(sxObject[styleKey], theme);
                if (value !== null && value !== void 0) {
                    if (typeof value === "object") {
                        if (config[styleKey]) {
                            css2 = merge(css2, getThemeValue(styleKey, value, theme, config));
                        } else {
                            const breakpointsValues = handleBreakpoints(
                                {
                                    theme,
                                },
                                value,
                                (x2) => ({
                                    [styleKey]: x2,
                                })
                            );
                            if (objectsHaveSameKeys(breakpointsValues, value)) {
                                css2[styleKey] = styleFunctionSx2({
                                    sx: value,
                                    theme,
                                });
                            } else {
                                css2 = merge(css2, breakpointsValues);
                            }
                        }
                    } else {
                        css2 = merge(css2, getThemeValue(styleKey, value, theme, config));
                    }
                }
            });
            return removeUnusedBreakpoints(breakpointsKeys, css2);
        }
        return Array.isArray(sx) ? sx.map(traverse) : traverse(sx);
    }
    return styleFunctionSx2;
}
const styleFunctionSx = unstable_createStyleFunctionSx();
styleFunctionSx.filterProps = ["sx"];
const styleFunctionSx$1 = styleFunctionSx;
const _excluded$16 = ["breakpoints", "palette", "spacing", "shape"];
function createTheme$1(options = {}, ...args) {
    const { breakpoints: breakpointsInput = {}, palette: paletteInput = {}, spacing: spacingInput, shape: shapeInput = {} } = options,
        other = _objectWithoutPropertiesLoose(options, _excluded$16);
    const breakpoints = createBreakpoints(breakpointsInput);
    const spacing = createSpacing(spacingInput);
    let muiTheme = deepmerge(
        {
            breakpoints,
            direction: "ltr",
            components: {},
            // Inject component definitions.
            palette: _extends(
                {
                    mode: "light",
                },
                paletteInput
            ),
            spacing,
            shape: _extends({}, shape$1, shapeInput),
        },
        other
    );
    muiTheme = args.reduce((acc, argument) => deepmerge(acc, argument), muiTheme);
    muiTheme.unstable_sxConfig = _extends({}, defaultSxConfig$1, other == null ? void 0 : other.unstable_sxConfig);
    muiTheme.unstable_sx = function sx(props) {
        return styleFunctionSx$1({
            sx: props,
            theme: this,
        });
    };
    return muiTheme;
}
function isObjectEmpty(obj) {
    return Object.keys(obj).length === 0;
}
function useTheme$2(defaultTheme2 = null) {
    const contextTheme = reactExports.useContext(ThemeContext);
    return !contextTheme || isObjectEmpty(contextTheme) ? defaultTheme2 : contextTheme;
}
const systemDefaultTheme$1 = createTheme$1();
function useTheme$1(defaultTheme2 = systemDefaultTheme$1) {
    return useTheme$2(defaultTheme2);
}
function GlobalStyles$1({ styles: styles2, themeId, defaultTheme: defaultTheme2 = {} }) {
    const upperTheme = useTheme$1(defaultTheme2);
    const globalStyles = typeof styles2 === "function" ? styles2(themeId ? upperTheme[themeId] || upperTheme : upperTheme) : styles2;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(GlobalStyles$2, {
        styles: globalStyles,
    });
}
const _excluded$15 = ["sx"];
const splitProps = (props) => {
    var _props$theme$unstable, _props$theme;
    const result = {
        systemProps: {},
        otherProps: {},
    };
    const config = (_props$theme$unstable = props == null || (_props$theme = props.theme) == null ? void 0 : _props$theme.unstable_sxConfig) != null ? _props$theme$unstable : defaultSxConfig$1;
    Object.keys(props).forEach((prop) => {
        if (config[prop]) {
            result.systemProps[prop] = props[prop];
        } else {
            result.otherProps[prop] = props[prop];
        }
    });
    return result;
};
function extendSxProp(props) {
    const { sx: inSx } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded$15);
    const { systemProps, otherProps } = splitProps(other);
    let finalSx;
    if (Array.isArray(inSx)) {
        finalSx = [systemProps, ...inSx];
    } else if (typeof inSx === "function") {
        finalSx = (...args) => {
            const result = inSx(...args);
            if (!isPlainObject(result)) {
                return systemProps;
            }
            return _extends({}, systemProps, result);
        };
    } else {
        finalSx = _extends({}, systemProps, inSx);
    }
    return _extends({}, otherProps, {
        sx: finalSx,
    });
}
function r$2(e2) {
    var t2,
        f2,
        n2 = "";
    if ("string" == typeof e2 || "number" == typeof e2) n2 += e2;
    else if ("object" == typeof e2)
        if (Array.isArray(e2)) for (t2 = 0; t2 < e2.length; t2++) e2[t2] && (f2 = r$2(e2[t2])) && (n2 && (n2 += " "), (n2 += f2));
        else for (t2 in e2) e2[t2] && (n2 && (n2 += " "), (n2 += t2));
    return n2;
}
function clsx$2() {
    for (var e2, t2, f2 = 0, n2 = ""; f2 < arguments.length; ) (e2 = arguments[f2++]) && (t2 = r$2(e2)) && (n2 && (n2 += " "), (n2 += t2));
    return n2;
}
const _excluded$14 = ["className", "component"];
function createBox(options = {}) {
    const { themeId, defaultTheme: defaultTheme2, defaultClassName = "MuiBox-root", generateClassName } = options;
    const BoxRoot = styled$3("div", {
        shouldForwardProp: (prop) => prop !== "theme" && prop !== "sx" && prop !== "as",
    })(styleFunctionSx$1);
    const Box2 = /* @__PURE__ */ reactExports.forwardRef(function Box3(inProps, ref) {
        const theme = useTheme$1(defaultTheme2);
        const _extendSxProp = extendSxProp(inProps),
            { className, component = "div" } = _extendSxProp,
            other = _objectWithoutPropertiesLoose(_extendSxProp, _excluded$14);
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
            BoxRoot,
            _extends(
                {
                    as: component,
                    ref,
                    className: clsx$2(className, generateClassName ? generateClassName(defaultClassName) : defaultClassName),
                    theme: themeId ? theme[themeId] || theme : theme,
                },
                other
            )
        );
    });
    return Box2;
}
const _excluded$13 = ["variant"];
function isEmpty$3(string) {
    return string.length === 0;
}
function propsToClassKey(props) {
    const { variant } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded$13);
    let classKey = variant || "";
    Object.keys(other)
        .sort()
        .forEach((key) => {
            if (key === "color") {
                classKey += isEmpty$3(classKey) ? props[key] : capitalize(props[key]);
            } else {
                classKey += `${isEmpty$3(classKey) ? key : capitalize(key)}${capitalize(props[key].toString())}`;
            }
        });
    return classKey;
}
const _excluded$12 = ["name", "slot", "skipVariantsResolver", "skipSx", "overridesResolver"];
function isEmpty$2(obj) {
    return Object.keys(obj).length === 0;
}
function isStringTag(tag) {
    return (
        typeof tag === "string" && // 96 is one less than the char code
        // for "a" so this is checking that
        // it's a lowercase character
        tag.charCodeAt(0) > 96
    );
}
const getStyleOverrides = (name, theme) => {
    if (theme.components && theme.components[name] && theme.components[name].styleOverrides) {
        return theme.components[name].styleOverrides;
    }
    return null;
};
const transformVariants = (variants) => {
    const variantsStyles = {};
    if (variants) {
        variants.forEach((definition) => {
            const key = propsToClassKey(definition.props);
            variantsStyles[key] = definition.style;
        });
    }
    return variantsStyles;
};
const getVariantStyles = (name, theme) => {
    let variants = [];
    if (theme && theme.components && theme.components[name] && theme.components[name].variants) {
        variants = theme.components[name].variants;
    }
    return transformVariants(variants);
};
const variantsResolver = (props, styles2, variants) => {
    const { ownerState = {} } = props;
    const variantsStyles = [];
    if (variants) {
        variants.forEach((variant) => {
            let isMatch = true;
            Object.keys(variant.props).forEach((key) => {
                if (ownerState[key] !== variant.props[key] && props[key] !== variant.props[key]) {
                    isMatch = false;
                }
            });
            if (isMatch) {
                variantsStyles.push(styles2[propsToClassKey(variant.props)]);
            }
        });
    }
    return variantsStyles;
};
const themeVariantsResolver = (props, styles2, theme, name) => {
    var _theme$components;
    const themeVariants = theme == null || (_theme$components = theme.components) == null || (_theme$components = _theme$components[name]) == null ? void 0 : _theme$components.variants;
    return variantsResolver(props, styles2, themeVariants);
};
function shouldForwardProp(prop) {
    return prop !== "ownerState" && prop !== "theme" && prop !== "sx" && prop !== "as";
}
const systemDefaultTheme = createTheme$1();
const lowercaseFirstLetter = (string) => {
    if (!string) {
        return string;
    }
    return string.charAt(0).toLowerCase() + string.slice(1);
};
function resolveTheme({ defaultTheme: defaultTheme2, theme, themeId }) {
    return isEmpty$2(theme) ? defaultTheme2 : theme[themeId] || theme;
}
function defaultOverridesResolver(slot) {
    if (!slot) {
        return null;
    }
    return (props, styles2) => styles2[slot];
}
const muiStyledFunctionResolver = ({ styledArg, props, defaultTheme: defaultTheme2, themeId }) => {
    const resolvedStyles = styledArg(
        _extends({}, props, {
            theme: resolveTheme(
                _extends({}, props, {
                    defaultTheme: defaultTheme2,
                    themeId,
                })
            ),
        })
    );
    let optionalVariants;
    if (resolvedStyles && resolvedStyles.variants) {
        optionalVariants = resolvedStyles.variants;
        delete resolvedStyles.variants;
    }
    if (optionalVariants) {
        const variantsStyles = variantsResolver(props, transformVariants(optionalVariants), optionalVariants);
        return [resolvedStyles, ...variantsStyles];
    }
    return resolvedStyles;
};
function createStyled2(input = {}) {
    const {
        themeId,
        defaultTheme: defaultTheme2 = systemDefaultTheme,
        rootShouldForwardProp: rootShouldForwardProp2 = shouldForwardProp,
        slotShouldForwardProp: slotShouldForwardProp2 = shouldForwardProp,
    } = input;
    const systemSx = (props) => {
        return styleFunctionSx$1(
            _extends({}, props, {
                theme: resolveTheme(
                    _extends({}, props, {
                        defaultTheme: defaultTheme2,
                        themeId,
                    })
                ),
            })
        );
    };
    systemSx.__mui_systemSx = true;
    return (tag, inputOptions = {}) => {
        internal_processStyles(tag, (styles2) => styles2.filter((style2) => !(style2 != null && style2.__mui_systemSx)));
        const {
                name: componentName,
                slot: componentSlot,
                skipVariantsResolver: inputSkipVariantsResolver,
                skipSx: inputSkipSx,
                // TODO v6: remove `lowercaseFirstLetter()` in the next major release
                // For more details: https://github.com/mui/material-ui/pull/37908
                overridesResolver: overridesResolver2 = defaultOverridesResolver(lowercaseFirstLetter(componentSlot)),
            } = inputOptions,
            options = _objectWithoutPropertiesLoose(inputOptions, _excluded$12);
        const skipVariantsResolver =
            inputSkipVariantsResolver !== void 0
                ? inputSkipVariantsResolver
                : // TODO v6: remove `Root` in the next major release
                  // For more details: https://github.com/mui/material-ui/pull/37908
                  (componentSlot && componentSlot !== "Root" && componentSlot !== "root") || false;
        const skipSx = inputSkipSx || false;
        let label;
        let shouldForwardPropOption = shouldForwardProp;
        if (componentSlot === "Root" || componentSlot === "root") {
            shouldForwardPropOption = rootShouldForwardProp2;
        } else if (componentSlot) {
            shouldForwardPropOption = slotShouldForwardProp2;
        } else if (isStringTag(tag)) {
            shouldForwardPropOption = void 0;
        }
        const defaultStyledResolver = styled$3(
            tag,
            _extends(
                {
                    shouldForwardProp: shouldForwardPropOption,
                    label,
                },
                options
            )
        );
        const muiStyledResolver = (styleArg, ...expressions) => {
            const expressionsWithDefaultTheme = expressions
                ? expressions.map((stylesArg) => {
                      if (typeof stylesArg === "function" && stylesArg.__emotion_real !== stylesArg) {
                          return (props) =>
                              muiStyledFunctionResolver({
                                  styledArg: stylesArg,
                                  props,
                                  defaultTheme: defaultTheme2,
                                  themeId,
                              });
                      }
                      if (isPlainObject(stylesArg)) {
                          let transformedStylesArg = stylesArg;
                          let styledArgVariants;
                          if (stylesArg && stylesArg.variants) {
                              styledArgVariants = stylesArg.variants;
                              delete transformedStylesArg.variants;
                              transformedStylesArg = (props) => {
                                  let result = stylesArg;
                                  const variantStyles = variantsResolver(props, transformVariants(styledArgVariants), styledArgVariants);
                                  variantStyles.forEach((variantStyle) => {
                                      result = deepmerge(result, variantStyle);
                                  });
                                  return result;
                              };
                          }
                          return transformedStylesArg;
                      }
                      return stylesArg;
                  })
                : [];
            let transformedStyleArg = styleArg;
            if (isPlainObject(styleArg)) {
                let styledArgVariants;
                if (styleArg && styleArg.variants) {
                    styledArgVariants = styleArg.variants;
                    delete transformedStyleArg.variants;
                    transformedStyleArg = (props) => {
                        let result = styleArg;
                        const variantStyles = variantsResolver(props, transformVariants(styledArgVariants), styledArgVariants);
                        variantStyles.forEach((variantStyle) => {
                            result = deepmerge(result, variantStyle);
                        });
                        return result;
                    };
                }
            } else if (
                typeof styleArg === "function" && // On the server Emotion doesn't use React.forwardRef for creating components, so the created
                // component stays as a function. This condition makes sure that we do not interpolate functions
                // which are basically components used as a selectors.
                styleArg.__emotion_real !== styleArg
            ) {
                transformedStyleArg = (props) =>
                    muiStyledFunctionResolver({
                        styledArg: styleArg,
                        props,
                        defaultTheme: defaultTheme2,
                        themeId,
                    });
            }
            if (componentName && overridesResolver2) {
                expressionsWithDefaultTheme.push((props) => {
                    const theme = resolveTheme(
                        _extends({}, props, {
                            defaultTheme: defaultTheme2,
                            themeId,
                        })
                    );
                    const styleOverrides = getStyleOverrides(componentName, theme);
                    if (styleOverrides) {
                        const resolvedStyleOverrides = {};
                        Object.entries(styleOverrides).forEach(([slotKey, slotStyle]) => {
                            resolvedStyleOverrides[slotKey] =
                                typeof slotStyle === "function"
                                    ? slotStyle(
                                          _extends({}, props, {
                                              theme,
                                          })
                                      )
                                    : slotStyle;
                        });
                        return overridesResolver2(props, resolvedStyleOverrides);
                    }
                    return null;
                });
            }
            if (componentName && !skipVariantsResolver) {
                expressionsWithDefaultTheme.push((props) => {
                    const theme = resolveTheme(
                        _extends({}, props, {
                            defaultTheme: defaultTheme2,
                            themeId,
                        })
                    );
                    return themeVariantsResolver(props, getVariantStyles(componentName, theme), theme, componentName);
                });
            }
            if (!skipSx) {
                expressionsWithDefaultTheme.push(systemSx);
            }
            const numOfCustomFnsApplied = expressionsWithDefaultTheme.length - expressions.length;
            if (Array.isArray(styleArg) && numOfCustomFnsApplied > 0) {
                const placeholders = new Array(numOfCustomFnsApplied).fill("");
                transformedStyleArg = [...styleArg, ...placeholders];
                transformedStyleArg.raw = [...styleArg.raw, ...placeholders];
            }
            const Component = defaultStyledResolver(transformedStyleArg, ...expressionsWithDefaultTheme);
            if (tag.muiName) {
                Component.muiName = tag.muiName;
            }
            return Component;
        };
        if (defaultStyledResolver.withConfig) {
            muiStyledResolver.withConfig = defaultStyledResolver.withConfig;
        }
        return muiStyledResolver;
    };
}
const styled$2 = createStyled2();
const systemStyled = styled$2;
function getThemeProps(params) {
    const { theme, name, props } = params;
    if (!theme || !theme.components || !theme.components[name] || !theme.components[name].defaultProps) {
        return props;
    }
    return resolveProps(theme.components[name].defaultProps, props);
}
function useThemeProps$1({ props, name, defaultTheme: defaultTheme2, themeId }) {
    let theme = useTheme$1(defaultTheme2);
    if (themeId) {
        theme = theme[themeId] || theme;
    }
    const mergedProps = getThemeProps({
        theme,
        name,
        props,
    });
    return mergedProps;
}
function clamp(value, min2 = 0, max2 = 1) {
    return Math.min(Math.max(min2, value), max2);
}
function hexToRgb(color2) {
    color2 = color2.slice(1);
    const re = new RegExp(`.{1,${color2.length >= 6 ? 2 : 1}}`, "g");
    let colors = color2.match(re);
    if (colors && colors[0].length === 1) {
        colors = colors.map((n2) => n2 + n2);
    }
    return colors
        ? `rgb${colors.length === 4 ? "a" : ""}(${colors
              .map((n2, index) => {
                  return index < 3 ? parseInt(n2, 16) : Math.round((parseInt(n2, 16) / 255) * 1e3) / 1e3;
              })
              .join(", ")})`
        : "";
}
function decomposeColor(color2) {
    if (color2.type) {
        return color2;
    }
    if (color2.charAt(0) === "#") {
        return decomposeColor(hexToRgb(color2));
    }
    const marker = color2.indexOf("(");
    const type = color2.substring(0, marker);
    if (["rgb", "rgba", "hsl", "hsla", "color"].indexOf(type) === -1) {
        throw new Error(formatMuiErrorMessage(9, color2));
    }
    let values2 = color2.substring(marker + 1, color2.length - 1);
    let colorSpace;
    if (type === "color") {
        values2 = values2.split(" ");
        colorSpace = values2.shift();
        if (values2.length === 4 && values2[3].charAt(0) === "/") {
            values2[3] = values2[3].slice(1);
        }
        if (["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].indexOf(colorSpace) === -1) {
            throw new Error(formatMuiErrorMessage(10, colorSpace));
        }
    } else {
        values2 = values2.split(",");
    }
    values2 = values2.map((value) => parseFloat(value));
    return {
        type,
        values: values2,
        colorSpace,
    };
}
function recomposeColor(color2) {
    const { type, colorSpace } = color2;
    let { values: values2 } = color2;
    if (type.indexOf("rgb") !== -1) {
        values2 = values2.map((n2, i) => (i < 3 ? parseInt(n2, 10) : n2));
    } else if (type.indexOf("hsl") !== -1) {
        values2[1] = `${values2[1]}%`;
        values2[2] = `${values2[2]}%`;
    }
    if (type.indexOf("color") !== -1) {
        values2 = `${colorSpace} ${values2.join(" ")}`;
    } else {
        values2 = `${values2.join(", ")}`;
    }
    return `${type}(${values2})`;
}
function hslToRgb(color2) {
    color2 = decomposeColor(color2);
    const { values: values2 } = color2;
    const h2 = values2[0];
    const s = values2[1] / 100;
    const l2 = values2[2] / 100;
    const a = s * Math.min(l2, 1 - l2);
    const f2 = (n2, k2 = (n2 + h2 / 30) % 12) => l2 - a * Math.max(Math.min(k2 - 3, 9 - k2, 1), -1);
    let type = "rgb";
    const rgb = [Math.round(f2(0) * 255), Math.round(f2(8) * 255), Math.round(f2(4) * 255)];
    if (color2.type === "hsla") {
        type += "a";
        rgb.push(values2[3]);
    }
    return recomposeColor({
        type,
        values: rgb,
    });
}
function getLuminance(color2) {
    color2 = decomposeColor(color2);
    let rgb = color2.type === "hsl" || color2.type === "hsla" ? decomposeColor(hslToRgb(color2)).values : color2.values;
    rgb = rgb.map((val) => {
        if (color2.type !== "color") {
            val /= 255;
        }
        return val <= 0.03928 ? val / 12.92 : ((val + 0.055) / 1.055) ** 2.4;
    });
    return Number((0.2126 * rgb[0] + 0.7152 * rgb[1] + 0.0722 * rgb[2]).toFixed(3));
}
function getContrastRatio(foreground, background) {
    const lumA = getLuminance(foreground);
    const lumB = getLuminance(background);
    return (Math.max(lumA, lumB) + 0.05) / (Math.min(lumA, lumB) + 0.05);
}
function alpha(color2, value) {
    color2 = decomposeColor(color2);
    value = clamp(value);
    if (color2.type === "rgb" || color2.type === "hsl") {
        color2.type += "a";
    }
    if (color2.type === "color") {
        color2.values[3] = `/${value}`;
    } else {
        color2.values[3] = value;
    }
    return recomposeColor(color2);
}
function darken(color2, coefficient) {
    color2 = decomposeColor(color2);
    coefficient = clamp(coefficient);
    if (color2.type.indexOf("hsl") !== -1) {
        color2.values[2] *= 1 - coefficient;
    } else if (color2.type.indexOf("rgb") !== -1 || color2.type.indexOf("color") !== -1) {
        for (let i = 0; i < 3; i += 1) {
            color2.values[i] *= 1 - coefficient;
        }
    }
    return recomposeColor(color2);
}
function lighten(color2, coefficient) {
    color2 = decomposeColor(color2);
    coefficient = clamp(coefficient);
    if (color2.type.indexOf("hsl") !== -1) {
        color2.values[2] += (100 - color2.values[2]) * coefficient;
    } else if (color2.type.indexOf("rgb") !== -1) {
        for (let i = 0; i < 3; i += 1) {
            color2.values[i] += (255 - color2.values[i]) * coefficient;
        }
    } else if (color2.type.indexOf("color") !== -1) {
        for (let i = 0; i < 3; i += 1) {
            color2.values[i] += (1 - color2.values[i]) * coefficient;
        }
    }
    return recomposeColor(color2);
}
const _excluded$11 = ["component", "direction", "spacing", "divider", "children", "className", "useFlexGap"];
const defaultTheme$3 = createTheme$1();
const defaultCreateStyledComponent = systemStyled("div", {
    name: "MuiStack",
    slot: "Root",
    overridesResolver: (props, styles2) => styles2.root,
});
function useThemePropsDefault(props) {
    return useThemeProps$1({
        props,
        name: "MuiStack",
        defaultTheme: defaultTheme$3,
    });
}
function joinChildren(children, separator) {
    const childrenArray = reactExports.Children.toArray(children).filter(Boolean);
    return childrenArray.reduce((output, child, index) => {
        output.push(child);
        if (index < childrenArray.length - 1) {
            output.push(
                /* @__PURE__ */ reactExports.cloneElement(separator, {
                    key: `separator-${index}`,
                })
            );
        }
        return output;
    }, []);
}
const getSideFromDirection = (direction) => {
    return {
        row: "Left",
        "row-reverse": "Right",
        column: "Top",
        "column-reverse": "Bottom",
    }[direction];
};
const style$1 = ({ ownerState, theme }) => {
    let styles2 = _extends(
        {
            display: "flex",
            flexDirection: "column",
        },
        handleBreakpoints(
            {
                theme,
            },
            resolveBreakpointValues({
                values: ownerState.direction,
                breakpoints: theme.breakpoints.values,
            }),
            (propValue) => ({
                flexDirection: propValue,
            })
        )
    );
    if (ownerState.spacing) {
        const transformer = createUnarySpacing(theme);
        const base = Object.keys(theme.breakpoints.values).reduce((acc, breakpoint) => {
            if ((typeof ownerState.spacing === "object" && ownerState.spacing[breakpoint] != null) || (typeof ownerState.direction === "object" && ownerState.direction[breakpoint] != null)) {
                acc[breakpoint] = true;
            }
            return acc;
        }, {});
        const directionValues = resolveBreakpointValues({
            values: ownerState.direction,
            base,
        });
        const spacingValues = resolveBreakpointValues({
            values: ownerState.spacing,
            base,
        });
        if (typeof directionValues === "object") {
            Object.keys(directionValues).forEach((breakpoint, index, breakpoints) => {
                const directionValue = directionValues[breakpoint];
                if (!directionValue) {
                    const previousDirectionValue = index > 0 ? directionValues[breakpoints[index - 1]] : "column";
                    directionValues[breakpoint] = previousDirectionValue;
                }
            });
        }
        const styleFromPropValue = (propValue, breakpoint) => {
            if (ownerState.useFlexGap) {
                return {
                    gap: getValue(transformer, propValue),
                };
            }
            return {
                // The useFlexGap={false} implement relies on each child to give up control of the margin.
                // We need to reset the margin to avoid double spacing.
                "& > :not(style):not(style)": {
                    margin: 0,
                },
                "& > :not(style) ~ :not(style)": {
                    [`margin${getSideFromDirection(breakpoint ? directionValues[breakpoint] : ownerState.direction)}`]: getValue(transformer, propValue),
                },
            };
        };
        styles2 = deepmerge(
            styles2,
            handleBreakpoints(
                {
                    theme,
                },
                spacingValues,
                styleFromPropValue
            )
        );
    }
    styles2 = mergeBreakpointsInOrder(theme.breakpoints, styles2);
    return styles2;
};
function createStack(options = {}) {
    const {
        // This will allow adding custom styled fn (for example for custom sx style function)
        createStyledComponent = defaultCreateStyledComponent,
        useThemeProps: useThemeProps2 = useThemePropsDefault,
        componentName = "MuiStack",
    } = options;
    const useUtilityClasses2 = () => {
        const slots = {
            root: ["root"],
        };
        return composeClasses(slots, (slot) => generateUtilityClass(componentName, slot), {});
    };
    const StackRoot = createStyledComponent(style$1);
    const Stack2 = /* @__PURE__ */ reactExports.forwardRef(function Grid3(inProps, ref) {
        const themeProps = useThemeProps2(inProps);
        const props = extendSxProp(themeProps);
        const { component = "div", direction = "column", spacing = 0, divider, children, className, useFlexGap = false } = props,
            other = _objectWithoutPropertiesLoose(props, _excluded$11);
        const ownerState = {
            direction,
            spacing,
            useFlexGap,
        };
        const classes = useUtilityClasses2();
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
            StackRoot,
            _extends(
                {
                    as: component,
                    ownerState,
                    ref,
                    className: clsx$2(classes.root, className),
                },
                other,
                {
                    children: divider ? joinChildren(children, divider) : children,
                }
            )
        );
    });
    return Stack2;
}
function createMixins(breakpoints, mixins) {
    return _extends(
        {
            toolbar: {
                minHeight: 56,
                [breakpoints.up("xs")]: {
                    "@media (orientation: landscape)": {
                        minHeight: 48,
                    },
                },
                [breakpoints.up("sm")]: {
                    minHeight: 64,
                },
            },
        },
        mixins
    );
}
const _excluded$10 = ["mode", "contrastThreshold", "tonalOffset"];
const light = {
    // The colors used to style the text.
    text: {
        // The most important text.
        primary: "rgba(0, 0, 0, 0.87)",
        // Secondary text.
        secondary: "rgba(0, 0, 0, 0.6)",
        // Disabled text have even lower visual prominence.
        disabled: "rgba(0, 0, 0, 0.38)",
    },
    // The color used to divide different elements.
    divider: "rgba(0, 0, 0, 0.12)",
    // The background colors used to style the surfaces.
    // Consistency between these values is important.
    background: {
        paper: common$1.white,
        default: common$1.white,
    },
    // The colors used to style the action elements.
    action: {
        // The color of an active action like an icon button.
        active: "rgba(0, 0, 0, 0.54)",
        // The color of an hovered action.
        hover: "rgba(0, 0, 0, 0.04)",
        hoverOpacity: 0.04,
        // The color of a selected action.
        selected: "rgba(0, 0, 0, 0.08)",
        selectedOpacity: 0.08,
        // The color of a disabled action.
        disabled: "rgba(0, 0, 0, 0.26)",
        // The background color of a disabled action.
        disabledBackground: "rgba(0, 0, 0, 0.12)",
        disabledOpacity: 0.38,
        focus: "rgba(0, 0, 0, 0.12)",
        focusOpacity: 0.12,
        activatedOpacity: 0.12,
    },
};
const dark = {
    text: {
        primary: common$1.white,
        secondary: "rgba(255, 255, 255, 0.7)",
        disabled: "rgba(255, 255, 255, 0.5)",
        icon: "rgba(255, 255, 255, 0.5)",
    },
    divider: "rgba(255, 255, 255, 0.12)",
    background: {
        paper: "#121212",
        default: "#121212",
    },
    action: {
        active: common$1.white,
        hover: "rgba(255, 255, 255, 0.08)",
        hoverOpacity: 0.08,
        selected: "rgba(255, 255, 255, 0.16)",
        selectedOpacity: 0.16,
        disabled: "rgba(255, 255, 255, 0.3)",
        disabledBackground: "rgba(255, 255, 255, 0.12)",
        disabledOpacity: 0.38,
        focus: "rgba(255, 255, 255, 0.12)",
        focusOpacity: 0.12,
        activatedOpacity: 0.24,
    },
};
function addLightOrDark(intent, direction, shade, tonalOffset) {
    const tonalOffsetLight = tonalOffset.light || tonalOffset;
    const tonalOffsetDark = tonalOffset.dark || tonalOffset * 1.5;
    if (!intent[direction]) {
        if (intent.hasOwnProperty(shade)) {
            intent[direction] = intent[shade];
        } else if (direction === "light") {
            intent.light = lighten(intent.main, tonalOffsetLight);
        } else if (direction === "dark") {
            intent.dark = darken(intent.main, tonalOffsetDark);
        }
    }
}
function getDefaultPrimary(mode = "light") {
    if (mode === "dark") {
        return {
            main: blue$1[200],
            light: blue$1[50],
            dark: blue$1[400],
        };
    }
    return {
        main: blue$1[700],
        light: blue$1[400],
        dark: blue$1[800],
    };
}
function getDefaultSecondary(mode = "light") {
    if (mode === "dark") {
        return {
            main: purple$1[200],
            light: purple$1[50],
            dark: purple$1[400],
        };
    }
    return {
        main: purple$1[500],
        light: purple$1[300],
        dark: purple$1[700],
    };
}
function getDefaultError(mode = "light") {
    if (mode === "dark") {
        return {
            main: red$1[500],
            light: red$1[300],
            dark: red$1[700],
        };
    }
    return {
        main: red$1[700],
        light: red$1[400],
        dark: red$1[800],
    };
}
function getDefaultInfo(mode = "light") {
    if (mode === "dark") {
        return {
            main: lightBlue$1[400],
            light: lightBlue$1[300],
            dark: lightBlue$1[700],
        };
    }
    return {
        main: lightBlue$1[700],
        light: lightBlue$1[500],
        dark: lightBlue$1[900],
    };
}
function getDefaultSuccess(mode = "light") {
    if (mode === "dark") {
        return {
            main: green$1[400],
            light: green$1[300],
            dark: green$1[700],
        };
    }
    return {
        main: green$1[800],
        light: green$1[500],
        dark: green$1[900],
    };
}
function getDefaultWarning(mode = "light") {
    if (mode === "dark") {
        return {
            main: orange$1[400],
            light: orange$1[300],
            dark: orange$1[700],
        };
    }
    return {
        main: "#ed6c02",
        // closest to orange[800] that pass 3:1.
        light: orange$1[500],
        dark: orange$1[900],
    };
}
function createPalette(palette) {
    const { mode = "light", contrastThreshold = 3, tonalOffset = 0.2 } = palette,
        other = _objectWithoutPropertiesLoose(palette, _excluded$10);
    const primary = palette.primary || getDefaultPrimary(mode);
    const secondary = palette.secondary || getDefaultSecondary(mode);
    const error = palette.error || getDefaultError(mode);
    const info = palette.info || getDefaultInfo(mode);
    const success2 = palette.success || getDefaultSuccess(mode);
    const warning = palette.warning || getDefaultWarning(mode);
    function getContrastText(background) {
        const contrastText = getContrastRatio(background, dark.text.primary) >= contrastThreshold ? dark.text.primary : light.text.primary;
        return contrastText;
    }
    const augmentColor = ({ color: color2, name, mainShade = 500, lightShade = 300, darkShade = 700 }) => {
        color2 = _extends({}, color2);
        if (!color2.main && color2[mainShade]) {
            color2.main = color2[mainShade];
        }
        if (!color2.hasOwnProperty("main")) {
            throw new Error(formatMuiErrorMessage(11, name ? ` (${name})` : "", mainShade));
        }
        if (typeof color2.main !== "string") {
            throw new Error(formatMuiErrorMessage(12, name ? ` (${name})` : "", JSON.stringify(color2.main)));
        }
        addLightOrDark(color2, "light", lightShade, tonalOffset);
        addLightOrDark(color2, "dark", darkShade, tonalOffset);
        if (!color2.contrastText) {
            color2.contrastText = getContrastText(color2.main);
        }
        return color2;
    };
    const modes = {
        dark,
        light,
    };
    const paletteOutput = deepmerge(
        _extends(
            {
                // A collection of common colors.
                common: _extends({}, common$1),
                // prevent mutable object.
                // The palette mode, can be light or dark.
                mode,
                // The colors used to represent primary interface elements for a user.
                primary: augmentColor({
                    color: primary,
                    name: "primary",
                }),
                // The colors used to represent secondary interface elements for a user.
                secondary: augmentColor({
                    color: secondary,
                    name: "secondary",
                    mainShade: "A400",
                    lightShade: "A200",
                    darkShade: "A700",
                }),
                // The colors used to represent interface elements that the user should be made aware of.
                error: augmentColor({
                    color: error,
                    name: "error",
                }),
                // The colors used to represent potentially dangerous actions or important messages.
                warning: augmentColor({
                    color: warning,
                    name: "warning",
                }),
                // The colors used to present information to the user that is neutral and not necessarily important.
                info: augmentColor({
                    color: info,
                    name: "info",
                }),
                // The colors used to indicate the successful completion of an action that user triggered.
                success: augmentColor({
                    color: success2,
                    name: "success",
                }),
                // The grey colors.
                grey: grey$1,
                // Used by `getContrastText()` to maximize the contrast between
                // the background and the text.
                contrastThreshold,
                // Takes a background color and returns the text color that maximizes the contrast.
                getContrastText,
                // Generate a rich color object.
                augmentColor,
                // Used by the functions below to shift a color's luminance by approximately
                // two indexes within its tonal palette.
                // E.g., shift from Red 500 to Red 300 or Red 700.
                tonalOffset,
            },
            modes[mode]
        ),
        other
    );
    return paletteOutput;
}
const _excluded$$ = ["fontFamily", "fontSize", "fontWeightLight", "fontWeightRegular", "fontWeightMedium", "fontWeightBold", "htmlFontSize", "allVariants", "pxToRem"];
function round$2(value) {
    return Math.round(value * 1e5) / 1e5;
}
const caseAllCaps = {
    textTransform: "uppercase",
};
const defaultFontFamily = '"Roboto", "Helvetica", "Arial", sans-serif';
function createTypography(palette, typography) {
    const _ref = typeof typography === "function" ? typography(palette) : typography,
        {
            fontFamily = defaultFontFamily,
            // The default font size of the Material Specification.
            fontSize = 14,
            // px
            fontWeightLight = 300,
            fontWeightRegular = 400,
            fontWeightMedium = 500,
            fontWeightBold = 700,
            // Tell MUI what's the font-size on the html element.
            // 16px is the default font-size used by browsers.
            htmlFontSize = 16,
            // Apply the CSS properties to all the variants.
            allVariants,
            pxToRem: pxToRem2,
        } = _ref,
        other = _objectWithoutPropertiesLoose(_ref, _excluded$$);
    const coef = fontSize / 14;
    const pxToRem = pxToRem2 || ((size) => `${(size / htmlFontSize) * coef}rem`);
    const buildVariant = (fontWeight, size, lineHeight, letterSpacing, casing) =>
        _extends(
            {
                fontFamily,
                fontWeight,
                fontSize: pxToRem(size),
                // Unitless following https://meyerweb.com/eric/thoughts/2006/02/08/unitless-line-heights/
                lineHeight,
            },
            fontFamily === defaultFontFamily
                ? {
                      letterSpacing: `${round$2(letterSpacing / size)}em`,
                  }
                : {},
            casing,
            allVariants
        );
    const variants = {
        h1: buildVariant(fontWeightLight, 96, 1.167, -1.5),
        h2: buildVariant(fontWeightLight, 60, 1.2, -0.5),
        h3: buildVariant(fontWeightRegular, 48, 1.167, 0),
        h4: buildVariant(fontWeightRegular, 34, 1.235, 0.25),
        h5: buildVariant(fontWeightRegular, 24, 1.334, 0),
        h6: buildVariant(fontWeightMedium, 20, 1.6, 0.15),
        subtitle1: buildVariant(fontWeightRegular, 16, 1.75, 0.15),
        subtitle2: buildVariant(fontWeightMedium, 14, 1.57, 0.1),
        body1: buildVariant(fontWeightRegular, 16, 1.5, 0.15),
        body2: buildVariant(fontWeightRegular, 14, 1.43, 0.15),
        button: buildVariant(fontWeightMedium, 14, 1.75, 0.4, caseAllCaps),
        caption: buildVariant(fontWeightRegular, 12, 1.66, 0.4),
        overline: buildVariant(fontWeightRegular, 12, 2.66, 1, caseAllCaps),
        inherit: {
            fontFamily: "inherit",
            fontWeight: "inherit",
            fontSize: "inherit",
            lineHeight: "inherit",
            letterSpacing: "inherit",
        },
    };
    return deepmerge(
        _extends(
            {
                htmlFontSize,
                pxToRem,
                fontFamily,
                fontSize,
                fontWeightLight,
                fontWeightRegular,
                fontWeightMedium,
                fontWeightBold,
            },
            variants
        ),
        other,
        {
            clone: false,
            // No need to clone deep
        }
    );
}
const shadowKeyUmbraOpacity = 0.2;
const shadowKeyPenumbraOpacity = 0.14;
const shadowAmbientShadowOpacity = 0.12;
function createShadow(...px) {
    return [
        `${px[0]}px ${px[1]}px ${px[2]}px ${px[3]}px rgba(0,0,0,${shadowKeyUmbraOpacity})`,
        `${px[4]}px ${px[5]}px ${px[6]}px ${px[7]}px rgba(0,0,0,${shadowKeyPenumbraOpacity})`,
        `${px[8]}px ${px[9]}px ${px[10]}px ${px[11]}px rgba(0,0,0,${shadowAmbientShadowOpacity})`,
    ].join(",");
}
const shadows = [
    "none",
    createShadow(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0),
    createShadow(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0),
    createShadow(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0),
    createShadow(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0),
    createShadow(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0),
    createShadow(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0),
    createShadow(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1),
    createShadow(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2),
    createShadow(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2),
    createShadow(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3),
    createShadow(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3),
    createShadow(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4),
    createShadow(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4),
    createShadow(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4),
    createShadow(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5),
    createShadow(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5),
    createShadow(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5),
    createShadow(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6),
    createShadow(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6),
    createShadow(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7),
    createShadow(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7),
    createShadow(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7),
    createShadow(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8),
    createShadow(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8),
];
const shadows$1 = shadows;
const _excluded$_ = ["duration", "easing", "delay"];
const easing = {
    // This is the most common easing curve.
    easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
    // Objects enter the screen at full velocity from off-screen and
    // slowly decelerate to a resting point.
    easeOut: "cubic-bezier(0.0, 0, 0.2, 1)",
    // Objects leave the screen at full velocity. They do not decelerate when off-screen.
    easeIn: "cubic-bezier(0.4, 0, 1, 1)",
    // The sharp curve is used by objects that may return to the screen at any time.
    sharp: "cubic-bezier(0.4, 0, 0.6, 1)",
};
const duration = {
    shortest: 150,
    shorter: 200,
    short: 250,
    // most basic recommended timing
    standard: 300,
    // this is to be used in complex animations
    complex: 375,
    // recommended when something is entering screen
    enteringScreen: 225,
    // recommended when something is leaving screen
    leavingScreen: 195,
};
function formatMs(milliseconds) {
    return `${Math.round(milliseconds)}ms`;
}
function getAutoHeightDuration(height2) {
    if (!height2) {
        return 0;
    }
    const constant = height2 / 36;
    return Math.round((4 + 15 * constant ** 0.25 + constant / 5) * 10);
}
function createTransitions(inputTransitions) {
    const mergedEasing = _extends({}, easing, inputTransitions.easing);
    const mergedDuration = _extends({}, duration, inputTransitions.duration);
    const create = (props = ["all"], options = {}) => {
        const { duration: durationOption = mergedDuration.standard, easing: easingOption = mergedEasing.easeInOut, delay = 0 } = options;
        _objectWithoutPropertiesLoose(options, _excluded$_);
        return (Array.isArray(props) ? props : [props])
            .map(
                (animatedProp) =>
                    `${animatedProp} ${typeof durationOption === "string" ? durationOption : formatMs(durationOption)} ${easingOption} ${typeof delay === "string" ? delay : formatMs(delay)}`
            )
            .join(",");
    };
    return _extends(
        {
            getAutoHeightDuration,
            create,
        },
        inputTransitions,
        {
            easing: mergedEasing,
            duration: mergedDuration,
        }
    );
}
const zIndex = {
    mobileStepper: 1e3,
    fab: 1050,
    speedDial: 1050,
    appBar: 1100,
    drawer: 1200,
    modal: 1300,
    snackbar: 1400,
    tooltip: 1500,
};
const zIndex$1 = zIndex;
const _excluded$Z = ["breakpoints", "mixins", "spacing", "palette", "transitions", "typography", "shape"];
function createTheme(options = {}, ...args) {
    const { mixins: mixinsInput = {}, palette: paletteInput = {}, transitions: transitionsInput = {}, typography: typographyInput = {} } = options,
        other = _objectWithoutPropertiesLoose(options, _excluded$Z);
    if (options.vars) {
        throw new Error(formatMuiErrorMessage(18));
    }
    const palette = createPalette(paletteInput);
    const systemTheme = createTheme$1(options);
    let muiTheme = deepmerge(systemTheme, {
        mixins: createMixins(systemTheme.breakpoints, mixinsInput),
        palette,
        // Don't use [...shadows] until you've verified its transpiled code is not invoking the iterator protocol.
        shadows: shadows$1.slice(),
        typography: createTypography(palette, typographyInput),
        transitions: createTransitions(transitionsInput),
        zIndex: _extends({}, zIndex$1),
    });
    muiTheme = deepmerge(muiTheme, other);
    muiTheme = args.reduce((acc, argument) => deepmerge(acc, argument), muiTheme);
    muiTheme.unstable_sxConfig = _extends({}, defaultSxConfig$1, other == null ? void 0 : other.unstable_sxConfig);
    muiTheme.unstable_sx = function sx(props) {
        return styleFunctionSx$1({
            sx: props,
            theme: this,
        });
    };
    return muiTheme;
}
const defaultTheme$1 = createTheme();
const defaultTheme$2 = defaultTheme$1;
function useTheme() {
    const theme = useTheme$1(defaultTheme$2);
    return theme[THEME_ID] || theme;
}
function useThemeProps({ props, name }) {
    return useThemeProps$1({
        props,
        name,
        defaultTheme: defaultTheme$2,
        themeId: THEME_ID,
    });
}
const rootShouldForwardProp = (prop) => shouldForwardProp(prop) && prop !== "classes";
const slotShouldForwardProp = shouldForwardProp;
const styled = createStyled2({
    themeId: THEME_ID,
    defaultTheme: defaultTheme$2,
    rootShouldForwardProp,
});
const styled$1 = styled;
const getOverlayAlpha = (elevation) => {
    let alphaValue;
    if (elevation < 1) {
        alphaValue = 5.11916 * elevation ** 2;
    } else {
        alphaValue = 4.5 * Math.log(elevation + 1) + 2;
    }
    return (alphaValue / 100).toFixed(2);
};
const getOverlayAlpha$1 = getOverlayAlpha;
function r$1(e2) {
    var t2,
        f2,
        n2 = "";
    if ("string" == typeof e2 || "number" == typeof e2) n2 += e2;
    else if ("object" == typeof e2)
        if (Array.isArray(e2)) for (t2 = 0; t2 < e2.length; t2++) e2[t2] && (f2 = r$1(e2[t2])) && (n2 && (n2 += " "), (n2 += f2));
        else for (t2 in e2) e2[t2] && (n2 && (n2 += " "), (n2 += t2));
    return n2;
}
function clsx$1() {
    for (var e2, t2, f2 = 0, n2 = ""; f2 < arguments.length; ) (e2 = arguments[f2++]) && (t2 = r$1(e2)) && (n2 && (n2 += " "), (n2 += t2));
    return n2;
}
function isHostComponent(element) {
    return typeof element === "string";
}
function appendOwnerState(elementType, otherProps, ownerState) {
    if (elementType === void 0 || isHostComponent(elementType)) {
        return otherProps;
    }
    return _extends({}, otherProps, {
        ownerState: _extends({}, otherProps.ownerState, ownerState),
    });
}
const defaultContextValue = {
    disableDefaultClasses: false,
};
const ClassNameConfiguratorContext = /* @__PURE__ */ reactExports.createContext(defaultContextValue);
function useClassNamesOverride(generateUtilityClass2) {
    const { disableDefaultClasses } = reactExports.useContext(ClassNameConfiguratorContext);
    return (slot) => {
        if (disableDefaultClasses) {
            return "";
        }
        return generateUtilityClass2(slot);
    };
}
function extractEventHandlers(object, excludeKeys = []) {
    if (object === void 0) {
        return {};
    }
    const result = {};
    Object.keys(object)
        .filter((prop) => prop.match(/^on[A-Z]/) && typeof object[prop] === "function" && !excludeKeys.includes(prop))
        .forEach((prop) => {
            result[prop] = object[prop];
        });
    return result;
}
function resolveComponentProps(componentProps, ownerState) {
    if (typeof componentProps === "function") {
        return componentProps(ownerState);
    }
    return componentProps;
}
function omitEventHandlers(object) {
    if (object === void 0) {
        return {};
    }
    const result = {};
    Object.keys(object)
        .filter((prop) => !(prop.match(/^on[A-Z]/) && typeof object[prop] === "function"))
        .forEach((prop) => {
            result[prop] = object[prop];
        });
    return result;
}
function mergeSlotProps(parameters) {
    const { getSlotProps, additionalProps, externalSlotProps, externalForwardedProps, className } = parameters;
    if (!getSlotProps) {
        const joinedClasses2 = clsx$1(
            externalForwardedProps == null ? void 0 : externalForwardedProps.className,
            externalSlotProps == null ? void 0 : externalSlotProps.className,
            className,
            additionalProps == null ? void 0 : additionalProps.className
        );
        const mergedStyle2 = _extends(
            {},
            additionalProps == null ? void 0 : additionalProps.style,
            externalForwardedProps == null ? void 0 : externalForwardedProps.style,
            externalSlotProps == null ? void 0 : externalSlotProps.style
        );
        const props2 = _extends({}, additionalProps, externalForwardedProps, externalSlotProps);
        if (joinedClasses2.length > 0) {
            props2.className = joinedClasses2;
        }
        if (Object.keys(mergedStyle2).length > 0) {
            props2.style = mergedStyle2;
        }
        return {
            props: props2,
            internalRef: void 0,
        };
    }
    const eventHandlers = extractEventHandlers(_extends({}, externalForwardedProps, externalSlotProps));
    const componentsPropsWithoutEventHandlers = omitEventHandlers(externalSlotProps);
    const otherPropsWithoutEventHandlers = omitEventHandlers(externalForwardedProps);
    const internalSlotProps = getSlotProps(eventHandlers);
    const joinedClasses = clsx$1(
        internalSlotProps == null ? void 0 : internalSlotProps.className,
        additionalProps == null ? void 0 : additionalProps.className,
        className,
        externalForwardedProps == null ? void 0 : externalForwardedProps.className,
        externalSlotProps == null ? void 0 : externalSlotProps.className
    );
    const mergedStyle = _extends(
        {},
        internalSlotProps == null ? void 0 : internalSlotProps.style,
        additionalProps == null ? void 0 : additionalProps.style,
        externalForwardedProps == null ? void 0 : externalForwardedProps.style,
        externalSlotProps == null ? void 0 : externalSlotProps.style
    );
    const props = _extends({}, internalSlotProps, additionalProps, otherPropsWithoutEventHandlers, componentsPropsWithoutEventHandlers);
    if (joinedClasses.length > 0) {
        props.className = joinedClasses;
    }
    if (Object.keys(mergedStyle).length > 0) {
        props.style = mergedStyle;
    }
    return {
        props,
        internalRef: internalSlotProps.ref,
    };
}
const _excluded$Y = ["elementType", "externalSlotProps", "ownerState"];
function useSlotProps(parameters) {
    var _parameters$additiona;
    const { elementType, externalSlotProps, ownerState } = parameters,
        rest = _objectWithoutPropertiesLoose(parameters, _excluded$Y);
    const resolvedComponentsProps = resolveComponentProps(externalSlotProps, ownerState);
    const { props: mergedProps, internalRef } = mergeSlotProps(
        _extends({}, rest, {
            externalSlotProps: resolvedComponentsProps,
        })
    );
    const ref = useForkRef(
        internalRef,
        resolvedComponentsProps == null ? void 0 : resolvedComponentsProps.ref,
        (_parameters$additiona = parameters.additionalProps) == null ? void 0 : _parameters$additiona.ref
    );
    const props = appendOwnerState(
        elementType,
        _extends({}, mergedProps, {
            ref,
        }),
        ownerState
    );
    return props;
}
const candidatesSelector = ["input", "select", "textarea", "a[href]", "button", "[tabindex]", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])'].join(",");
function getTabIndex(node2) {
    const tabindexAttr = parseInt(node2.getAttribute("tabindex") || "", 10);
    if (!Number.isNaN(tabindexAttr)) {
        return tabindexAttr;
    }
    if (node2.contentEditable === "true" || ((node2.nodeName === "AUDIO" || node2.nodeName === "VIDEO" || node2.nodeName === "DETAILS") && node2.getAttribute("tabindex") === null)) {
        return 0;
    }
    return node2.tabIndex;
}
function isNonTabbableRadio(node2) {
    if (node2.tagName !== "INPUT" || node2.type !== "radio") {
        return false;
    }
    if (!node2.name) {
        return false;
    }
    const getRadio = (selector) => node2.ownerDocument.querySelector(`input[type="radio"]${selector}`);
    let roving = getRadio(`[name="${node2.name}"]:checked`);
    if (!roving) {
        roving = getRadio(`[name="${node2.name}"]`);
    }
    return roving !== node2;
}
function isNodeMatchingSelectorFocusable(node2) {
    if (node2.disabled || (node2.tagName === "INPUT" && node2.type === "hidden") || isNonTabbableRadio(node2)) {
        return false;
    }
    return true;
}
function defaultGetTabbable(root2) {
    const regularTabNodes = [];
    const orderedTabNodes = [];
    Array.from(root2.querySelectorAll(candidatesSelector)).forEach((node2, i) => {
        const nodeTabIndex = getTabIndex(node2);
        if (nodeTabIndex === -1 || !isNodeMatchingSelectorFocusable(node2)) {
            return;
        }
        if (nodeTabIndex === 0) {
            regularTabNodes.push(node2);
        } else {
            orderedTabNodes.push({
                documentOrder: i,
                tabIndex: nodeTabIndex,
                node: node2,
            });
        }
    });
    return orderedTabNodes
        .sort((a, b2) => (a.tabIndex === b2.tabIndex ? a.documentOrder - b2.documentOrder : a.tabIndex - b2.tabIndex))
        .map((a) => a.node)
        .concat(regularTabNodes);
}
function defaultIsEnabled() {
    return true;
}
function FocusTrap(props) {
    const { children, disableAutoFocus = false, disableEnforceFocus = false, disableRestoreFocus = false, getTabbable = defaultGetTabbable, isEnabled = defaultIsEnabled, open: open2 } = props;
    const ignoreNextEnforceFocus = reactExports.useRef(false);
    const sentinelStart = reactExports.useRef(null);
    const sentinelEnd = reactExports.useRef(null);
    const nodeToRestore = reactExports.useRef(null);
    const reactFocusEventTarget = reactExports.useRef(null);
    const activated = reactExports.useRef(false);
    const rootRef = reactExports.useRef(null);
    const handleRef = useForkRef(children.ref, rootRef);
    const lastKeydown = reactExports.useRef(null);
    reactExports.useEffect(() => {
        if (!open2 || !rootRef.current) {
            return;
        }
        activated.current = !disableAutoFocus;
    }, [disableAutoFocus, open2]);
    reactExports.useEffect(() => {
        if (!open2 || !rootRef.current) {
            return;
        }
        const doc = ownerDocument(rootRef.current);
        if (!rootRef.current.contains(doc.activeElement)) {
            if (!rootRef.current.hasAttribute("tabIndex")) {
                rootRef.current.setAttribute("tabIndex", "-1");
            }
            if (activated.current) {
                rootRef.current.focus();
            }
        }
        return () => {
            if (!disableRestoreFocus) {
                if (nodeToRestore.current && nodeToRestore.current.focus) {
                    ignoreNextEnforceFocus.current = true;
                    nodeToRestore.current.focus();
                }
                nodeToRestore.current = null;
            }
        };
    }, [open2]);
    reactExports.useEffect(() => {
        if (!open2 || !rootRef.current) {
            return;
        }
        const doc = ownerDocument(rootRef.current);
        const contain = (nativeEvent) => {
            const { current: rootElement } = rootRef;
            if (rootElement === null) {
                return;
            }
            if (!doc.hasFocus() || disableEnforceFocus || !isEnabled() || ignoreNextEnforceFocus.current) {
                ignoreNextEnforceFocus.current = false;
                return;
            }
            if (!rootElement.contains(doc.activeElement)) {
                if ((nativeEvent && reactFocusEventTarget.current !== nativeEvent.target) || doc.activeElement !== reactFocusEventTarget.current) {
                    reactFocusEventTarget.current = null;
                } else if (reactFocusEventTarget.current !== null) {
                    return;
                }
                if (!activated.current) {
                    return;
                }
                let tabbable = [];
                if (doc.activeElement === sentinelStart.current || doc.activeElement === sentinelEnd.current) {
                    tabbable = getTabbable(rootRef.current);
                }
                if (tabbable.length > 0) {
                    var _lastKeydown$current, _lastKeydown$current2;
                    const isShiftTab = Boolean(
                        ((_lastKeydown$current = lastKeydown.current) == null ? void 0 : _lastKeydown$current.shiftKey) &&
                            ((_lastKeydown$current2 = lastKeydown.current) == null ? void 0 : _lastKeydown$current2.key) === "Tab"
                    );
                    const focusNext = tabbable[0];
                    const focusPrevious = tabbable[tabbable.length - 1];
                    if (typeof focusNext !== "string" && typeof focusPrevious !== "string") {
                        if (isShiftTab) {
                            focusPrevious.focus();
                        } else {
                            focusNext.focus();
                        }
                    }
                } else {
                    rootElement.focus();
                }
            }
        };
        const loopFocus = (nativeEvent) => {
            lastKeydown.current = nativeEvent;
            if (disableEnforceFocus || !isEnabled() || nativeEvent.key !== "Tab") {
                return;
            }
            if (doc.activeElement === rootRef.current && nativeEvent.shiftKey) {
                ignoreNextEnforceFocus.current = true;
                if (sentinelEnd.current) {
                    sentinelEnd.current.focus();
                }
            }
        };
        doc.addEventListener("focusin", contain);
        doc.addEventListener("keydown", loopFocus, true);
        const interval = setInterval(() => {
            if (doc.activeElement && doc.activeElement.tagName === "BODY") {
                contain(null);
            }
        }, 50);
        return () => {
            clearInterval(interval);
            doc.removeEventListener("focusin", contain);
            doc.removeEventListener("keydown", loopFocus, true);
        };
    }, [disableAutoFocus, disableEnforceFocus, disableRestoreFocus, isEnabled, open2, getTabbable]);
    const onFocus = (event) => {
        if (nodeToRestore.current === null) {
            nodeToRestore.current = event.relatedTarget;
        }
        activated.current = true;
        reactFocusEventTarget.current = event.target;
        const childrenPropsHandler = children.props.onFocus;
        if (childrenPropsHandler) {
            childrenPropsHandler(event);
        }
    };
    const handleFocusSentinel = (event) => {
        if (nodeToRestore.current === null) {
            nodeToRestore.current = event.relatedTarget;
        }
        activated.current = true;
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
        children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
                tabIndex: open2 ? 0 : -1,
                onFocus: handleFocusSentinel,
                ref: sentinelStart,
                "data-testid": "sentinelStart",
            }),
            /* @__PURE__ */ reactExports.cloneElement(children, {
                ref: handleRef,
                onFocus,
            }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
                tabIndex: open2 ? 0 : -1,
                onFocus: handleFocusSentinel,
                ref: sentinelEnd,
                "data-testid": "sentinelEnd",
            }),
        ],
    });
}
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function (acc, placement) {
    return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function (acc, placement) {
    return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
function getNodeName(element) {
    return element ? (element.nodeName || "").toLowerCase() : null;
}
function getWindow(node2) {
    if (node2 == null) {
        return window;
    }
    if (node2.toString() !== "[object Window]") {
        var ownerDocument2 = node2.ownerDocument;
        return ownerDocument2 ? ownerDocument2.defaultView || window : window;
    }
    return node2;
}
function isElement(node2) {
    var OwnElement = getWindow(node2).Element;
    return node2 instanceof OwnElement || node2 instanceof Element;
}
function isHTMLElement$1(node2) {
    var OwnElement = getWindow(node2).HTMLElement;
    return node2 instanceof OwnElement || node2 instanceof HTMLElement;
}
function isShadowRoot(node2) {
    if (typeof ShadowRoot === "undefined") {
        return false;
    }
    var OwnElement = getWindow(node2).ShadowRoot;
    return node2 instanceof OwnElement || node2 instanceof ShadowRoot;
}
function applyStyles(_ref) {
    var state = _ref.state;
    Object.keys(state.elements).forEach(function (name) {
        var style2 = state.styles[name] || {};
        var attributes = state.attributes[name] || {};
        var element = state.elements[name];
        if (!isHTMLElement$1(element) || !getNodeName(element)) {
            return;
        }
        Object.assign(element.style, style2);
        Object.keys(attributes).forEach(function (name2) {
            var value = attributes[name2];
            if (value === false) {
                element.removeAttribute(name2);
            } else {
                element.setAttribute(name2, value === true ? "" : value);
            }
        });
    });
}
function effect$2(_ref2) {
    var state = _ref2.state;
    var initialStyles = {
        popper: {
            position: state.options.strategy,
            left: "0",
            top: "0",
            margin: "0",
        },
        arrow: {
            position: "absolute",
        },
        reference: {},
    };
    Object.assign(state.elements.popper.style, initialStyles.popper);
    state.styles = initialStyles;
    if (state.elements.arrow) {
        Object.assign(state.elements.arrow.style, initialStyles.arrow);
    }
    return function () {
        Object.keys(state.elements).forEach(function (name) {
            var element = state.elements[name];
            var attributes = state.attributes[name] || {};
            var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
            var style2 = styleProperties.reduce(function (style3, property) {
                style3[property] = "";
                return style3;
            }, {});
            if (!isHTMLElement$1(element) || !getNodeName(element)) {
                return;
            }
            Object.assign(element.style, style2);
            Object.keys(attributes).forEach(function (attribute) {
                element.removeAttribute(attribute);
            });
        });
    };
}
const applyStyles$1 = {
    name: "applyStyles",
    enabled: true,
    phase: "write",
    fn: applyStyles,
    effect: effect$2,
    requires: ["computeStyles"],
};
function getBasePlacement(placement) {
    return placement.split("-")[0];
}
var max = Math.max;
var min = Math.min;
var round$1 = Math.round;
function getUAString() {
    var uaData = navigator.userAgentData;
    if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
        return uaData.brands
            .map(function (item) {
                return item.brand + "/" + item.version;
            })
            .join(" ");
    }
    return navigator.userAgent;
}
function isLayoutViewport() {
    return !/^((?!chrome|android).)*safari/i.test(getUAString());
}
function getBoundingClientRect(element, includeScale, isFixedStrategy) {
    if (includeScale === void 0) {
        includeScale = false;
    }
    if (isFixedStrategy === void 0) {
        isFixedStrategy = false;
    }
    var clientRect = element.getBoundingClientRect();
    var scaleX = 1;
    var scaleY = 1;
    if (includeScale && isHTMLElement$1(element)) {
        scaleX = element.offsetWidth > 0 ? round$1(clientRect.width) / element.offsetWidth || 1 : 1;
        scaleY = element.offsetHeight > 0 ? round$1(clientRect.height) / element.offsetHeight || 1 : 1;
    }
    var _ref = isElement(element) ? getWindow(element) : window,
        visualViewport = _ref.visualViewport;
    var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
    var x2 = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
    var y2 = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
    var width2 = clientRect.width / scaleX;
    var height2 = clientRect.height / scaleY;
    return {
        width: width2,
        height: height2,
        top: y2,
        right: x2 + width2,
        bottom: y2 + height2,
        left: x2,
        x: x2,
        y: y2,
    };
}
function getLayoutRect(element) {
    var clientRect = getBoundingClientRect(element);
    var width2 = element.offsetWidth;
    var height2 = element.offsetHeight;
    if (Math.abs(clientRect.width - width2) <= 1) {
        width2 = clientRect.width;
    }
    if (Math.abs(clientRect.height - height2) <= 1) {
        height2 = clientRect.height;
    }
    return {
        x: element.offsetLeft,
        y: element.offsetTop,
        width: width2,
        height: height2,
    };
}
function contains(parent, child) {
    var rootNode = child.getRootNode && child.getRootNode();
    if (parent.contains(child)) {
        return true;
    } else if (rootNode && isShadowRoot(rootNode)) {
        var next2 = child;
        do {
            if (next2 && parent.isSameNode(next2)) {
                return true;
            }
            next2 = next2.parentNode || next2.host;
        } while (next2);
    }
    return false;
}
function getComputedStyle(element) {
    return getWindow(element).getComputedStyle(element);
}
function isTableElement(element) {
    return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
}
function getDocumentElement(element) {
    return (
        (isElement(element)
            ? element.ownerDocument
            : // $FlowFixMe[prop-missing]
              element.document) || window.document
    ).documentElement;
}
function getParentNode(element) {
    if (getNodeName(element) === "html") {
        return element;
    }
    return (
        // this is a quicker (but less type safe) way to save quite some bytes from the bundle
        // $FlowFixMe[incompatible-return]
        // $FlowFixMe[prop-missing]
        element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
        element.parentNode || // DOM Element detected
        (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
        // $FlowFixMe[incompatible-call]: HTMLElement is a Node
        getDocumentElement(element)
    );
}
function getTrueOffsetParent(element) {
    if (
        !isHTMLElement$1(element) || // https://github.com/popperjs/popper-core/issues/837
        getComputedStyle(element).position === "fixed"
    ) {
        return null;
    }
    return element.offsetParent;
}
function getContainingBlock(element) {
    var isFirefox = /firefox/i.test(getUAString());
    var isIE = /Trident/i.test(getUAString());
    if (isIE && isHTMLElement$1(element)) {
        var elementCss = getComputedStyle(element);
        if (elementCss.position === "fixed") {
            return null;
        }
    }
    var currentNode = getParentNode(element);
    if (isShadowRoot(currentNode)) {
        currentNode = currentNode.host;
    }
    while (isHTMLElement$1(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
        var css2 = getComputedStyle(currentNode);
        if (
            css2.transform !== "none" ||
            css2.perspective !== "none" ||
            css2.contain === "paint" ||
            ["transform", "perspective"].indexOf(css2.willChange) !== -1 ||
            (isFirefox && css2.willChange === "filter") ||
            (isFirefox && css2.filter && css2.filter !== "none")
        ) {
            return currentNode;
        } else {
            currentNode = currentNode.parentNode;
        }
    }
    return null;
}
function getOffsetParent(element) {
    var window2 = getWindow(element);
    var offsetParent = getTrueOffsetParent(element);
    while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === "static") {
        offsetParent = getTrueOffsetParent(offsetParent);
    }
    if (offsetParent && (getNodeName(offsetParent) === "html" || (getNodeName(offsetParent) === "body" && getComputedStyle(offsetParent).position === "static"))) {
        return window2;
    }
    return offsetParent || getContainingBlock(element) || window2;
}
function getMainAxisFromPlacement(placement) {
    return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}
function within(min$1, value, max$1) {
    return max(min$1, min(value, max$1));
}
function withinMaxClamp(min2, value, max2) {
    var v2 = within(min2, value, max2);
    return v2 > max2 ? max2 : v2;
}
function getFreshSideObject() {
    return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0,
    };
}
function mergePaddingObject(paddingObject) {
    return Object.assign({}, getFreshSideObject(), paddingObject);
}
function expandToHashMap(value, keys) {
    return keys.reduce(function (hashMap, key) {
        hashMap[key] = value;
        return hashMap;
    }, {});
}
var toPaddingObject = function toPaddingObject2(padding2, state) {
    padding2 =
        typeof padding2 === "function"
            ? padding2(
                  Object.assign({}, state.rects, {
                      placement: state.placement,
                  })
              )
            : padding2;
    return mergePaddingObject(typeof padding2 !== "number" ? padding2 : expandToHashMap(padding2, basePlacements));
};
function arrow(_ref) {
    var _state$modifiersData$;
    var state = _ref.state,
        name = _ref.name,
        options = _ref.options;
    var arrowElement = state.elements.arrow;
    var popperOffsets2 = state.modifiersData.popperOffsets;
    var basePlacement = getBasePlacement(state.placement);
    var axis = getMainAxisFromPlacement(basePlacement);
    var isVertical = [left, right].indexOf(basePlacement) >= 0;
    var len = isVertical ? "height" : "width";
    if (!arrowElement || !popperOffsets2) {
        return;
    }
    var paddingObject = toPaddingObject(options.padding, state);
    var arrowRect = getLayoutRect(arrowElement);
    var minProp = axis === "y" ? top : left;
    var maxProp = axis === "y" ? bottom : right;
    var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
    var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
    var arrowOffsetParent = getOffsetParent(arrowElement);
    var clientSize = arrowOffsetParent ? (axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0) : 0;
    var centerToReference = endDiff / 2 - startDiff / 2;
    var min2 = paddingObject[minProp];
    var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
    var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
    var offset2 = within(min2, center, max2);
    var axisProp = axis;
    state.modifiersData[name] = ((_state$modifiersData$ = {}), (_state$modifiersData$[axisProp] = offset2), (_state$modifiersData$.centerOffset = offset2 - center), _state$modifiersData$);
}
function effect$1(_ref2) {
    var state = _ref2.state,
        options = _ref2.options;
    var _options$element = options.element,
        arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
    if (arrowElement == null) {
        return;
    }
    if (typeof arrowElement === "string") {
        arrowElement = state.elements.popper.querySelector(arrowElement);
        if (!arrowElement) {
            return;
        }
    }
    if (!contains(state.elements.popper, arrowElement)) {
        return;
    }
    state.elements.arrow = arrowElement;
}
const arrow$1 = {
    name: "arrow",
    enabled: true,
    phase: "main",
    fn: arrow,
    effect: effect$1,
    requires: ["popperOffsets"],
    requiresIfExists: ["preventOverflow"],
};
function getVariation(placement) {
    return placement.split("-")[1];
}
var unsetSides = {
    top: "auto",
    right: "auto",
    bottom: "auto",
    left: "auto",
};
function roundOffsetsByDPR(_ref, win) {
    var x2 = _ref.x,
        y2 = _ref.y;
    var dpr = win.devicePixelRatio || 1;
    return {
        x: round$1(x2 * dpr) / dpr || 0,
        y: round$1(y2 * dpr) / dpr || 0,
    };
}
function mapToStyles(_ref2) {
    var _Object$assign2;
    var popper2 = _ref2.popper,
        popperRect = _ref2.popperRect,
        placement = _ref2.placement,
        variation = _ref2.variation,
        offsets = _ref2.offsets,
        position2 = _ref2.position,
        gpuAcceleration = _ref2.gpuAcceleration,
        adaptive = _ref2.adaptive,
        roundOffsets = _ref2.roundOffsets,
        isFixed = _ref2.isFixed;
    var _offsets$x = offsets.x,
        x2 = _offsets$x === void 0 ? 0 : _offsets$x,
        _offsets$y = offsets.y,
        y2 = _offsets$y === void 0 ? 0 : _offsets$y;
    var _ref3 =
        typeof roundOffsets === "function"
            ? roundOffsets({
                  x: x2,
                  y: y2,
              })
            : {
                  x: x2,
                  y: y2,
              };
    x2 = _ref3.x;
    y2 = _ref3.y;
    var hasX = offsets.hasOwnProperty("x");
    var hasY = offsets.hasOwnProperty("y");
    var sideX = left;
    var sideY = top;
    var win = window;
    if (adaptive) {
        var offsetParent = getOffsetParent(popper2);
        var heightProp = "clientHeight";
        var widthProp = "clientWidth";
        if (offsetParent === getWindow(popper2)) {
            offsetParent = getDocumentElement(popper2);
            if (getComputedStyle(offsetParent).position !== "static" && position2 === "absolute") {
                heightProp = "scrollHeight";
                widthProp = "scrollWidth";
            }
        }
        offsetParent = offsetParent;
        if (placement === top || ((placement === left || placement === right) && variation === end)) {
            sideY = bottom;
            var offsetY =
                isFixed && offsetParent === win && win.visualViewport
                    ? win.visualViewport.height
                    : // $FlowFixMe[prop-missing]
                      offsetParent[heightProp];
            y2 -= offsetY - popperRect.height;
            y2 *= gpuAcceleration ? 1 : -1;
        }
        if (placement === left || ((placement === top || placement === bottom) && variation === end)) {
            sideX = right;
            var offsetX =
                isFixed && offsetParent === win && win.visualViewport
                    ? win.visualViewport.width
                    : // $FlowFixMe[prop-missing]
                      offsetParent[widthProp];
            x2 -= offsetX - popperRect.width;
            x2 *= gpuAcceleration ? 1 : -1;
        }
    }
    var commonStyles = Object.assign(
        {
            position: position2,
        },
        adaptive && unsetSides
    );
    var _ref4 =
        roundOffsets === true
            ? roundOffsetsByDPR(
                  {
                      x: x2,
                      y: y2,
                  },
                  getWindow(popper2)
              )
            : {
                  x: x2,
                  y: y2,
              };
    x2 = _ref4.x;
    y2 = _ref4.y;
    if (gpuAcceleration) {
        var _Object$assign;
        return Object.assign(
            {},
            commonStyles,
            ((_Object$assign = {}),
            (_Object$assign[sideY] = hasY ? "0" : ""),
            (_Object$assign[sideX] = hasX ? "0" : ""),
            (_Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x2 + "px, " + y2 + "px)" : "translate3d(" + x2 + "px, " + y2 + "px, 0)"),
            _Object$assign)
        );
    }
    return Object.assign(
        {},
        commonStyles,
        ((_Object$assign2 = {}), (_Object$assign2[sideY] = hasY ? y2 + "px" : ""), (_Object$assign2[sideX] = hasX ? x2 + "px" : ""), (_Object$assign2.transform = ""), _Object$assign2)
    );
}
function computeStyles(_ref5) {
    var state = _ref5.state,
        options = _ref5.options;
    var _options$gpuAccelerat = options.gpuAcceleration,
        gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,
        _options$adaptive = options.adaptive,
        adaptive = _options$adaptive === void 0 ? true : _options$adaptive,
        _options$roundOffsets = options.roundOffsets,
        roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
    var commonStyles = {
        placement: getBasePlacement(state.placement),
        variation: getVariation(state.placement),
        popper: state.elements.popper,
        popperRect: state.rects.popper,
        gpuAcceleration,
        isFixed: state.options.strategy === "fixed",
    };
    if (state.modifiersData.popperOffsets != null) {
        state.styles.popper = Object.assign(
            {},
            state.styles.popper,
            mapToStyles(
                Object.assign({}, commonStyles, {
                    offsets: state.modifiersData.popperOffsets,
                    position: state.options.strategy,
                    adaptive,
                    roundOffsets,
                })
            )
        );
    }
    if (state.modifiersData.arrow != null) {
        state.styles.arrow = Object.assign(
            {},
            state.styles.arrow,
            mapToStyles(
                Object.assign({}, commonStyles, {
                    offsets: state.modifiersData.arrow,
                    position: "absolute",
                    adaptive: false,
                    roundOffsets,
                })
            )
        );
    }
    state.attributes.popper = Object.assign({}, state.attributes.popper, {
        "data-popper-placement": state.placement,
    });
}
const computeStyles$1 = {
    name: "computeStyles",
    enabled: true,
    phase: "beforeWrite",
    fn: computeStyles,
    data: {},
};
var passive = {
    passive: true,
};
function effect(_ref) {
    var state = _ref.state,
        instance = _ref.instance,
        options = _ref.options;
    var _options$scroll = options.scroll,
        scroll = _options$scroll === void 0 ? true : _options$scroll,
        _options$resize = options.resize,
        resize = _options$resize === void 0 ? true : _options$resize;
    var window2 = getWindow(state.elements.popper);
    var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
    if (scroll) {
        scrollParents.forEach(function (scrollParent) {
            scrollParent.addEventListener("scroll", instance.update, passive);
        });
    }
    if (resize) {
        window2.addEventListener("resize", instance.update, passive);
    }
    return function () {
        if (scroll) {
            scrollParents.forEach(function (scrollParent) {
                scrollParent.removeEventListener("scroll", instance.update, passive);
            });
        }
        if (resize) {
            window2.removeEventListener("resize", instance.update, passive);
        }
    };
}
const eventListeners = {
    name: "eventListeners",
    enabled: true,
    phase: "write",
    fn: function fn() {},
    effect,
    data: {},
};
var hash$1 = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom",
};
function getOppositePlacement(placement) {
    return placement.replace(/left|right|bottom|top/g, function (matched) {
        return hash$1[matched];
    });
}
var hash = {
    start: "end",
    end: "start",
};
function getOppositeVariationPlacement(placement) {
    return placement.replace(/start|end/g, function (matched) {
        return hash[matched];
    });
}
function getWindowScroll(node2) {
    var win = getWindow(node2);
    var scrollLeft = win.pageXOffset;
    var scrollTop = win.pageYOffset;
    return {
        scrollLeft,
        scrollTop,
    };
}
function getWindowScrollBarX(element) {
    return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}
function getViewportRect(element, strategy) {
    var win = getWindow(element);
    var html = getDocumentElement(element);
    var visualViewport = win.visualViewport;
    var width2 = html.clientWidth;
    var height2 = html.clientHeight;
    var x2 = 0;
    var y2 = 0;
    if (visualViewport) {
        width2 = visualViewport.width;
        height2 = visualViewport.height;
        var layoutViewport = isLayoutViewport();
        if (layoutViewport || (!layoutViewport && strategy === "fixed")) {
            x2 = visualViewport.offsetLeft;
            y2 = visualViewport.offsetTop;
        }
    }
    return {
        width: width2,
        height: height2,
        x: x2 + getWindowScrollBarX(element),
        y: y2,
    };
}
function getDocumentRect(element) {
    var _element$ownerDocumen;
    var html = getDocumentElement(element);
    var winScroll = getWindowScroll(element);
    var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
    var width2 = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
    var height2 = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
    var x2 = -winScroll.scrollLeft + getWindowScrollBarX(element);
    var y2 = -winScroll.scrollTop;
    if (getComputedStyle(body || html).direction === "rtl") {
        x2 += max(html.clientWidth, body ? body.clientWidth : 0) - width2;
    }
    return {
        width: width2,
        height: height2,
        x: x2,
        y: y2,
    };
}
function isScrollParent(element) {
    var _getComputedStyle = getComputedStyle(element),
        overflow = _getComputedStyle.overflow,
        overflowX = _getComputedStyle.overflowX,
        overflowY = _getComputedStyle.overflowY;
    return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}
function getScrollParent(node2) {
    if (["html", "body", "#document"].indexOf(getNodeName(node2)) >= 0) {
        return node2.ownerDocument.body;
    }
    if (isHTMLElement$1(node2) && isScrollParent(node2)) {
        return node2;
    }
    return getScrollParent(getParentNode(node2));
}
function listScrollParents(element, list) {
    var _element$ownerDocumen;
    if (list === void 0) {
        list = [];
    }
    var scrollParent = getScrollParent(element);
    var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
    var win = getWindow(scrollParent);
    var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
    var updatedList = list.concat(target);
    return isBody
        ? updatedList
        : // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
          updatedList.concat(listScrollParents(getParentNode(target)));
}
function rectToClientRect(rect) {
    return Object.assign({}, rect, {
        left: rect.x,
        top: rect.y,
        right: rect.x + rect.width,
        bottom: rect.y + rect.height,
    });
}
function getInnerBoundingClientRect(element, strategy) {
    var rect = getBoundingClientRect(element, false, strategy === "fixed");
    rect.top = rect.top + element.clientTop;
    rect.left = rect.left + element.clientLeft;
    rect.bottom = rect.top + element.clientHeight;
    rect.right = rect.left + element.clientWidth;
    rect.width = element.clientWidth;
    rect.height = element.clientHeight;
    rect.x = rect.left;
    rect.y = rect.top;
    return rect;
}
function getClientRectFromMixedType(element, clippingParent, strategy) {
    return clippingParent === viewport
        ? rectToClientRect(getViewportRect(element, strategy))
        : isElement(clippingParent)
        ? getInnerBoundingClientRect(clippingParent, strategy)
        : rectToClientRect(getDocumentRect(getDocumentElement(element)));
}
function getClippingParents(element) {
    var clippingParents2 = listScrollParents(getParentNode(element));
    var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle(element).position) >= 0;
    var clipperElement = canEscapeClipping && isHTMLElement$1(element) ? getOffsetParent(element) : element;
    if (!isElement(clipperElement)) {
        return [];
    }
    return clippingParents2.filter(function (clippingParent) {
        return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
    });
}
function getClippingRect(element, boundary, rootBoundary, strategy) {
    var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
    var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
    var firstClippingParent = clippingParents2[0];
    var clippingRect = clippingParents2.reduce(function (accRect, clippingParent) {
        var rect = getClientRectFromMixedType(element, clippingParent, strategy);
        accRect.top = max(rect.top, accRect.top);
        accRect.right = min(rect.right, accRect.right);
        accRect.bottom = min(rect.bottom, accRect.bottom);
        accRect.left = max(rect.left, accRect.left);
        return accRect;
    }, getClientRectFromMixedType(element, firstClippingParent, strategy));
    clippingRect.width = clippingRect.right - clippingRect.left;
    clippingRect.height = clippingRect.bottom - clippingRect.top;
    clippingRect.x = clippingRect.left;
    clippingRect.y = clippingRect.top;
    return clippingRect;
}
function computeOffsets(_ref) {
    var reference2 = _ref.reference,
        element = _ref.element,
        placement = _ref.placement;
    var basePlacement = placement ? getBasePlacement(placement) : null;
    var variation = placement ? getVariation(placement) : null;
    var commonX = reference2.x + reference2.width / 2 - element.width / 2;
    var commonY = reference2.y + reference2.height / 2 - element.height / 2;
    var offsets;
    switch (basePlacement) {
        case top:
            offsets = {
                x: commonX,
                y: reference2.y - element.height,
            };
            break;
        case bottom:
            offsets = {
                x: commonX,
                y: reference2.y + reference2.height,
            };
            break;
        case right:
            offsets = {
                x: reference2.x + reference2.width,
                y: commonY,
            };
            break;
        case left:
            offsets = {
                x: reference2.x - element.width,
                y: commonY,
            };
            break;
        default:
            offsets = {
                x: reference2.x,
                y: reference2.y,
            };
    }
    var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
    if (mainAxis != null) {
        var len = mainAxis === "y" ? "height" : "width";
        switch (variation) {
            case start:
                offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
                break;
            case end:
                offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
                break;
        }
    }
    return offsets;
}
function detectOverflow(state, options) {
    if (options === void 0) {
        options = {};
    }
    var _options = options,
        _options$placement = _options.placement,
        placement = _options$placement === void 0 ? state.placement : _options$placement,
        _options$strategy = _options.strategy,
        strategy = _options$strategy === void 0 ? state.strategy : _options$strategy,
        _options$boundary = _options.boundary,
        boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,
        _options$rootBoundary = _options.rootBoundary,
        rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,
        _options$elementConte = _options.elementContext,
        elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,
        _options$altBoundary = _options.altBoundary,
        altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,
        _options$padding = _options.padding,
        padding2 = _options$padding === void 0 ? 0 : _options$padding;
    var paddingObject = mergePaddingObject(typeof padding2 !== "number" ? padding2 : expandToHashMap(padding2, basePlacements));
    var altContext = elementContext === popper ? reference : popper;
    var popperRect = state.rects.popper;
    var element = state.elements[altBoundary ? altContext : elementContext];
    var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
    var referenceClientRect = getBoundingClientRect(state.elements.reference);
    var popperOffsets2 = computeOffsets({
        reference: referenceClientRect,
        element: popperRect,
        strategy: "absolute",
        placement,
    });
    var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
    var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
    var overflowOffsets = {
        top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
        bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
        left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
        right: elementClientRect.right - clippingClientRect.right + paddingObject.right,
    };
    var offsetData = state.modifiersData.offset;
    if (elementContext === popper && offsetData) {
        var offset2 = offsetData[placement];
        Object.keys(overflowOffsets).forEach(function (key) {
            var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
            var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
            overflowOffsets[key] += offset2[axis] * multiply;
        });
    }
    return overflowOffsets;
}
function computeAutoPlacement(state, options) {
    if (options === void 0) {
        options = {};
    }
    var _options = options,
        placement = _options.placement,
        boundary = _options.boundary,
        rootBoundary = _options.rootBoundary,
        padding2 = _options.padding,
        flipVariations = _options.flipVariations,
        _options$allowedAutoP = _options.allowedAutoPlacements,
        allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
    var variation = getVariation(placement);
    var placements$1 = variation
        ? flipVariations
            ? variationPlacements
            : variationPlacements.filter(function (placement2) {
                  return getVariation(placement2) === variation;
              })
        : basePlacements;
    var allowedPlacements = placements$1.filter(function (placement2) {
        return allowedAutoPlacements.indexOf(placement2) >= 0;
    });
    if (allowedPlacements.length === 0) {
        allowedPlacements = placements$1;
    }
    var overflows = allowedPlacements.reduce(function (acc, placement2) {
        acc[placement2] = detectOverflow(state, {
            placement: placement2,
            boundary,
            rootBoundary,
            padding: padding2,
        })[getBasePlacement(placement2)];
        return acc;
    }, {});
    return Object.keys(overflows).sort(function (a, b2) {
        return overflows[a] - overflows[b2];
    });
}
function getExpandedFallbackPlacements(placement) {
    if (getBasePlacement(placement) === auto) {
        return [];
    }
    var oppositePlacement = getOppositePlacement(placement);
    return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip(_ref) {
    var state = _ref.state,
        options = _ref.options,
        name = _ref.name;
    if (state.modifiersData[name]._skip) {
        return;
    }
    var _options$mainAxis = options.mainAxis,
        checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
        _options$altAxis = options.altAxis,
        checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,
        specifiedFallbackPlacements = options.fallbackPlacements,
        padding2 = options.padding,
        boundary = options.boundary,
        rootBoundary = options.rootBoundary,
        altBoundary = options.altBoundary,
        _options$flipVariatio = options.flipVariations,
        flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,
        allowedAutoPlacements = options.allowedAutoPlacements;
    var preferredPlacement = state.options.placement;
    var basePlacement = getBasePlacement(preferredPlacement);
    var isBasePlacement = basePlacement === preferredPlacement;
    var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
    var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement2) {
        return acc.concat(
            getBasePlacement(placement2) === auto
                ? computeAutoPlacement(state, {
                      placement: placement2,
                      boundary,
                      rootBoundary,
                      padding: padding2,
                      flipVariations,
                      allowedAutoPlacements,
                  })
                : placement2
        );
    }, []);
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var checksMap = /* @__PURE__ */ new Map();
    var makeFallbackChecks = true;
    var firstFittingPlacement = placements2[0];
    for (var i = 0; i < placements2.length; i++) {
        var placement = placements2[i];
        var _basePlacement = getBasePlacement(placement);
        var isStartVariation = getVariation(placement) === start;
        var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
        var len = isVertical ? "width" : "height";
        var overflow = detectOverflow(state, {
            placement,
            boundary,
            rootBoundary,
            altBoundary,
            padding: padding2,
        });
        var mainVariationSide = isVertical ? (isStartVariation ? right : left) : isStartVariation ? bottom : top;
        if (referenceRect[len] > popperRect[len]) {
            mainVariationSide = getOppositePlacement(mainVariationSide);
        }
        var altVariationSide = getOppositePlacement(mainVariationSide);
        var checks = [];
        if (checkMainAxis) {
            checks.push(overflow[_basePlacement] <= 0);
        }
        if (checkAltAxis) {
            checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
        }
        if (
            checks.every(function (check) {
                return check;
            })
        ) {
            firstFittingPlacement = placement;
            makeFallbackChecks = false;
            break;
        }
        checksMap.set(placement, checks);
    }
    if (makeFallbackChecks) {
        var numberOfChecks = flipVariations ? 3 : 1;
        var _loop = function _loop2(_i2) {
            var fittingPlacement = placements2.find(function (placement2) {
                var checks2 = checksMap.get(placement2);
                if (checks2) {
                    return checks2.slice(0, _i2).every(function (check) {
                        return check;
                    });
                }
            });
            if (fittingPlacement) {
                firstFittingPlacement = fittingPlacement;
                return "break";
            }
        };
        for (var _i = numberOfChecks; _i > 0; _i--) {
            var _ret = _loop(_i);
            if (_ret === "break") break;
        }
    }
    if (state.placement !== firstFittingPlacement) {
        state.modifiersData[name]._skip = true;
        state.placement = firstFittingPlacement;
        state.reset = true;
    }
}
const flip$1 = {
    name: "flip",
    enabled: true,
    phase: "main",
    fn: flip,
    requiresIfExists: ["offset"],
    data: {
        _skip: false,
    },
};
function getSideOffsets(overflow, rect, preventedOffsets) {
    if (preventedOffsets === void 0) {
        preventedOffsets = {
            x: 0,
            y: 0,
        };
    }
    return {
        top: overflow.top - rect.height - preventedOffsets.y,
        right: overflow.right - rect.width + preventedOffsets.x,
        bottom: overflow.bottom - rect.height + preventedOffsets.y,
        left: overflow.left - rect.width - preventedOffsets.x,
    };
}
function isAnySideFullyClipped(overflow) {
    return [top, right, bottom, left].some(function (side) {
        return overflow[side] >= 0;
    });
}
function hide(_ref) {
    var state = _ref.state,
        name = _ref.name;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var preventedOffsets = state.modifiersData.preventOverflow;
    var referenceOverflow = detectOverflow(state, {
        elementContext: "reference",
    });
    var popperAltOverflow = detectOverflow(state, {
        altBoundary: true,
    });
    var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
    var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
    var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
    var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
    state.modifiersData[name] = {
        referenceClippingOffsets,
        popperEscapeOffsets,
        isReferenceHidden,
        hasPopperEscaped,
    };
    state.attributes.popper = Object.assign({}, state.attributes.popper, {
        "data-popper-reference-hidden": isReferenceHidden,
        "data-popper-escaped": hasPopperEscaped,
    });
}
const hide$1 = {
    name: "hide",
    enabled: true,
    phase: "main",
    requiresIfExists: ["preventOverflow"],
    fn: hide,
};
function distanceAndSkiddingToXY(placement, rects, offset2) {
    var basePlacement = getBasePlacement(placement);
    var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
    var _ref =
            typeof offset2 === "function"
                ? offset2(
                      Object.assign({}, rects, {
                          placement,
                      })
                  )
                : offset2,
        skidding = _ref[0],
        distance = _ref[1];
    skidding = skidding || 0;
    distance = (distance || 0) * invertDistance;
    return [left, right].indexOf(basePlacement) >= 0
        ? {
              x: distance,
              y: skidding,
          }
        : {
              x: skidding,
              y: distance,
          };
}
function offset(_ref2) {
    var state = _ref2.state,
        options = _ref2.options,
        name = _ref2.name;
    var _options$offset = options.offset,
        offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
    var data = placements.reduce(function (acc, placement) {
        acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
        return acc;
    }, {});
    var _data$state$placement = data[state.placement],
        x2 = _data$state$placement.x,
        y2 = _data$state$placement.y;
    if (state.modifiersData.popperOffsets != null) {
        state.modifiersData.popperOffsets.x += x2;
        state.modifiersData.popperOffsets.y += y2;
    }
    state.modifiersData[name] = data;
}
const offset$1 = {
    name: "offset",
    enabled: true,
    phase: "main",
    requires: ["popperOffsets"],
    fn: offset,
};
function popperOffsets(_ref) {
    var state = _ref.state,
        name = _ref.name;
    state.modifiersData[name] = computeOffsets({
        reference: state.rects.reference,
        element: state.rects.popper,
        strategy: "absolute",
        placement: state.placement,
    });
}
const popperOffsets$1 = {
    name: "popperOffsets",
    enabled: true,
    phase: "read",
    fn: popperOffsets,
    data: {},
};
function getAltAxis(axis) {
    return axis === "x" ? "y" : "x";
}
function preventOverflow(_ref) {
    var state = _ref.state,
        options = _ref.options,
        name = _ref.name;
    var _options$mainAxis = options.mainAxis,
        checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
        _options$altAxis = options.altAxis,
        checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,
        boundary = options.boundary,
        rootBoundary = options.rootBoundary,
        altBoundary = options.altBoundary,
        padding2 = options.padding,
        _options$tether = options.tether,
        tether = _options$tether === void 0 ? true : _options$tether,
        _options$tetherOffset = options.tetherOffset,
        tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
    var overflow = detectOverflow(state, {
        boundary,
        rootBoundary,
        padding: padding2,
        altBoundary,
    });
    var basePlacement = getBasePlacement(state.placement);
    var variation = getVariation(state.placement);
    var isBasePlacement = !variation;
    var mainAxis = getMainAxisFromPlacement(basePlacement);
    var altAxis = getAltAxis(mainAxis);
    var popperOffsets2 = state.modifiersData.popperOffsets;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var tetherOffsetValue =
        typeof tetherOffset === "function"
            ? tetherOffset(
                  Object.assign({}, state.rects, {
                      placement: state.placement,
                  })
              )
            : tetherOffset;
    var normalizedTetherOffsetValue =
        typeof tetherOffsetValue === "number"
            ? {
                  mainAxis: tetherOffsetValue,
                  altAxis: tetherOffsetValue,
              }
            : Object.assign(
                  {
                      mainAxis: 0,
                      altAxis: 0,
                  },
                  tetherOffsetValue
              );
    var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
    var data = {
        x: 0,
        y: 0,
    };
    if (!popperOffsets2) {
        return;
    }
    if (checkMainAxis) {
        var _offsetModifierState$;
        var mainSide = mainAxis === "y" ? top : left;
        var altSide = mainAxis === "y" ? bottom : right;
        var len = mainAxis === "y" ? "height" : "width";
        var offset2 = popperOffsets2[mainAxis];
        var min$1 = offset2 + overflow[mainSide];
        var max$1 = offset2 - overflow[altSide];
        var additive = tether ? -popperRect[len] / 2 : 0;
        var minLen = variation === start ? referenceRect[len] : popperRect[len];
        var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
        var arrowElement = state.elements.arrow;
        var arrowRect =
            tether && arrowElement
                ? getLayoutRect(arrowElement)
                : {
                      width: 0,
                      height: 0,
                  };
        var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
        var arrowPaddingMin = arrowPaddingObject[mainSide];
        var arrowPaddingMax = arrowPaddingObject[altSide];
        var arrowLen = within(0, referenceRect[len], arrowRect[len]);
        var minOffset = isBasePlacement
            ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis
            : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
        var maxOffset = isBasePlacement
            ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis
            : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
        var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
        var clientOffset = arrowOffsetParent ? (mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0) : 0;
        var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
        var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
        var tetherMax = offset2 + maxOffset - offsetModifierValue;
        var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset2, tether ? max(max$1, tetherMax) : max$1);
        popperOffsets2[mainAxis] = preventedOffset;
        data[mainAxis] = preventedOffset - offset2;
    }
    if (checkAltAxis) {
        var _offsetModifierState$2;
        var _mainSide = mainAxis === "x" ? top : left;
        var _altSide = mainAxis === "x" ? bottom : right;
        var _offset = popperOffsets2[altAxis];
        var _len = altAxis === "y" ? "height" : "width";
        var _min = _offset + overflow[_mainSide];
        var _max = _offset - overflow[_altSide];
        var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
        var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
        var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
        var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
        var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
        popperOffsets2[altAxis] = _preventedOffset;
        data[altAxis] = _preventedOffset - _offset;
    }
    state.modifiersData[name] = data;
}
const preventOverflow$1 = {
    name: "preventOverflow",
    enabled: true,
    phase: "main",
    fn: preventOverflow,
    requiresIfExists: ["offset"],
};
function getHTMLElementScroll(element) {
    return {
        scrollLeft: element.scrollLeft,
        scrollTop: element.scrollTop,
    };
}
function getNodeScroll(node2) {
    if (node2 === getWindow(node2) || !isHTMLElement$1(node2)) {
        return getWindowScroll(node2);
    } else {
        return getHTMLElementScroll(node2);
    }
}
function isElementScaled(element) {
    var rect = element.getBoundingClientRect();
    var scaleX = round$1(rect.width) / element.offsetWidth || 1;
    var scaleY = round$1(rect.height) / element.offsetHeight || 1;
    return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
    if (isFixed === void 0) {
        isFixed = false;
    }
    var isOffsetParentAnElement = isHTMLElement$1(offsetParent);
    var offsetParentIsScaled = isHTMLElement$1(offsetParent) && isElementScaled(offsetParent);
    var documentElement = getDocumentElement(offsetParent);
    var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
    var scroll = {
        scrollLeft: 0,
        scrollTop: 0,
    };
    var offsets = {
        x: 0,
        y: 0,
    };
    if (isOffsetParentAnElement || (!isOffsetParentAnElement && !isFixed)) {
        if (
            getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
            isScrollParent(documentElement)
        ) {
            scroll = getNodeScroll(offsetParent);
        }
        if (isHTMLElement$1(offsetParent)) {
            offsets = getBoundingClientRect(offsetParent, true);
            offsets.x += offsetParent.clientLeft;
            offsets.y += offsetParent.clientTop;
        } else if (documentElement) {
            offsets.x = getWindowScrollBarX(documentElement);
        }
    }
    return {
        x: rect.left + scroll.scrollLeft - offsets.x,
        y: rect.top + scroll.scrollTop - offsets.y,
        width: rect.width,
        height: rect.height,
    };
}
function order(modifiers) {
    var map = /* @__PURE__ */ new Map();
    var visited = /* @__PURE__ */ new Set();
    var result = [];
    modifiers.forEach(function (modifier) {
        map.set(modifier.name, modifier);
    });
    function sort(modifier) {
        visited.add(modifier.name);
        var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
        requires.forEach(function (dep) {
            if (!visited.has(dep)) {
                var depModifier = map.get(dep);
                if (depModifier) {
                    sort(depModifier);
                }
            }
        });
        result.push(modifier);
    }
    modifiers.forEach(function (modifier) {
        if (!visited.has(modifier.name)) {
            sort(modifier);
        }
    });
    return result;
}
function orderModifiers(modifiers) {
    var orderedModifiers = order(modifiers);
    return modifierPhases.reduce(function (acc, phase) {
        return acc.concat(
            orderedModifiers.filter(function (modifier) {
                return modifier.phase === phase;
            })
        );
    }, []);
}
function debounce(fn2) {
    var pending;
    return function () {
        if (!pending) {
            pending = new Promise(function (resolve) {
                Promise.resolve().then(function () {
                    pending = void 0;
                    resolve(fn2());
                });
            });
        }
        return pending;
    };
}
function mergeByName(modifiers) {
    var merged = modifiers.reduce(function (merged2, current) {
        var existing = merged2[current.name];
        merged2[current.name] = existing
            ? Object.assign({}, existing, current, {
                  options: Object.assign({}, existing.options, current.options),
                  data: Object.assign({}, existing.data, current.data),
              })
            : current;
        return merged2;
    }, {});
    return Object.keys(merged).map(function (key) {
        return merged[key];
    });
}
var DEFAULT_OPTIONS = {
    placement: "bottom",
    modifiers: [],
    strategy: "absolute",
};
function areValidElements() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
    }
    return !args.some(function (element) {
        return !(element && typeof element.getBoundingClientRect === "function");
    });
}
function popperGenerator(generatorOptions) {
    if (generatorOptions === void 0) {
        generatorOptions = {};
    }
    var _generatorOptions = generatorOptions,
        _generatorOptions$def = _generatorOptions.defaultModifiers,
        defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,
        _generatorOptions$def2 = _generatorOptions.defaultOptions,
        defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
    return function createPopper2(reference2, popper2, options) {
        if (options === void 0) {
            options = defaultOptions;
        }
        var state = {
            placement: "bottom",
            orderedModifiers: [],
            options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
            modifiersData: {},
            elements: {
                reference: reference2,
                popper: popper2,
            },
            attributes: {},
            styles: {},
        };
        var effectCleanupFns = [];
        var isDestroyed = false;
        var instance = {
            state,
            setOptions: function setOptions(setOptionsAction) {
                var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
                cleanupModifierEffects();
                state.options = Object.assign({}, defaultOptions, state.options, options2);
                state.scrollParents = {
                    reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
                    popper: listScrollParents(popper2),
                };
                var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
                state.orderedModifiers = orderedModifiers.filter(function (m2) {
                    return m2.enabled;
                });
                runModifierEffects();
                return instance.update();
            },
            // Sync update  it will always be executed, even if not necessary. This
            // is useful for low frequency updates where sync behavior simplifies the
            // logic.
            // For high frequency updates (e.g. `resize` and `scroll` events), always
            // prefer the async Popper#update method
            forceUpdate: function forceUpdate() {
                if (isDestroyed) {
                    return;
                }
                var _state$elements = state.elements,
                    reference3 = _state$elements.reference,
                    popper3 = _state$elements.popper;
                if (!areValidElements(reference3, popper3)) {
                    return;
                }
                state.rects = {
                    reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
                    popper: getLayoutRect(popper3),
                };
                state.reset = false;
                state.placement = state.options.placement;
                state.orderedModifiers.forEach(function (modifier) {
                    return (state.modifiersData[modifier.name] = Object.assign({}, modifier.data));
                });
                for (var index = 0; index < state.orderedModifiers.length; index++) {
                    if (state.reset === true) {
                        state.reset = false;
                        index = -1;
                        continue;
                    }
                    var _state$orderedModifie = state.orderedModifiers[index],
                        fn2 = _state$orderedModifie.fn,
                        _state$orderedModifie2 = _state$orderedModifie.options,
                        _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,
                        name = _state$orderedModifie.name;
                    if (typeof fn2 === "function") {
                        state =
                            fn2({
                                state,
                                options: _options,
                                name,
                                instance,
                            }) || state;
                    }
                }
            },
            // Async and optimistically optimized update  it will not be executed if
            // not necessary (debounced to run at most once-per-tick)
            update: debounce(function () {
                return new Promise(function (resolve) {
                    instance.forceUpdate();
                    resolve(state);
                });
            }),
            destroy: function destroy() {
                cleanupModifierEffects();
                isDestroyed = true;
            },
        };
        if (!areValidElements(reference2, popper2)) {
            return instance;
        }
        instance.setOptions(options).then(function (state2) {
            if (!isDestroyed && options.onFirstUpdate) {
                options.onFirstUpdate(state2);
            }
        });
        function runModifierEffects() {
            state.orderedModifiers.forEach(function (_ref) {
                var name = _ref.name,
                    _ref$options = _ref.options,
                    options2 = _ref$options === void 0 ? {} : _ref$options,
                    effect2 = _ref.effect;
                if (typeof effect2 === "function") {
                    var cleanupFn = effect2({
                        state,
                        name,
                        instance,
                        options: options2,
                    });
                    var noopFn = function noopFn2() {};
                    effectCleanupFns.push(cleanupFn || noopFn);
                }
            });
        }
        function cleanupModifierEffects() {
            effectCleanupFns.forEach(function (fn2) {
                return fn2();
            });
            effectCleanupFns = [];
        }
        return instance;
    };
}
var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
var createPopper = /* @__PURE__ */ popperGenerator({
    defaultModifiers,
});
function getContainer$1(container2) {
    return typeof container2 === "function" ? container2() : container2;
}
const Portal = /* @__PURE__ */ reactExports.forwardRef(function Portal2(props, ref) {
    const { children, container: container2, disablePortal = false } = props;
    const [mountNode, setMountNode] = reactExports.useState(null);
    const handleRef = useForkRef(/* @__PURE__ */ reactExports.isValidElement(children) ? children.ref : null, ref);
    useEnhancedEffect$1(() => {
        if (!disablePortal) {
            setMountNode(getContainer$1(container2) || document.body);
        }
    }, [container2, disablePortal]);
    useEnhancedEffect$1(() => {
        if (mountNode && !disablePortal) {
            setRef(ref, mountNode);
            return () => {
                setRef(ref, null);
            };
        }
        return void 0;
    }, [ref, mountNode, disablePortal]);
    if (disablePortal) {
        if (/* @__PURE__ */ reactExports.isValidElement(children)) {
            const newProps = {
                ref: handleRef,
            };
            return /* @__PURE__ */ reactExports.cloneElement(children, newProps);
        }
        return /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Fragment, {
            children,
        });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Fragment, {
        children: mountNode ? /* @__PURE__ */ reactDomExports.createPortal(children, mountNode) : mountNode,
    });
});
const Portal$1 = Portal;
function getPopperUtilityClass(slot) {
    return generateUtilityClass("MuiPopper", slot);
}
generateUtilityClasses("MuiPopper", ["root"]);
const _excluded$X = [
        "anchorEl",
        "children",
        "component",
        "direction",
        "disablePortal",
        "modifiers",
        "open",
        "placement",
        "popperOptions",
        "popperRef",
        "slotProps",
        "slots",
        "TransitionProps",
        "ownerState",
    ],
    _excluded2$2 = [
        "anchorEl",
        "children",
        "container",
        "direction",
        "disablePortal",
        "keepMounted",
        "modifiers",
        "open",
        "placement",
        "popperOptions",
        "popperRef",
        "style",
        "transition",
        "slotProps",
        "slots",
    ];
function flipPlacement(placement, direction) {
    if (direction === "ltr") {
        return placement;
    }
    switch (placement) {
        case "bottom-end":
            return "bottom-start";
        case "bottom-start":
            return "bottom-end";
        case "top-end":
            return "top-start";
        case "top-start":
            return "top-end";
        default:
            return placement;
    }
}
function resolveAnchorEl$1(anchorEl) {
    return typeof anchorEl === "function" ? anchorEl() : anchorEl;
}
function isHTMLElement(element) {
    return element.nodeType !== void 0;
}
const useUtilityClasses$M = () => {
    const slots = {
        root: ["root"],
    };
    return composeClasses(slots, useClassNamesOverride(getPopperUtilityClass));
};
const defaultPopperOptions = {};
const PopperTooltip = /* @__PURE__ */ reactExports.forwardRef(function PopperTooltip2(props, ref) {
    var _ref;
    const {
            anchorEl,
            children,
            component,
            direction,
            disablePortal,
            modifiers,
            open: open2,
            placement: initialPlacement,
            popperOptions,
            popperRef: popperRefProp,
            slotProps = {},
            slots = {},
            TransitionProps,
        } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded$X);
    const tooltipRef = reactExports.useRef(null);
    const ownRef = useForkRef(tooltipRef, ref);
    const popperRef = reactExports.useRef(null);
    const handlePopperRef = useForkRef(popperRef, popperRefProp);
    const handlePopperRefRef = reactExports.useRef(handlePopperRef);
    useEnhancedEffect$1(() => {
        handlePopperRefRef.current = handlePopperRef;
    }, [handlePopperRef]);
    reactExports.useImperativeHandle(popperRefProp, () => popperRef.current, []);
    const rtlPlacement = flipPlacement(initialPlacement, direction);
    const [placement, setPlacement] = reactExports.useState(rtlPlacement);
    const [resolvedAnchorElement, setResolvedAnchorElement] = reactExports.useState(resolveAnchorEl$1(anchorEl));
    reactExports.useEffect(() => {
        if (popperRef.current) {
            popperRef.current.forceUpdate();
        }
    });
    reactExports.useEffect(() => {
        if (anchorEl) {
            setResolvedAnchorElement(resolveAnchorEl$1(anchorEl));
        }
    }, [anchorEl]);
    useEnhancedEffect$1(() => {
        if (!resolvedAnchorElement || !open2) {
            return void 0;
        }
        const handlePopperUpdate = (data) => {
            setPlacement(data.placement);
        };
        let popperModifiers = [
            {
                name: "preventOverflow",
                options: {
                    altBoundary: disablePortal,
                },
            },
            {
                name: "flip",
                options: {
                    altBoundary: disablePortal,
                },
            },
            {
                name: "onUpdate",
                enabled: true,
                phase: "afterWrite",
                fn: ({ state }) => {
                    handlePopperUpdate(state);
                },
            },
        ];
        if (modifiers != null) {
            popperModifiers = popperModifiers.concat(modifiers);
        }
        if (popperOptions && popperOptions.modifiers != null) {
            popperModifiers = popperModifiers.concat(popperOptions.modifiers);
        }
        const popper2 = createPopper(
            resolvedAnchorElement,
            tooltipRef.current,
            _extends(
                {
                    placement: rtlPlacement,
                },
                popperOptions,
                {
                    modifiers: popperModifiers,
                }
            )
        );
        handlePopperRefRef.current(popper2);
        return () => {
            popper2.destroy();
            handlePopperRefRef.current(null);
        };
    }, [resolvedAnchorElement, disablePortal, modifiers, open2, popperOptions, rtlPlacement]);
    const childProps = {
        placement,
    };
    if (TransitionProps !== null) {
        childProps.TransitionProps = TransitionProps;
    }
    const classes = useUtilityClasses$M();
    const Root = (_ref = component != null ? component : slots.root) != null ? _ref : "div";
    const rootProps = useSlotProps({
        elementType: Root,
        externalSlotProps: slotProps.root,
        externalForwardedProps: other,
        additionalProps: {
            role: "tooltip",
            ref: ownRef,
        },
        ownerState: props,
        className: classes.root,
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Root,
        _extends({}, rootProps, {
            children: typeof children === "function" ? children(childProps) : children,
        })
    );
});
const Popper$2 = /* @__PURE__ */ reactExports.forwardRef(function Popper(props, ref) {
    const {
            anchorEl,
            children,
            container: containerProp,
            direction = "ltr",
            disablePortal = false,
            keepMounted = false,
            modifiers,
            open: open2,
            placement = "bottom",
            popperOptions = defaultPopperOptions,
            popperRef,
            style: style2,
            transition = false,
            slotProps = {},
            slots = {},
        } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded2$2);
    const [exited, setExited] = reactExports.useState(true);
    const handleEnter = () => {
        setExited(false);
    };
    const handleExited = () => {
        setExited(true);
    };
    if (!keepMounted && !open2 && (!transition || exited)) {
        return null;
    }
    let container2;
    if (containerProp) {
        container2 = containerProp;
    } else if (anchorEl) {
        const resolvedAnchorEl = resolveAnchorEl$1(anchorEl);
        container2 = resolvedAnchorEl && isHTMLElement(resolvedAnchorEl) ? ownerDocument(resolvedAnchorEl).body : ownerDocument(null).body;
    }
    const display = !open2 && keepMounted && (!transition || exited) ? "none" : void 0;
    const transitionProps = transition
        ? {
              in: open2,
              onEnter: handleEnter,
              onExited: handleExited,
          }
        : void 0;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$1, {
        disablePortal,
        container: container2,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            PopperTooltip,
            _extends(
                {
                    anchorEl,
                    direction,
                    disablePortal,
                    modifiers,
                    ref,
                    open: transition ? !exited : open2,
                    placement,
                    popperOptions,
                    popperRef,
                    slotProps,
                    slots,
                },
                other,
                {
                    style: _extends(
                        {
                            // Prevents scroll issue, waiting for Popper.js to add this style once initiated.
                            position: "fixed",
                            // Fix Popper.js display issue
                            top: 0,
                            left: 0,
                            display,
                        },
                        style2
                    ),
                    TransitionProps: transitionProps,
                    children,
                }
            )
        ),
    });
});
const BasePopper = Popper$2;
function isOverflowing(container2) {
    const doc = ownerDocument(container2);
    if (doc.body === container2) {
        return ownerWindow(container2).innerWidth > doc.documentElement.clientWidth;
    }
    return container2.scrollHeight > container2.clientHeight;
}
function ariaHidden(element, show) {
    if (show) {
        element.setAttribute("aria-hidden", "true");
    } else {
        element.removeAttribute("aria-hidden");
    }
}
function getPaddingRight(element) {
    return parseInt(ownerWindow(element).getComputedStyle(element).paddingRight, 10) || 0;
}
function isAriaHiddenForbiddenOnElement(element) {
    const forbiddenTagNames = ["TEMPLATE", "SCRIPT", "STYLE", "LINK", "MAP", "META", "NOSCRIPT", "PICTURE", "COL", "COLGROUP", "PARAM", "SLOT", "SOURCE", "TRACK"];
    const isForbiddenTagName = forbiddenTagNames.indexOf(element.tagName) !== -1;
    const isInputHidden = element.tagName === "INPUT" && element.getAttribute("type") === "hidden";
    return isForbiddenTagName || isInputHidden;
}
function ariaHiddenSiblings(container2, mountElement, currentElement, elementsToExclude, show) {
    const blacklist = [mountElement, currentElement, ...elementsToExclude];
    [].forEach.call(container2.children, (element) => {
        const isNotExcludedElement = blacklist.indexOf(element) === -1;
        const isNotForbiddenElement = !isAriaHiddenForbiddenOnElement(element);
        if (isNotExcludedElement && isNotForbiddenElement) {
            ariaHidden(element, show);
        }
    });
}
function findIndexOf(items, callback) {
    let idx = -1;
    items.some((item, index) => {
        if (callback(item)) {
            idx = index;
            return true;
        }
        return false;
    });
    return idx;
}
function handleContainer(containerInfo, props) {
    const restoreStyle = [];
    const container2 = containerInfo.container;
    if (!props.disableScrollLock) {
        if (isOverflowing(container2)) {
            const scrollbarSize = getScrollbarSize(ownerDocument(container2));
            restoreStyle.push({
                value: container2.style.paddingRight,
                property: "padding-right",
                el: container2,
            });
            container2.style.paddingRight = `${getPaddingRight(container2) + scrollbarSize}px`;
            const fixedElements2 = ownerDocument(container2).querySelectorAll(".mui-fixed");
            [].forEach.call(fixedElements2, (element) => {
                restoreStyle.push({
                    value: element.style.paddingRight,
                    property: "padding-right",
                    el: element,
                });
                element.style.paddingRight = `${getPaddingRight(element) + scrollbarSize}px`;
            });
        }
        let scrollContainer;
        if (container2.parentNode instanceof DocumentFragment) {
            scrollContainer = ownerDocument(container2).body;
        } else {
            const parent = container2.parentElement;
            const containerWindow = ownerWindow(container2);
            scrollContainer = (parent == null ? void 0 : parent.nodeName) === "HTML" && containerWindow.getComputedStyle(parent).overflowY === "scroll" ? parent : container2;
        }
        restoreStyle.push(
            {
                value: scrollContainer.style.overflow,
                property: "overflow",
                el: scrollContainer,
            },
            {
                value: scrollContainer.style.overflowX,
                property: "overflow-x",
                el: scrollContainer,
            },
            {
                value: scrollContainer.style.overflowY,
                property: "overflow-y",
                el: scrollContainer,
            }
        );
        scrollContainer.style.overflow = "hidden";
    }
    const restore = () => {
        restoreStyle.forEach(({ value, el, property }) => {
            if (value) {
                el.style.setProperty(property, value);
            } else {
                el.style.removeProperty(property);
            }
        });
    };
    return restore;
}
function getHiddenSiblings(container2) {
    const hiddenSiblings = [];
    [].forEach.call(container2.children, (element) => {
        if (element.getAttribute("aria-hidden") === "true") {
            hiddenSiblings.push(element);
        }
    });
    return hiddenSiblings;
}
class ModalManager {
    constructor() {
        this.containers = void 0;
        this.modals = void 0;
        this.modals = [];
        this.containers = [];
    }
    add(modal, container2) {
        let modalIndex = this.modals.indexOf(modal);
        if (modalIndex !== -1) {
            return modalIndex;
        }
        modalIndex = this.modals.length;
        this.modals.push(modal);
        if (modal.modalRef) {
            ariaHidden(modal.modalRef, false);
        }
        const hiddenSiblings = getHiddenSiblings(container2);
        ariaHiddenSiblings(container2, modal.mount, modal.modalRef, hiddenSiblings, true);
        const containerIndex = findIndexOf(this.containers, (item) => item.container === container2);
        if (containerIndex !== -1) {
            this.containers[containerIndex].modals.push(modal);
            return modalIndex;
        }
        this.containers.push({
            modals: [modal],
            container: container2,
            restore: null,
            hiddenSiblings,
        });
        return modalIndex;
    }
    mount(modal, props) {
        const containerIndex = findIndexOf(this.containers, (item) => item.modals.indexOf(modal) !== -1);
        const containerInfo = this.containers[containerIndex];
        if (!containerInfo.restore) {
            containerInfo.restore = handleContainer(containerInfo, props);
        }
    }
    remove(modal, ariaHiddenState = true) {
        const modalIndex = this.modals.indexOf(modal);
        if (modalIndex === -1) {
            return modalIndex;
        }
        const containerIndex = findIndexOf(this.containers, (item) => item.modals.indexOf(modal) !== -1);
        const containerInfo = this.containers[containerIndex];
        containerInfo.modals.splice(containerInfo.modals.indexOf(modal), 1);
        this.modals.splice(modalIndex, 1);
        if (containerInfo.modals.length === 0) {
            if (containerInfo.restore) {
                containerInfo.restore();
            }
            if (modal.modalRef) {
                ariaHidden(modal.modalRef, ariaHiddenState);
            }
            ariaHiddenSiblings(containerInfo.container, modal.mount, modal.modalRef, containerInfo.hiddenSiblings, false);
            this.containers.splice(containerIndex, 1);
        } else {
            const nextTop = containerInfo.modals[containerInfo.modals.length - 1];
            if (nextTop.modalRef) {
                ariaHidden(nextTop.modalRef, false);
            }
        }
        return modalIndex;
    }
    isTopModal(modal) {
        return this.modals.length > 0 && this.modals[this.modals.length - 1] === modal;
    }
}
function getModalUtilityClass(slot) {
    return generateUtilityClass("MuiModal", slot);
}
generateUtilityClasses("MuiModal", ["root", "hidden", "backdrop"]);
const _excluded$W = [
    "children",
    "closeAfterTransition",
    "component",
    "container",
    "disableAutoFocus",
    "disableEnforceFocus",
    "disableEscapeKeyDown",
    "disablePortal",
    "disableRestoreFocus",
    "disableScrollLock",
    "hideBackdrop",
    "keepMounted",
    "manager",
    "onBackdropClick",
    "onClose",
    "onKeyDown",
    "open",
    "onTransitionEnter",
    "onTransitionExited",
    "slotProps",
    "slots",
];
const useUtilityClasses$L = (ownerState) => {
    const { open: open2, exited } = ownerState;
    const slots = {
        root: ["root", !open2 && exited && "hidden"],
        backdrop: ["backdrop"],
    };
    return composeClasses(slots, useClassNamesOverride(getModalUtilityClass));
};
function getContainer(container2) {
    return typeof container2 === "function" ? container2() : container2;
}
function getHasTransition(children) {
    return children ? children.props.hasOwnProperty("in") : false;
}
const defaultManager = new ModalManager();
const Modal$2 = /* @__PURE__ */ reactExports.forwardRef(function Modal(props, forwardedRef) {
    var _props$ariaHidden, _ref;
    const {
            children,
            closeAfterTransition = false,
            component,
            container: container2,
            disableAutoFocus = false,
            disableEnforceFocus = false,
            disableEscapeKeyDown = false,
            disablePortal = false,
            disableRestoreFocus = false,
            disableScrollLock = false,
            hideBackdrop = false,
            keepMounted = false,
            // private
            manager = defaultManager,
            onBackdropClick,
            onClose,
            onKeyDown,
            open: open2,
            onTransitionEnter,
            onTransitionExited,
            slotProps = {},
            slots = {},
        } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded$W);
    const [exited, setExited] = reactExports.useState(!open2);
    const modal = reactExports.useRef({});
    const mountNodeRef = reactExports.useRef(null);
    const modalRef = reactExports.useRef(null);
    const handleRef = useForkRef(modalRef, forwardedRef);
    const hasTransition = getHasTransition(children);
    const ariaHiddenProp = (_props$ariaHidden = props["aria-hidden"]) != null ? _props$ariaHidden : true;
    const getDoc = () => ownerDocument(mountNodeRef.current);
    const getModal = () => {
        modal.current.modalRef = modalRef.current;
        modal.current.mountNode = mountNodeRef.current;
        return modal.current;
    };
    const handleMounted = () => {
        manager.mount(getModal(), {
            disableScrollLock,
        });
        if (modalRef.current) {
            modalRef.current.scrollTop = 0;
        }
    };
    const handleOpen = useEventCallback(() => {
        const resolvedContainer = getContainer(container2) || getDoc().body;
        manager.add(getModal(), resolvedContainer);
        if (modalRef.current) {
            handleMounted();
        }
    });
    const isTopModal = reactExports.useCallback(() => manager.isTopModal(getModal()), [manager]);
    const handlePortalRef = useEventCallback((node2) => {
        mountNodeRef.current = node2;
        if (!node2 || !modalRef.current) {
            return;
        }
        if (open2 && isTopModal()) {
            handleMounted();
        } else {
            ariaHidden(modalRef.current, ariaHiddenProp);
        }
    });
    const handleClose = reactExports.useCallback(() => {
        manager.remove(getModal(), ariaHiddenProp);
    }, [manager, ariaHiddenProp]);
    reactExports.useEffect(() => {
        return () => {
            handleClose();
        };
    }, [handleClose]);
    reactExports.useEffect(() => {
        if (open2) {
            handleOpen();
        } else if (!hasTransition || !closeAfterTransition) {
            handleClose();
        }
    }, [open2, handleClose, hasTransition, closeAfterTransition, handleOpen]);
    const ownerState = _extends({}, props, {
        closeAfterTransition,
        disableAutoFocus,
        disableEnforceFocus,
        disableEscapeKeyDown,
        disablePortal,
        disableRestoreFocus,
        disableScrollLock,
        exited,
        hideBackdrop,
        keepMounted,
    });
    const classes = useUtilityClasses$L(ownerState);
    const handleEnter = () => {
        setExited(false);
        if (onTransitionEnter) {
            onTransitionEnter();
        }
    };
    const handleExited = () => {
        setExited(true);
        if (onTransitionExited) {
            onTransitionExited();
        }
        if (closeAfterTransition) {
            handleClose();
        }
    };
    const handleBackdropClick = (event) => {
        if (event.target !== event.currentTarget) {
            return;
        }
        if (onBackdropClick) {
            onBackdropClick(event);
        }
        if (onClose) {
            onClose(event, "backdropClick");
        }
    };
    const handleKeyDown2 = (event) => {
        if (onKeyDown) {
            onKeyDown(event);
        }
        if (event.key !== "Escape" || !isTopModal()) {
            return;
        }
        if (!disableEscapeKeyDown) {
            event.stopPropagation();
            if (onClose) {
                onClose(event, "escapeKeyDown");
            }
        }
    };
    const childProps = {};
    if (children.props.tabIndex === void 0) {
        childProps.tabIndex = "-1";
    }
    if (hasTransition) {
        childProps.onEnter = createChainedFunction(handleEnter, children.props.onEnter);
        childProps.onExited = createChainedFunction(handleExited, children.props.onExited);
    }
    const Root = (_ref = component != null ? component : slots.root) != null ? _ref : "div";
    const rootProps = useSlotProps({
        elementType: Root,
        externalSlotProps: slotProps.root,
        externalForwardedProps: other,
        additionalProps: {
            ref: handleRef,
            role: "presentation",
            onKeyDown: handleKeyDown2,
        },
        className: classes.root,
        ownerState,
    });
    const BackdropComponent = slots.backdrop;
    const backdropProps = useSlotProps({
        elementType: BackdropComponent,
        externalSlotProps: slotProps.backdrop,
        additionalProps: {
            "aria-hidden": true,
            onClick: handleBackdropClick,
            open: open2,
        },
        className: classes.backdrop,
        ownerState,
    });
    if (!keepMounted && !open2 && (!hasTransition || exited)) {
        return null;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$1, {
        ref: handlePortalRef,
        container: container2,
        disablePortal,
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Root,
            _extends({}, rootProps, {
                children: [
                    !hideBackdrop && BackdropComponent ? /* @__PURE__ */ jsxRuntimeExports.jsx(BackdropComponent, _extends({}, backdropProps)) : null,
                    /* @__PURE__ */ jsxRuntimeExports.jsx(FocusTrap, {
                        disableEnforceFocus,
                        disableAutoFocus,
                        disableRestoreFocus,
                        isEnabled: isTopModal,
                        open: open2,
                        children: /* @__PURE__ */ reactExports.cloneElement(children, childProps),
                    }),
                ],
            })
        ),
    });
});
const ModalUnstyled = Modal$2;
const _excluded$V = ["onChange", "maxRows", "minRows", "style", "value"];
function getStyleValue(value) {
    return parseInt(value, 10) || 0;
}
const styles$3 = {
    shadow: {
        // Visibility needed to hide the extra text area on iPads
        visibility: "hidden",
        // Remove from the content flow
        position: "absolute",
        // Ignore the scrollbar width
        overflow: "hidden",
        height: 0,
        top: 0,
        left: 0,
        // Create a new layer, increase the isolation of the computed values
        transform: "translateZ(0)",
    },
};
function isEmpty$1(obj) {
    return obj === void 0 || obj === null || Object.keys(obj).length === 0 || (obj.outerHeightStyle === 0 && !obj.overflow);
}
const TextareaAutosize = /* @__PURE__ */ reactExports.forwardRef(function TextareaAutosize2(props, ref) {
    const { onChange, maxRows, minRows = 1, style: style2, value } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded$V);
    const { current: isControlled } = reactExports.useRef(value != null);
    const inputRef = reactExports.useRef(null);
    const handleRef = useForkRef(ref, inputRef);
    const shadowRef = reactExports.useRef(null);
    const renders = reactExports.useRef(0);
    const [state, setState] = reactExports.useState({
        outerHeightStyle: 0,
    });
    const getUpdatedState = reactExports.useCallback(() => {
        const input = inputRef.current;
        const containerWindow = ownerWindow(input);
        const computedStyle = containerWindow.getComputedStyle(input);
        if (computedStyle.width === "0px") {
            return {
                outerHeightStyle: 0,
            };
        }
        const inputShallow = shadowRef.current;
        inputShallow.style.width = computedStyle.width;
        inputShallow.value = input.value || props.placeholder || "x";
        if (inputShallow.value.slice(-1) === "\n") {
            inputShallow.value += " ";
        }
        const boxSizing2 = computedStyle.boxSizing;
        const padding2 = getStyleValue(computedStyle.paddingBottom) + getStyleValue(computedStyle.paddingTop);
        const border2 = getStyleValue(computedStyle.borderBottomWidth) + getStyleValue(computedStyle.borderTopWidth);
        const innerHeight = inputShallow.scrollHeight;
        inputShallow.value = "x";
        const singleRowHeight = inputShallow.scrollHeight;
        let outerHeight = innerHeight;
        if (minRows) {
            outerHeight = Math.max(Number(minRows) * singleRowHeight, outerHeight);
        }
        if (maxRows) {
            outerHeight = Math.min(Number(maxRows) * singleRowHeight, outerHeight);
        }
        outerHeight = Math.max(outerHeight, singleRowHeight);
        const outerHeightStyle = outerHeight + (boxSizing2 === "border-box" ? padding2 + border2 : 0);
        const overflow = Math.abs(outerHeight - innerHeight) <= 1;
        return {
            outerHeightStyle,
            overflow,
        };
    }, [maxRows, minRows, props.placeholder]);
    const updateState = (prevState, newState) => {
        const { outerHeightStyle, overflow } = newState;
        if (renders.current < 20 && ((outerHeightStyle > 0 && Math.abs((prevState.outerHeightStyle || 0) - outerHeightStyle) > 1) || prevState.overflow !== overflow)) {
            renders.current += 1;
            return {
                overflow,
                outerHeightStyle,
            };
        }
        return prevState;
    };
    const syncHeight = reactExports.useCallback(() => {
        const newState = getUpdatedState();
        if (isEmpty$1(newState)) {
            return;
        }
        setState((prevState) => {
            return updateState(prevState, newState);
        });
    }, [getUpdatedState]);
    const syncHeightWithFlushSync = () => {
        const newState = getUpdatedState();
        if (isEmpty$1(newState)) {
            return;
        }
        reactDomExports.flushSync(() => {
            setState((prevState) => {
                return updateState(prevState, newState);
            });
        });
    };
    reactExports.useEffect(() => {
        const handleResize = debounce$1(() => {
            renders.current = 0;
            if (inputRef.current) {
                syncHeightWithFlushSync();
            }
        });
        let resizeObserver;
        const input = inputRef.current;
        const containerWindow = ownerWindow(input);
        containerWindow.addEventListener("resize", handleResize);
        if (typeof ResizeObserver !== "undefined") {
            resizeObserver = new ResizeObserver(handleResize);
            resizeObserver.observe(input);
        }
        return () => {
            handleResize.clear();
            containerWindow.removeEventListener("resize", handleResize);
            if (resizeObserver) {
                resizeObserver.disconnect();
            }
        };
    });
    useEnhancedEffect$1(() => {
        syncHeight();
    });
    reactExports.useEffect(() => {
        renders.current = 0;
    }, [value]);
    const handleChange = (event) => {
        renders.current = 0;
        if (!isControlled) {
            syncHeight();
        }
        if (onChange) {
            onChange(event);
        }
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
        children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
                "textarea",
                _extends(
                    {
                        value,
                        onChange: handleChange,
                        ref: handleRef,
                        rows: minRows,
                        style: _extends(
                            {
                                height: state.outerHeightStyle,
                                // Need a large enough difference to allow scrolling.
                                // This prevents infinite rendering loop.
                                overflow: state.overflow ? "hidden" : void 0,
                            },
                            style2
                        ),
                    },
                    other
                )
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("textarea", {
                "aria-hidden": true,
                className: props.className,
                readOnly: true,
                ref: shadowRef,
                tabIndex: -1,
                style: _extends({}, styles$3.shadow, style2, {
                    padding: 0,
                }),
            }),
        ],
    });
});
const TextareaAutosize$1 = TextareaAutosize;
function stripDiacritics(string) {
    return typeof string.normalize !== "undefined" ? string.normalize("NFD").replace(/[\u0300-\u036f]/g, "") : string;
}
function createFilterOptions(config = {}) {
    const { ignoreAccents = true, ignoreCase = true, limit, matchFrom = "any", stringify: stringify2, trim: trim2 = false } = config;
    return (options, { inputValue, getOptionLabel }) => {
        let input = trim2 ? inputValue.trim() : inputValue;
        if (ignoreCase) {
            input = input.toLowerCase();
        }
        if (ignoreAccents) {
            input = stripDiacritics(input);
        }
        const filteredOptions = !input
            ? options
            : options.filter((option) => {
                  let candidate = (stringify2 || getOptionLabel)(option);
                  if (ignoreCase) {
                      candidate = candidate.toLowerCase();
                  }
                  if (ignoreAccents) {
                      candidate = stripDiacritics(candidate);
                  }
                  return matchFrom === "start" ? candidate.indexOf(input) === 0 : candidate.indexOf(input) > -1;
              });
        return typeof limit === "number" ? filteredOptions.slice(0, limit) : filteredOptions;
    };
}
function findIndex$1(array, comp) {
    for (let i = 0; i < array.length; i += 1) {
        if (comp(array[i])) {
            return i;
        }
    }
    return -1;
}
const defaultFilterOptions = createFilterOptions();
const pageSize = 5;
const defaultIsActiveElementInListbox = (listboxRef) => {
    var _listboxRef$current$p;
    return listboxRef.current !== null && ((_listboxRef$current$p = listboxRef.current.parentElement) == null ? void 0 : _listboxRef$current$p.contains(document.activeElement));
};
function useAutocomplete(props) {
    const {
        // eslint-disable-next-line @typescript-eslint/naming-convention
        unstable_isActiveElementInListbox = defaultIsActiveElementInListbox,
        // eslint-disable-next-line @typescript-eslint/naming-convention
        unstable_classNamePrefix = "Mui",
        autoComplete = false,
        autoHighlight = false,
        autoSelect = false,
        blurOnSelect = false,
        clearOnBlur = !props.freeSolo,
        clearOnEscape = false,
        componentName = "useAutocomplete",
        defaultValue = props.multiple ? [] : null,
        disableClearable = false,
        disableCloseOnSelect = false,
        disabled: disabledProp,
        disabledItemsFocusable = false,
        disableListWrap = false,
        filterOptions = defaultFilterOptions,
        filterSelectedOptions = false,
        freeSolo = false,
        getOptionDisabled,
        getOptionLabel: getOptionLabelProp = (option) => {
            var _option$label;
            return (_option$label = option.label) != null ? _option$label : option;
        },
        groupBy,
        handleHomeEndKeys = !props.freeSolo,
        id: idProp,
        includeInputInList = false,
        inputValue: inputValueProp,
        isOptionEqualToValue = (option, value2) => option === value2,
        multiple = false,
        onChange,
        onClose,
        onHighlightChange,
        onInputChange,
        onOpen,
        open: openProp,
        openOnFocus = false,
        options,
        readOnly = false,
        selectOnFocus = !props.freeSolo,
        value: valueProp,
    } = props;
    const id = useId(idProp);
    let getOptionLabel = getOptionLabelProp;
    getOptionLabel = (option) => {
        const optionLabel = getOptionLabelProp(option);
        if (typeof optionLabel !== "string") {
            return String(optionLabel);
        }
        return optionLabel;
    };
    const ignoreFocus = reactExports.useRef(false);
    const firstFocus = reactExports.useRef(true);
    const inputRef = reactExports.useRef(null);
    const listboxRef = reactExports.useRef(null);
    const [anchorEl, setAnchorEl] = reactExports.useState(null);
    const [focusedTag, setFocusedTag] = reactExports.useState(-1);
    const defaultHighlighted = autoHighlight ? 0 : -1;
    const highlightedIndexRef = reactExports.useRef(defaultHighlighted);
    const [value, setValueState] = useControlled({
        controlled: valueProp,
        default: defaultValue,
        name: componentName,
    });
    const [inputValue, setInputValueState] = useControlled({
        controlled: inputValueProp,
        default: "",
        name: componentName,
        state: "inputValue",
    });
    const [focused, setFocused] = reactExports.useState(false);
    const resetInputValue = reactExports.useCallback(
        (event, newValue) => {
            const isOptionSelected = multiple ? value.length < newValue.length : newValue !== null;
            if (!isOptionSelected && !clearOnBlur) {
                return;
            }
            let newInputValue;
            if (multiple) {
                newInputValue = "";
            } else if (newValue == null) {
                newInputValue = "";
            } else {
                const optionLabel = getOptionLabel(newValue);
                newInputValue = typeof optionLabel === "string" ? optionLabel : "";
            }
            if (inputValue === newInputValue) {
                return;
            }
            setInputValueState(newInputValue);
            if (onInputChange) {
                onInputChange(event, newInputValue, "reset");
            }
        },
        [getOptionLabel, inputValue, multiple, onInputChange, setInputValueState, clearOnBlur, value]
    );
    const [open2, setOpenState] = useControlled({
        controlled: openProp,
        default: false,
        name: componentName,
        state: "open",
    });
    const [inputPristine, setInputPristine] = reactExports.useState(true);
    const inputValueIsSelectedValue = !multiple && value != null && inputValue === getOptionLabel(value);
    const popupOpen = open2 && !readOnly;
    const filteredOptions = popupOpen
        ? filterOptions(
              options.filter((option) => {
                  if (filterSelectedOptions && (multiple ? value : [value]).some((value2) => value2 !== null && isOptionEqualToValue(option, value2))) {
                      return false;
                  }
                  return true;
              }),
              // we use the empty string to manipulate `filterOptions` to not filter any options
              // i.e. the filter predicate always returns true
              {
                  inputValue: inputValueIsSelectedValue && inputPristine ? "" : inputValue,
                  getOptionLabel,
              }
          )
        : [];
    const previousProps = usePreviousProps$1({
        filteredOptions,
        value,
    });
    reactExports.useEffect(() => {
        const valueChange = value !== previousProps.value;
        if (focused && !valueChange) {
            return;
        }
        if (freeSolo && !valueChange) {
            return;
        }
        resetInputValue(null, value);
    }, [value, resetInputValue, focused, previousProps.value, freeSolo]);
    const listboxAvailable = open2 && filteredOptions.length > 0 && !readOnly;
    const focusTag = useEventCallback((tagToFocus) => {
        if (tagToFocus === -1) {
            inputRef.current.focus();
        } else {
            anchorEl.querySelector(`[data-tag-index="${tagToFocus}"]`).focus();
        }
    });
    reactExports.useEffect(() => {
        if (multiple && focusedTag > value.length - 1) {
            setFocusedTag(-1);
            focusTag(-1);
        }
    }, [value, multiple, focusedTag, focusTag]);
    function validOptionIndex(index, direction) {
        if (!listboxRef.current || index === -1) {
            return -1;
        }
        let nextFocus = index;
        while (true) {
            if ((direction === "next" && nextFocus === filteredOptions.length) || (direction === "previous" && nextFocus === -1)) {
                return -1;
            }
            const option = listboxRef.current.querySelector(`[data-option-index="${nextFocus}"]`);
            const nextFocusDisabled = disabledItemsFocusable ? false : !option || option.disabled || option.getAttribute("aria-disabled") === "true";
            if ((option && !option.hasAttribute("tabindex")) || nextFocusDisabled) {
                nextFocus += direction === "next" ? 1 : -1;
            } else {
                return nextFocus;
            }
        }
    }
    const setHighlightedIndex = useEventCallback(({ event, index, reason = "auto" }) => {
        highlightedIndexRef.current = index;
        if (index === -1) {
            inputRef.current.removeAttribute("aria-activedescendant");
        } else {
            inputRef.current.setAttribute("aria-activedescendant", `${id}-option-${index}`);
        }
        if (onHighlightChange) {
            onHighlightChange(event, index === -1 ? null : filteredOptions[index], reason);
        }
        if (!listboxRef.current) {
            return;
        }
        const prev2 = listboxRef.current.querySelector(`[role="option"].${unstable_classNamePrefix}-focused`);
        if (prev2) {
            prev2.classList.remove(`${unstable_classNamePrefix}-focused`);
            prev2.classList.remove(`${unstable_classNamePrefix}-focusVisible`);
        }
        const listboxNode = listboxRef.current.parentElement.querySelector('[role="listbox"]');
        if (!listboxNode) {
            return;
        }
        if (index === -1) {
            listboxNode.scrollTop = 0;
            return;
        }
        const option = listboxRef.current.querySelector(`[data-option-index="${index}"]`);
        if (!option) {
            return;
        }
        option.classList.add(`${unstable_classNamePrefix}-focused`);
        if (reason === "keyboard") {
            option.classList.add(`${unstable_classNamePrefix}-focusVisible`);
        }
        if (listboxNode.scrollHeight > listboxNode.clientHeight && reason !== "mouse") {
            const element = option;
            const scrollBottom = listboxNode.clientHeight + listboxNode.scrollTop;
            const elementBottom = element.offsetTop + element.offsetHeight;
            if (elementBottom > scrollBottom) {
                listboxNode.scrollTop = elementBottom - listboxNode.clientHeight;
            } else if (element.offsetTop - element.offsetHeight * (groupBy ? 1.3 : 0) < listboxNode.scrollTop) {
                listboxNode.scrollTop = element.offsetTop - element.offsetHeight * (groupBy ? 1.3 : 0);
            }
        }
    });
    const changeHighlightedIndex = useEventCallback(({ event, diff, direction = "next", reason = "auto" }) => {
        if (!popupOpen) {
            return;
        }
        const getNextIndex = () => {
            const maxIndex = filteredOptions.length - 1;
            if (diff === "reset") {
                return defaultHighlighted;
            }
            if (diff === "start") {
                return 0;
            }
            if (diff === "end") {
                return maxIndex;
            }
            const newIndex = highlightedIndexRef.current + diff;
            if (newIndex < 0) {
                if (newIndex === -1 && includeInputInList) {
                    return -1;
                }
                if ((disableListWrap && highlightedIndexRef.current !== -1) || Math.abs(diff) > 1) {
                    return 0;
                }
                return maxIndex;
            }
            if (newIndex > maxIndex) {
                if (newIndex === maxIndex + 1 && includeInputInList) {
                    return -1;
                }
                if (disableListWrap || Math.abs(diff) > 1) {
                    return maxIndex;
                }
                return 0;
            }
            return newIndex;
        };
        const nextIndex = validOptionIndex(getNextIndex(), direction);
        setHighlightedIndex({
            index: nextIndex,
            reason,
            event,
        });
        if (autoComplete && diff !== "reset") {
            if (nextIndex === -1) {
                inputRef.current.value = inputValue;
            } else {
                const option = getOptionLabel(filteredOptions[nextIndex]);
                inputRef.current.value = option;
                const index = option.toLowerCase().indexOf(inputValue.toLowerCase());
                if (index === 0 && inputValue.length > 0) {
                    inputRef.current.setSelectionRange(inputValue.length, option.length);
                }
            }
        }
    });
    const checkHighlightedOptionExists = () => {
        const isSameValue = (value1, value2) => {
            const label1 = value1 ? getOptionLabel(value1) : "";
            const label2 = value2 ? getOptionLabel(value2) : "";
            return label1 === label2;
        };
        if (
            highlightedIndexRef.current !== -1 &&
            previousProps.filteredOptions &&
            previousProps.filteredOptions.length !== filteredOptions.length &&
            (multiple
                ? value.length === previousProps.value.length && previousProps.value.every((val, i) => getOptionLabel(value[i]) === getOptionLabel(val))
                : isSameValue(previousProps.value, value))
        ) {
            const previousHighlightedOption = previousProps.filteredOptions[highlightedIndexRef.current];
            if (previousHighlightedOption) {
                const previousHighlightedOptionExists = filteredOptions.some((option) => {
                    return getOptionLabel(option) === getOptionLabel(previousHighlightedOption);
                });
                if (previousHighlightedOptionExists) {
                    return true;
                }
            }
        }
        return false;
    };
    const syncHighlightedIndex = reactExports.useCallback(() => {
        if (!popupOpen) {
            return;
        }
        if (checkHighlightedOptionExists()) {
            return;
        }
        const valueItem = multiple ? value[0] : value;
        if (filteredOptions.length === 0 || valueItem == null) {
            changeHighlightedIndex({
                diff: "reset",
            });
            return;
        }
        if (!listboxRef.current) {
            return;
        }
        if (valueItem != null) {
            const currentOption = filteredOptions[highlightedIndexRef.current];
            if (multiple && currentOption && findIndex$1(value, (val) => isOptionEqualToValue(currentOption, val)) !== -1) {
                return;
            }
            const itemIndex = findIndex$1(filteredOptions, (optionItem) => isOptionEqualToValue(optionItem, valueItem));
            if (itemIndex === -1) {
                changeHighlightedIndex({
                    diff: "reset",
                });
            } else {
                setHighlightedIndex({
                    index: itemIndex,
                });
            }
            return;
        }
        if (highlightedIndexRef.current >= filteredOptions.length - 1) {
            setHighlightedIndex({
                index: filteredOptions.length - 1,
            });
            return;
        }
        setHighlightedIndex({
            index: highlightedIndexRef.current,
        });
    }, [
        // Only sync the highlighted index when the option switch between empty and not
        filteredOptions.length,
        // Don't sync the highlighted index with the value when multiple
        // eslint-disable-next-line react-hooks/exhaustive-deps
        multiple ? false : value,
        filterSelectedOptions,
        changeHighlightedIndex,
        setHighlightedIndex,
        popupOpen,
        inputValue,
        multiple,
    ]);
    const handleListboxRef = useEventCallback((node2) => {
        setRef(listboxRef, node2);
        if (!node2) {
            return;
        }
        syncHighlightedIndex();
    });
    reactExports.useEffect(() => {
        syncHighlightedIndex();
    }, [syncHighlightedIndex]);
    const handleOpen = (event) => {
        if (open2) {
            return;
        }
        setOpenState(true);
        setInputPristine(true);
        if (onOpen) {
            onOpen(event);
        }
    };
    const handleClose = (event, reason) => {
        if (!open2) {
            return;
        }
        setOpenState(false);
        if (onClose) {
            onClose(event, reason);
        }
    };
    const handleValue = (event, newValue, reason, details) => {
        if (multiple) {
            if (value.length === newValue.length && value.every((val, i) => val === newValue[i])) {
                return;
            }
        } else if (value === newValue) {
            return;
        }
        if (onChange) {
            onChange(event, newValue, reason, details);
        }
        setValueState(newValue);
    };
    const isTouch = reactExports.useRef(false);
    const selectNewValue = (event, option, reasonProp = "selectOption", origin = "options") => {
        let reason = reasonProp;
        let newValue = option;
        if (multiple) {
            newValue = Array.isArray(value) ? value.slice() : [];
            const itemIndex = findIndex$1(newValue, (valueItem) => isOptionEqualToValue(option, valueItem));
            if (itemIndex === -1) {
                newValue.push(option);
            } else if (origin !== "freeSolo") {
                newValue.splice(itemIndex, 1);
                reason = "removeOption";
            }
        }
        resetInputValue(event, newValue);
        handleValue(event, newValue, reason, {
            option,
        });
        if (!disableCloseOnSelect && (!event || (!event.ctrlKey && !event.metaKey))) {
            handleClose(event, reason);
        }
        if (blurOnSelect === true || (blurOnSelect === "touch" && isTouch.current) || (blurOnSelect === "mouse" && !isTouch.current)) {
            inputRef.current.blur();
        }
    };
    function validTagIndex(index, direction) {
        if (index === -1) {
            return -1;
        }
        let nextFocus = index;
        while (true) {
            if ((direction === "next" && nextFocus === value.length) || (direction === "previous" && nextFocus === -1)) {
                return -1;
            }
            const option = anchorEl.querySelector(`[data-tag-index="${nextFocus}"]`);
            if (!option || !option.hasAttribute("tabindex") || option.disabled || option.getAttribute("aria-disabled") === "true") {
                nextFocus += direction === "next" ? 1 : -1;
            } else {
                return nextFocus;
            }
        }
    }
    const handleFocusTag = (event, direction) => {
        if (!multiple) {
            return;
        }
        if (inputValue === "") {
            handleClose(event, "toggleInput");
        }
        let nextTag = focusedTag;
        if (focusedTag === -1) {
            if (inputValue === "" && direction === "previous") {
                nextTag = value.length - 1;
            }
        } else {
            nextTag += direction === "next" ? 1 : -1;
            if (nextTag < 0) {
                nextTag = 0;
            }
            if (nextTag === value.length) {
                nextTag = -1;
            }
        }
        nextTag = validTagIndex(nextTag, direction);
        setFocusedTag(nextTag);
        focusTag(nextTag);
    };
    const handleClear = (event) => {
        ignoreFocus.current = true;
        setInputValueState("");
        if (onInputChange) {
            onInputChange(event, "", "clear");
        }
        handleValue(event, multiple ? [] : null, "clear");
    };
    const handleKeyDown2 = (other) => (event) => {
        if (other.onKeyDown) {
            other.onKeyDown(event);
        }
        if (event.defaultMuiPrevented) {
            return;
        }
        if (focusedTag !== -1 && ["ArrowLeft", "ArrowRight"].indexOf(event.key) === -1) {
            setFocusedTag(-1);
            focusTag(-1);
        }
        if (event.which !== 229) {
            switch (event.key) {
                case "Home":
                    if (popupOpen && handleHomeEndKeys) {
                        event.preventDefault();
                        changeHighlightedIndex({
                            diff: "start",
                            direction: "next",
                            reason: "keyboard",
                            event,
                        });
                    }
                    break;
                case "End":
                    if (popupOpen && handleHomeEndKeys) {
                        event.preventDefault();
                        changeHighlightedIndex({
                            diff: "end",
                            direction: "previous",
                            reason: "keyboard",
                            event,
                        });
                    }
                    break;
                case "PageUp":
                    event.preventDefault();
                    changeHighlightedIndex({
                        diff: -pageSize,
                        direction: "previous",
                        reason: "keyboard",
                        event,
                    });
                    handleOpen(event);
                    break;
                case "PageDown":
                    event.preventDefault();
                    changeHighlightedIndex({
                        diff: pageSize,
                        direction: "next",
                        reason: "keyboard",
                        event,
                    });
                    handleOpen(event);
                    break;
                case "ArrowDown":
                    event.preventDefault();
                    changeHighlightedIndex({
                        diff: 1,
                        direction: "next",
                        reason: "keyboard",
                        event,
                    });
                    handleOpen(event);
                    break;
                case "ArrowUp":
                    event.preventDefault();
                    changeHighlightedIndex({
                        diff: -1,
                        direction: "previous",
                        reason: "keyboard",
                        event,
                    });
                    handleOpen(event);
                    break;
                case "ArrowLeft":
                    handleFocusTag(event, "previous");
                    break;
                case "ArrowRight":
                    handleFocusTag(event, "next");
                    break;
                case "Enter":
                    if (highlightedIndexRef.current !== -1 && popupOpen) {
                        const option = filteredOptions[highlightedIndexRef.current];
                        const disabled = getOptionDisabled ? getOptionDisabled(option) : false;
                        event.preventDefault();
                        if (disabled) {
                            return;
                        }
                        selectNewValue(event, option, "selectOption");
                        if (autoComplete) {
                            inputRef.current.setSelectionRange(inputRef.current.value.length, inputRef.current.value.length);
                        }
                    } else if (freeSolo && inputValue !== "" && inputValueIsSelectedValue === false) {
                        if (multiple) {
                            event.preventDefault();
                        }
                        selectNewValue(event, inputValue, "createOption", "freeSolo");
                    }
                    break;
                case "Escape":
                    if (popupOpen) {
                        event.preventDefault();
                        event.stopPropagation();
                        handleClose(event, "escape");
                    } else if (clearOnEscape && (inputValue !== "" || (multiple && value.length > 0))) {
                        event.preventDefault();
                        event.stopPropagation();
                        handleClear(event);
                    }
                    break;
                case "Backspace":
                    if (multiple && !readOnly && inputValue === "" && value.length > 0) {
                        const index = focusedTag === -1 ? value.length - 1 : focusedTag;
                        const newValue = value.slice();
                        newValue.splice(index, 1);
                        handleValue(event, newValue, "removeOption", {
                            option: value[index],
                        });
                    }
                    break;
                case "Delete":
                    if (multiple && !readOnly && inputValue === "" && value.length > 0 && focusedTag !== -1) {
                        const index = focusedTag;
                        const newValue = value.slice();
                        newValue.splice(index, 1);
                        handleValue(event, newValue, "removeOption", {
                            option: value[index],
                        });
                    }
                    break;
            }
        }
    };
    const handleFocus = (event) => {
        setFocused(true);
        if (openOnFocus && !ignoreFocus.current) {
            handleOpen(event);
        }
    };
    const handleBlur = (event) => {
        if (unstable_isActiveElementInListbox(listboxRef)) {
            inputRef.current.focus();
            return;
        }
        setFocused(false);
        firstFocus.current = true;
        ignoreFocus.current = false;
        if (autoSelect && highlightedIndexRef.current !== -1 && popupOpen) {
            selectNewValue(event, filteredOptions[highlightedIndexRef.current], "blur");
        } else if (autoSelect && freeSolo && inputValue !== "") {
            selectNewValue(event, inputValue, "blur", "freeSolo");
        } else if (clearOnBlur) {
            resetInputValue(event, value);
        }
        handleClose(event, "blur");
    };
    const handleInputChange = (event) => {
        const newValue = event.target.value;
        if (inputValue !== newValue) {
            setInputValueState(newValue);
            setInputPristine(false);
            if (onInputChange) {
                onInputChange(event, newValue, "input");
            }
        }
        if (newValue === "") {
            if (!disableClearable && !multiple) {
                handleValue(event, null, "clear");
            }
        } else {
            handleOpen(event);
        }
    };
    const handleOptionMouseMove = (event) => {
        const index = Number(event.currentTarget.getAttribute("data-option-index"));
        if (highlightedIndexRef.current !== index) {
            setHighlightedIndex({
                event,
                index,
                reason: "mouse",
            });
        }
    };
    const handleOptionTouchStart = (event) => {
        setHighlightedIndex({
            event,
            index: Number(event.currentTarget.getAttribute("data-option-index")),
            reason: "touch",
        });
        isTouch.current = true;
    };
    const handleOptionClick = (event) => {
        const index = Number(event.currentTarget.getAttribute("data-option-index"));
        selectNewValue(event, filteredOptions[index], "selectOption");
        isTouch.current = false;
    };
    const handleTagDelete = (index) => (event) => {
        const newValue = value.slice();
        newValue.splice(index, 1);
        handleValue(event, newValue, "removeOption", {
            option: value[index],
        });
    };
    const handlePopupIndicator = (event) => {
        if (open2) {
            handleClose(event, "toggleInput");
        } else {
            handleOpen(event);
        }
    };
    const handleMouseDown = (event) => {
        if (event.target.getAttribute("id") !== id) {
            event.preventDefault();
        }
    };
    const handleClick = () => {
        inputRef.current.focus();
        if (selectOnFocus && firstFocus.current && inputRef.current.selectionEnd - inputRef.current.selectionStart === 0) {
            inputRef.current.select();
        }
        firstFocus.current = false;
    };
    const handleInputMouseDown = (event) => {
        if (inputValue === "" || !open2) {
            handlePopupIndicator(event);
        }
    };
    let dirty = freeSolo && inputValue.length > 0;
    dirty = dirty || (multiple ? value.length > 0 : value !== null);
    let groupedOptions = filteredOptions;
    if (groupBy) {
        groupedOptions = filteredOptions.reduce((acc, option, index) => {
            const group = groupBy(option);
            if (acc.length > 0 && acc[acc.length - 1].group === group) {
                acc[acc.length - 1].options.push(option);
            } else {
                acc.push({
                    key: index,
                    index,
                    group,
                    options: [option],
                });
            }
            return acc;
        }, []);
    }
    if (disabledProp && focused) {
        handleBlur();
    }
    return {
        getRootProps: (other = {}) =>
            _extends(
                {
                    "aria-owns": listboxAvailable ? `${id}-listbox` : null,
                },
                other,
                {
                    onKeyDown: handleKeyDown2(other),
                    onMouseDown: handleMouseDown,
                    onClick: handleClick,
                }
            ),
        getInputLabelProps: () => ({
            id: `${id}-label`,
            htmlFor: id,
        }),
        getInputProps: () => ({
            id,
            value: inputValue,
            onBlur: handleBlur,
            onFocus: handleFocus,
            onChange: handleInputChange,
            onMouseDown: handleInputMouseDown,
            // if open then this is handled imperatively so don't let react override
            // only have an opinion about this when closed
            "aria-activedescendant": popupOpen ? "" : null,
            "aria-autocomplete": autoComplete ? "both" : "list",
            "aria-controls": listboxAvailable ? `${id}-listbox` : void 0,
            "aria-expanded": listboxAvailable,
            // Disable browser's suggestion that might overlap with the popup.
            // Handle autocomplete but not autofill.
            autoComplete: "off",
            ref: inputRef,
            autoCapitalize: "none",
            spellCheck: "false",
            role: "combobox",
            disabled: disabledProp,
        }),
        getClearProps: () => ({
            tabIndex: -1,
            onClick: handleClear,
        }),
        getPopupIndicatorProps: () => ({
            tabIndex: -1,
            onClick: handlePopupIndicator,
        }),
        getTagProps: ({ index }) =>
            _extends(
                {
                    key: index,
                    "data-tag-index": index,
                    tabIndex: -1,
                },
                !readOnly && {
                    onDelete: handleTagDelete(index),
                }
            ),
        getListboxProps: () => ({
            role: "listbox",
            id: `${id}-listbox`,
            "aria-labelledby": `${id}-label`,
            ref: handleListboxRef,
            onMouseDown: (event) => {
                event.preventDefault();
            },
        }),
        getOptionProps: ({ index, option }) => {
            const selected = (multiple ? value : [value]).some((value2) => value2 != null && isOptionEqualToValue(option, value2));
            const disabled = getOptionDisabled ? getOptionDisabled(option) : false;
            return {
                key: getOptionLabel(option),
                tabIndex: -1,
                role: "option",
                id: `${id}-option-${index}`,
                onMouseMove: handleOptionMouseMove,
                onClick: handleOptionClick,
                onTouchStart: handleOptionTouchStart,
                "data-option-index": index,
                "aria-disabled": disabled,
                "aria-selected": selected,
            };
        },
        id,
        inputValue,
        value,
        dirty,
        expanded: popupOpen && anchorEl,
        popupOpen,
        focused: focused || focusedTag !== -1,
        anchorEl,
        setAnchorEl,
        focusedTag,
        groupedOptions,
    };
}
function getSvgIconUtilityClass(slot) {
    return generateUtilityClass("MuiSvgIcon", slot);
}
generateUtilityClasses("MuiSvgIcon", ["root", "colorPrimary", "colorSecondary", "colorAction", "colorError", "colorDisabled", "fontSizeInherit", "fontSizeSmall", "fontSizeMedium", "fontSizeLarge"]);
const _excluded$U = ["children", "className", "color", "component", "fontSize", "htmlColor", "inheritViewBox", "titleAccess", "viewBox"];
const useUtilityClasses$K = (ownerState) => {
    const { color: color2, fontSize, classes } = ownerState;
    const slots = {
        root: ["root", color2 !== "inherit" && `color${capitalize(color2)}`, `fontSize${capitalize(fontSize)}`],
    };
    return composeClasses(slots, getSvgIconUtilityClass, classes);
};
const SvgIconRoot = styled$1("svg", {
    name: "MuiSvgIcon",
    slot: "Root",
    overridesResolver: (props, styles2) => {
        const { ownerState } = props;
        return [styles2.root, ownerState.color !== "inherit" && styles2[`color${capitalize(ownerState.color)}`], styles2[`fontSize${capitalize(ownerState.fontSize)}`]];
    },
})(({ theme, ownerState }) => {
    var _theme$transitions,
        _theme$transitions$cr,
        _theme$transitions2,
        _theme$transitions2$d,
        _theme$typography,
        _theme$typography$pxT,
        _theme$typography2,
        _theme$typography2$px,
        _theme$typography3,
        _theme$typography3$px,
        _palette$ownerState$c,
        _palette,
        _palette$ownerState$c2,
        _palette2,
        _palette2$action,
        _palette3,
        _palette3$action;
    return {
        userSelect: "none",
        width: "1em",
        height: "1em",
        display: "inline-block",
        fill: "currentColor",
        flexShrink: 0,
        transition:
            (_theme$transitions = theme.transitions) == null
                ? void 0
                : (_theme$transitions$cr = _theme$transitions.create) == null
                ? void 0
                : _theme$transitions$cr.call(_theme$transitions, "fill", {
                      duration: (_theme$transitions2 = theme.transitions) == null ? void 0 : (_theme$transitions2$d = _theme$transitions2.duration) == null ? void 0 : _theme$transitions2$d.shorter,
                  }),
        fontSize: {
            inherit: "inherit",
            small:
                ((_theme$typography = theme.typography) == null ? void 0 : (_theme$typography$pxT = _theme$typography.pxToRem) == null ? void 0 : _theme$typography$pxT.call(_theme$typography, 20)) ||
                "1.25rem",
            medium:
                ((_theme$typography2 = theme.typography) == null
                    ? void 0
                    : (_theme$typography2$px = _theme$typography2.pxToRem) == null
                    ? void 0
                    : _theme$typography2$px.call(_theme$typography2, 24)) || "1.5rem",
            large:
                ((_theme$typography3 = theme.typography) == null
                    ? void 0
                    : (_theme$typography3$px = _theme$typography3.pxToRem) == null
                    ? void 0
                    : _theme$typography3$px.call(_theme$typography3, 35)) || "2.1875rem",
        }[ownerState.fontSize],
        // TODO v5 deprecate, v6 remove for sx
        color:
            (_palette$ownerState$c =
                (_palette = (theme.vars || theme).palette) == null ? void 0 : (_palette$ownerState$c2 = _palette[ownerState.color]) == null ? void 0 : _palette$ownerState$c2.main) != null
                ? _palette$ownerState$c
                : {
                      action: (_palette2 = (theme.vars || theme).palette) == null ? void 0 : (_palette2$action = _palette2.action) == null ? void 0 : _palette2$action.active,
                      disabled: (_palette3 = (theme.vars || theme).palette) == null ? void 0 : (_palette3$action = _palette3.action) == null ? void 0 : _palette3$action.disabled,
                      inherit: void 0,
                  }[ownerState.color],
    };
});
const SvgIcon = /* @__PURE__ */ reactExports.forwardRef(function SvgIcon2(inProps, ref) {
    const props = useThemeProps({
        props: inProps,
        name: "MuiSvgIcon",
    });
    const { children, className, color: color2 = "inherit", component = "svg", fontSize = "medium", htmlColor, inheritViewBox = false, titleAccess, viewBox = "0 0 24 24" } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded$U);
    const ownerState = _extends({}, props, {
        color: color2,
        component,
        fontSize,
        instanceFontSize: inProps.fontSize,
        inheritViewBox,
        viewBox,
    });
    const more = {};
    if (!inheritViewBox) {
        more.viewBox = viewBox;
    }
    const classes = useUtilityClasses$K(ownerState);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        SvgIconRoot,
        _extends(
            {
                as: component,
                className: clsx$1(classes.root, className),
                focusable: "false",
                color: htmlColor,
                "aria-hidden": titleAccess ? void 0 : true,
                role: titleAccess ? "img" : void 0,
                ref,
            },
            more,
            other,
            {
                ownerState,
                children: [
                    children,
                    titleAccess
                        ? /* @__PURE__ */ jsxRuntimeExports.jsx("title", {
                              children: titleAccess,
                          })
                        : null,
                ],
            }
        )
    );
});
SvgIcon.muiName = "SvgIcon";
const SvgIcon$1 = SvgIcon;
function createSvgIcon$1(path, displayName) {
    function Component(props, ref) {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
            SvgIcon$1,
            _extends(
                {
                    "data-testid": `${displayName}Icon`,
                    ref,
                },
                props,
                {
                    children: path,
                }
            )
        );
    }
    Component.muiName = SvgIcon$1.muiName;
    return /* @__PURE__ */ reactExports.memo(/* @__PURE__ */ reactExports.forwardRef(Component));
}
const unstable_ClassNameGenerator = {
    configure: (generator) => {
        ClassNameGenerator$1.configure(generator);
    },
};
const utils = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
        {
            __proto__: null,
            capitalize,
            createChainedFunction,
            createSvgIcon: createSvgIcon$1,
            debounce: debounce$1,
            deprecatedPropType,
            isMuiElement,
            ownerDocument,
            ownerWindow,
            requirePropFactory,
            setRef,
            unstable_ClassNameGenerator,
            unstable_useEnhancedEffect: useEnhancedEffect$1,
            unstable_useId: useId,
            unsupportedProp,
            useControlled,
            useEventCallback,
            useForkRef,
            useIsFocusVisible,
        },
        Symbol.toStringTag,
        { value: "Module" }
    )
);
function _assertThisInitialized(self2) {
    if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
}
function getChildMapping(children, mapFn) {
    var mapper = function mapper2(child) {
        return mapFn && reactExports.isValidElement(child) ? mapFn(child) : child;
    };
    var result = /* @__PURE__ */ Object.create(null);
    if (children)
        reactExports.Children.map(children, function (c2) {
            return c2;
        }).forEach(function (child) {
            result[child.key] = mapper(child);
        });
    return result;
}
function mergeChildMappings(prev2, next2) {
    prev2 = prev2 || {};
    next2 = next2 || {};
    function getValueForKey(key) {
        return key in next2 ? next2[key] : prev2[key];
    }
    var nextKeysPending = /* @__PURE__ */ Object.create(null);
    var pendingKeys = [];
    for (var prevKey in prev2) {
        if (prevKey in next2) {
            if (pendingKeys.length) {
                nextKeysPending[prevKey] = pendingKeys;
                pendingKeys = [];
            }
        } else {
            pendingKeys.push(prevKey);
        }
    }
    var i;
    var childMapping = {};
    for (var nextKey in next2) {
        if (nextKeysPending[nextKey]) {
            for (i = 0; i < nextKeysPending[nextKey].length; i++) {
                var pendingNextKey = nextKeysPending[nextKey][i];
                childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);
            }
        }
        childMapping[nextKey] = getValueForKey(nextKey);
    }
    for (i = 0; i < pendingKeys.length; i++) {
        childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);
    }
    return childMapping;
}
function getProp(child, prop, props) {
    return props[prop] != null ? props[prop] : child.props[prop];
}
function getInitialChildMapping(props, onExited) {
    return getChildMapping(props.children, function (child) {
        return reactExports.cloneElement(child, {
            onExited: onExited.bind(null, child),
            in: true,
            appear: getProp(child, "appear", props),
            enter: getProp(child, "enter", props),
            exit: getProp(child, "exit", props),
        });
    });
}
function getNextChildMapping(nextProps, prevChildMapping, onExited) {
    var nextChildMapping = getChildMapping(nextProps.children);
    var children = mergeChildMappings(prevChildMapping, nextChildMapping);
    Object.keys(children).forEach(function (key) {
        var child = children[key];
        if (!reactExports.isValidElement(child)) return;
        var hasPrev = key in prevChildMapping;
        var hasNext = key in nextChildMapping;
        var prevChild = prevChildMapping[key];
        var isLeaving = reactExports.isValidElement(prevChild) && !prevChild.props.in;
        if (hasNext && (!hasPrev || isLeaving)) {
            children[key] = reactExports.cloneElement(child, {
                onExited: onExited.bind(null, child),
                in: true,
                exit: getProp(child, "exit", nextProps),
                enter: getProp(child, "enter", nextProps),
            });
        } else if (!hasNext && hasPrev && !isLeaving) {
            children[key] = reactExports.cloneElement(child, {
                in: false,
            });
        } else if (hasNext && hasPrev && reactExports.isValidElement(prevChild)) {
            children[key] = reactExports.cloneElement(child, {
                onExited: onExited.bind(null, child),
                in: prevChild.props.in,
                exit: getProp(child, "exit", nextProps),
                enter: getProp(child, "enter", nextProps),
            });
        }
    });
    return children;
}
var values =
    Object.values ||
    function (obj) {
        return Object.keys(obj).map(function (k2) {
            return obj[k2];
        });
    };
var defaultProps = {
    component: "div",
    childFactory: function childFactory(child) {
        return child;
    },
};
var TransitionGroup = /* @__PURE__ */ (function (_React$Component) {
    _inheritsLoose(TransitionGroup2, _React$Component);
    function TransitionGroup2(props, context) {
        var _this;
        _this = _React$Component.call(this, props, context) || this;
        var handleExited = _this.handleExited.bind(_assertThisInitialized(_this));
        _this.state = {
            contextValue: {
                isMounting: true,
            },
            handleExited,
            firstRender: true,
        };
        return _this;
    }
    var _proto = TransitionGroup2.prototype;
    _proto.componentDidMount = function componentDidMount() {
        this.mounted = true;
        this.setState({
            contextValue: {
                isMounting: false,
            },
        });
    };
    _proto.componentWillUnmount = function componentWillUnmount() {
        this.mounted = false;
    };
    TransitionGroup2.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, _ref) {
        var prevChildMapping = _ref.children,
            handleExited = _ref.handleExited,
            firstRender = _ref.firstRender;
        return {
            children: firstRender ? getInitialChildMapping(nextProps, handleExited) : getNextChildMapping(nextProps, prevChildMapping, handleExited),
            firstRender: false,
        };
    };
    _proto.handleExited = function handleExited(child, node2) {
        var currentChildMapping = getChildMapping(this.props.children);
        if (child.key in currentChildMapping) return;
        if (child.props.onExited) {
            child.props.onExited(node2);
        }
        if (this.mounted) {
            this.setState(function (state) {
                var children = _extends({}, state.children);
                delete children[child.key];
                return {
                    children,
                };
            });
        }
    };
    _proto.render = function render() {
        var _this$props = this.props,
            Component = _this$props.component,
            childFactory2 = _this$props.childFactory,
            props = _objectWithoutPropertiesLoose(_this$props, ["component", "childFactory"]);
        var contextValue = this.state.contextValue;
        var children = values(this.state.children).map(childFactory2);
        delete props.appear;
        delete props.enter;
        delete props.exit;
        if (Component === null) {
            return /* @__PURE__ */ React$1.createElement(
                TransitionGroupContext.Provider,
                {
                    value: contextValue,
                },
                children
            );
        }
        return /* @__PURE__ */ React$1.createElement(
            TransitionGroupContext.Provider,
            {
                value: contextValue,
            },
            /* @__PURE__ */ React$1.createElement(Component, props, children)
        );
    };
    return TransitionGroup2;
})(React$1.Component);
TransitionGroup.propTypes = {};
TransitionGroup.defaultProps = defaultProps;
const TransitionGroup$1 = TransitionGroup;
const reflow = (node2) => node2.scrollTop;
function getTransitionProps(props, options) {
    var _style$transitionDura, _style$transitionTimi;
    const { timeout, easing: easing2, style: style2 = {} } = props;
    return {
        duration: (_style$transitionDura = style2.transitionDuration) != null ? _style$transitionDura : typeof timeout === "number" ? timeout : timeout[options.mode] || 0,
        easing: (_style$transitionTimi = style2.transitionTimingFunction) != null ? _style$transitionTimi : typeof easing2 === "object" ? easing2[options.mode] : easing2,
        delay: style2.transitionDelay,
    };
}
function getCollapseUtilityClass(slot) {
    return generateUtilityClass("MuiCollapse", slot);
}
generateUtilityClasses("MuiCollapse", ["root", "horizontal", "vertical", "entered", "hidden", "wrapper", "wrapperInner"]);
const _excluded$T = [
    "addEndListener",
    "children",
    "className",
    "collapsedSize",
    "component",
    "easing",
    "in",
    "onEnter",
    "onEntered",
    "onEntering",
    "onExit",
    "onExited",
    "onExiting",
    "orientation",
    "style",
    "timeout",
    "TransitionComponent",
];
const useUtilityClasses$J = (ownerState) => {
    const { orientation, classes } = ownerState;
    const slots = {
        root: ["root", `${orientation}`],
        entered: ["entered"],
        hidden: ["hidden"],
        wrapper: ["wrapper", `${orientation}`],
        wrapperInner: ["wrapperInner", `${orientation}`],
    };
    return composeClasses(slots, getCollapseUtilityClass, classes);
};
const CollapseRoot = styled$1("div", {
    name: "MuiCollapse",
    slot: "Root",
    overridesResolver: (props, styles2) => {
        const { ownerState } = props;
        return [
            styles2.root,
            styles2[ownerState.orientation],
            ownerState.state === "entered" && styles2.entered,
            ownerState.state === "exited" && !ownerState.in && ownerState.collapsedSize === "0px" && styles2.hidden,
        ];
    },
})(({ theme, ownerState }) =>
    _extends(
        {
            height: 0,
            overflow: "hidden",
            transition: theme.transitions.create("height"),
        },
        ownerState.orientation === "horizontal" && {
            height: "auto",
            width: 0,
            transition: theme.transitions.create("width"),
        },
        ownerState.state === "entered" &&
            _extends(
                {
                    height: "auto",
                    overflow: "visible",
                },
                ownerState.orientation === "horizontal" && {
                    width: "auto",
                }
            ),
        ownerState.state === "exited" &&
            !ownerState.in &&
            ownerState.collapsedSize === "0px" && {
                visibility: "hidden",
            }
    )
);
const CollapseWrapper = styled$1("div", {
    name: "MuiCollapse",
    slot: "Wrapper",
    overridesResolver: (props, styles2) => styles2.wrapper,
})(({ ownerState }) =>
    _extends(
        {
            // Hack to get children with a negative margin to not falsify the height computation.
            display: "flex",
            width: "100%",
        },
        ownerState.orientation === "horizontal" && {
            width: "auto",
            height: "100%",
        }
    )
);
const CollapseWrapperInner = styled$1("div", {
    name: "MuiCollapse",
    slot: "WrapperInner",
    overridesResolver: (props, styles2) => styles2.wrapperInner,
})(({ ownerState }) =>
    _extends(
        {
            width: "100%",
        },
        ownerState.orientation === "horizontal" && {
            width: "auto",
            height: "100%",
        }
    )
);
const Collapse = /* @__PURE__ */ reactExports.forwardRef(function Collapse2(inProps, ref) {
    const props = useThemeProps({
        props: inProps,
        name: "MuiCollapse",
    });
    const {
            addEndListener,
            children,
            className,
            collapsedSize: collapsedSizeProp = "0px",
            component,
            easing: easing2,
            in: inProp,
            onEnter,
            onEntered,
            onEntering,
            onExit,
            onExited,
            onExiting,
            orientation = "vertical",
            style: style2,
            timeout = duration.standard,
            // eslint-disable-next-line react/prop-types
            TransitionComponent = Transition,
        } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded$T);
    const ownerState = _extends({}, props, {
        orientation,
        collapsedSize: collapsedSizeProp,
    });
    const classes = useUtilityClasses$J(ownerState);
    const theme = useTheme();
    const timer = reactExports.useRef();
    const wrapperRef = reactExports.useRef(null);
    const autoTransitionDuration = reactExports.useRef();
    const collapsedSize = typeof collapsedSizeProp === "number" ? `${collapsedSizeProp}px` : collapsedSizeProp;
    const isHorizontal = orientation === "horizontal";
    const size = isHorizontal ? "width" : "height";
    reactExports.useEffect(() => {
        return () => {
            clearTimeout(timer.current);
        };
    }, []);
    const nodeRef = reactExports.useRef(null);
    const handleRef = useForkRef(ref, nodeRef);
    const normalizedTransitionCallback = (callback) => (maybeIsAppearing) => {
        if (callback) {
            const node2 = nodeRef.current;
            if (maybeIsAppearing === void 0) {
                callback(node2);
            } else {
                callback(node2, maybeIsAppearing);
            }
        }
    };
    const getWrapperSize = () => (wrapperRef.current ? wrapperRef.current[isHorizontal ? "clientWidth" : "clientHeight"] : 0);
    const handleEnter = normalizedTransitionCallback((node2, isAppearing) => {
        if (wrapperRef.current && isHorizontal) {
            wrapperRef.current.style.position = "absolute";
        }
        node2.style[size] = collapsedSize;
        if (onEnter) {
            onEnter(node2, isAppearing);
        }
    });
    const handleEntering = normalizedTransitionCallback((node2, isAppearing) => {
        const wrapperSize = getWrapperSize();
        if (wrapperRef.current && isHorizontal) {
            wrapperRef.current.style.position = "";
        }
        const { duration: transitionDuration, easing: transitionTimingFunction } = getTransitionProps(
            {
                style: style2,
                timeout,
                easing: easing2,
            },
            {
                mode: "enter",
            }
        );
        if (timeout === "auto") {
            const duration2 = theme.transitions.getAutoHeightDuration(wrapperSize);
            node2.style.transitionDuration = `${duration2}ms`;
            autoTransitionDuration.current = duration2;
        } else {
            node2.style.transitionDuration = typeof transitionDuration === "string" ? transitionDuration : `${transitionDuration}ms`;
        }
        node2.style[size] = `${wrapperSize}px`;
        node2.style.transitionTimingFunction = transitionTimingFunction;
        if (onEntering) {
            onEntering(node2, isAppearing);
        }
    });
    const handleEntered = normalizedTransitionCallback((node2, isAppearing) => {
        node2.style[size] = "auto";
        if (onEntered) {
            onEntered(node2, isAppearing);
        }
    });
    const handleExit = normalizedTransitionCallback((node2) => {
        node2.style[size] = `${getWrapperSize()}px`;
        if (onExit) {
            onExit(node2);
        }
    });
    const handleExited = normalizedTransitionCallback(onExited);
    const handleExiting = normalizedTransitionCallback((node2) => {
        const wrapperSize = getWrapperSize();
        const { duration: transitionDuration, easing: transitionTimingFunction } = getTransitionProps(
            {
                style: style2,
                timeout,
                easing: easing2,
            },
            {
                mode: "exit",
            }
        );
        if (timeout === "auto") {
            const duration2 = theme.transitions.getAutoHeightDuration(wrapperSize);
            node2.style.transitionDuration = `${duration2}ms`;
            autoTransitionDuration.current = duration2;
        } else {
            node2.style.transitionDuration = typeof transitionDuration === "string" ? transitionDuration : `${transitionDuration}ms`;
        }
        node2.style[size] = collapsedSize;
        node2.style.transitionTimingFunction = transitionTimingFunction;
        if (onExiting) {
            onExiting(node2);
        }
    });
    const handleAddEndListener = (next2) => {
        if (timeout === "auto") {
            timer.current = setTimeout(next2, autoTransitionDuration.current || 0);
        }
        if (addEndListener) {
            addEndListener(nodeRef.current, next2);
        }
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
        TransitionComponent,
        _extends(
            {
                in: inProp,
                onEnter: handleEnter,
                onEntered: handleEntered,
                onEntering: handleEntering,
                onExit: handleExit,
                onExited: handleExited,
                onExiting: handleExiting,
                addEndListener: handleAddEndListener,
                nodeRef,
                timeout: timeout === "auto" ? null : timeout,
            },
            other,
            {
                children: (state, childProps) =>
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                        CollapseRoot,
                        _extends(
                            {
                                as: component,
                                className: clsx$1(
                                    classes.root,
                                    className,
                                    {
                                        entered: classes.entered,
                                        exited: !inProp && collapsedSize === "0px" && classes.hidden,
                                    }[state]
                                ),
                                style: _extends(
                                    {
                                        [isHorizontal ? "minWidth" : "minHeight"]: collapsedSize,
                                    },
                                    style2
                                ),
                                ownerState: _extends({}, ownerState, {
                                    state,
                                }),
                                ref: handleRef,
                            },
                            childProps,
                            {
                                children: /* @__PURE__ */ jsxRuntimeExports.jsx(CollapseWrapper, {
                                    ownerState: _extends({}, ownerState, {
                                        state,
                                    }),
                                    className: classes.wrapper,
                                    ref: wrapperRef,
                                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(CollapseWrapperInner, {
                                        ownerState: _extends({}, ownerState, {
                                            state,
                                        }),
                                        className: classes.wrapperInner,
                                        children,
                                    }),
                                }),
                            }
                        )
                    ),
            }
        )
    );
});
Collapse.muiSupportAuto = true;
const Collapse$1 = Collapse;
function getPaperUtilityClass(slot) {
    return generateUtilityClass("MuiPaper", slot);
}
generateUtilityClasses("MuiPaper", [
    "root",
    "rounded",
    "outlined",
    "elevation",
    "elevation0",
    "elevation1",
    "elevation2",
    "elevation3",
    "elevation4",
    "elevation5",
    "elevation6",
    "elevation7",
    "elevation8",
    "elevation9",
    "elevation10",
    "elevation11",
    "elevation12",
    "elevation13",
    "elevation14",
    "elevation15",
    "elevation16",
    "elevation17",
    "elevation18",
    "elevation19",
    "elevation20",
    "elevation21",
    "elevation22",
    "elevation23",
    "elevation24",
]);
const _excluded$S = ["className", "component", "elevation", "square", "variant"];
const useUtilityClasses$I = (ownerState) => {
    const { square, elevation, variant, classes } = ownerState;
    const slots = {
        root: ["root", variant, !square && "rounded", variant === "elevation" && `elevation${elevation}`],
    };
    return composeClasses(slots, getPaperUtilityClass, classes);
};
const PaperRoot = styled$1("div", {
    name: "MuiPaper",
    slot: "Root",
    overridesResolver: (props, styles2) => {
        const { ownerState } = props;
        return [styles2.root, styles2[ownerState.variant], !ownerState.square && styles2.rounded, ownerState.variant === "elevation" && styles2[`elevation${ownerState.elevation}`]];
    },
})(({ theme, ownerState }) => {
    var _theme$vars$overlays;
    return _extends(
        {
            backgroundColor: (theme.vars || theme).palette.background.paper,
            color: (theme.vars || theme).palette.text.primary,
            transition: theme.transitions.create("box-shadow"),
        },
        !ownerState.square && {
            borderRadius: theme.shape.borderRadius,
        },
        ownerState.variant === "outlined" && {
            border: `1px solid ${(theme.vars || theme).palette.divider}`,
        },
        ownerState.variant === "elevation" &&
            _extends(
                {
                    boxShadow: (theme.vars || theme).shadows[ownerState.elevation],
                },
                !theme.vars &&
                    theme.palette.mode === "dark" && {
                        backgroundImage: `linear-gradient(${alpha("#fff", getOverlayAlpha$1(ownerState.elevation))}, ${alpha("#fff", getOverlayAlpha$1(ownerState.elevation))})`,
                    },
                theme.vars && {
                    backgroundImage: (_theme$vars$overlays = theme.vars.overlays) == null ? void 0 : _theme$vars$overlays[ownerState.elevation],
                }
            )
    );
});
const Paper = /* @__PURE__ */ reactExports.forwardRef(function Paper2(inProps, ref) {
    const props = useThemeProps({
        props: inProps,
        name: "MuiPaper",
    });
    const { className, component = "div", elevation = 1, square = false, variant = "elevation" } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded$S);
    const ownerState = _extends({}, props, {
        component,
        elevation,
        square,
        variant,
    });
    const classes = useUtilityClasses$I(ownerState);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
        PaperRoot,
        _extends(
            {
                as: component,
                ownerState,
                className: clsx$1(classes.root, className),
                ref,
            },
            other
        )
    );
});
const Paper$1 = Paper;
function Ripple(props) {
    const { className, classes, pulsate = false, rippleX, rippleY, rippleSize, in: inProp, onExited, timeout } = props;
    const [leaving, setLeaving] = reactExports.useState(false);
    const rippleClassName = clsx$1(className, classes.ripple, classes.rippleVisible, pulsate && classes.ripplePulsate);
    const rippleStyles = {
        width: rippleSize,
        height: rippleSize,
        top: -(rippleSize / 2) + rippleY,
        left: -(rippleSize / 2) + rippleX,
    };
    const childClassName = clsx$1(classes.child, leaving && classes.childLeaving, pulsate && classes.childPulsate);
    if (!inProp && !leaving) {
        setLeaving(true);
    }
    reactExports.useEffect(() => {
        if (!inProp && onExited != null) {
            const timeoutId = setTimeout(onExited, timeout);
            return () => {
                clearTimeout(timeoutId);
            };
        }
        return void 0;
    }, [onExited, inProp, timeout]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
        className: rippleClassName,
        style: rippleStyles,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
            className: childClassName,
        }),
    });
}
const touchRippleClasses = generateUtilityClasses("MuiTouchRipple", ["root", "ripple", "rippleVisible", "ripplePulsate", "child", "childLeaving", "childPulsate"]);
const touchRippleClasses$1 = touchRippleClasses;
const _excluded$R = ["center", "classes", "className"];
let _$1 = (t2) => t2,
    _t$1,
    _t2$1,
    _t3$1,
    _t4$1;
const DURATION = 550;
const DELAY_RIPPLE = 80;
const enterKeyframe = keyframes(
    _t$1 ||
        (_t$1 = _$1`
  0% {
    transform: scale(0);
    opacity: 0.1;
  }

  100% {
    transform: scale(1);
    opacity: 0.3;
  }
`)
);
const exitKeyframe = keyframes(
    _t2$1 ||
        (_t2$1 = _$1`
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
  }
`)
);
const pulsateKeyframe = keyframes(
    _t3$1 ||
        (_t3$1 = _$1`
  0% {
    transform: scale(1);
  }

  50% {
    transform: scale(0.92);
  }

  100% {
    transform: scale(1);
  }
`)
);
const TouchRippleRoot = styled$1("span", {
    name: "MuiTouchRipple",
    slot: "Root",
})({
    overflow: "hidden",
    pointerEvents: "none",
    position: "absolute",
    zIndex: 0,
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    borderRadius: "inherit",
});
const TouchRippleRipple = styled$1(Ripple, {
    name: "MuiTouchRipple",
    slot: "Ripple",
})(
    _t4$1 ||
        (_t4$1 = _$1`
  opacity: 0;
  position: absolute;

  &.${0} {
    opacity: 0.3;
    transform: scale(1);
    animation-name: ${0};
    animation-duration: ${0}ms;
    animation-timing-function: ${0};
  }

  &.${0} {
    animation-duration: ${0}ms;
  }

  & .${0} {
    opacity: 1;
    display: block;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: currentColor;
  }

  & .${0} {
    opacity: 0;
    animation-name: ${0};
    animation-duration: ${0}ms;
    animation-timing-function: ${0};
  }

  & .${0} {
    position: absolute;
    /* @noflip */
    left: 0px;
    top: 0;
    animation-name: ${0};
    animation-duration: 2500ms;
    animation-timing-function: ${0};
    animation-iteration-count: infinite;
    animation-delay: 200ms;
  }
`),
    touchRippleClasses$1.rippleVisible,
    enterKeyframe,
    DURATION,
    ({ theme }) => theme.transitions.easing.easeInOut,
    touchRippleClasses$1.ripplePulsate,
    ({ theme }) => theme.transitions.duration.shorter,
    touchRippleClasses$1.child,
    touchRippleClasses$1.childLeaving,
    exitKeyframe,
    DURATION,
    ({ theme }) => theme.transitions.easing.easeInOut,
    touchRippleClasses$1.childPulsate,
    pulsateKeyframe,
    ({ theme }) => theme.transitions.easing.easeInOut
);
const TouchRipple = /* @__PURE__ */ reactExports.forwardRef(function TouchRipple2(inProps, ref) {
    const props = useThemeProps({
        props: inProps,
        name: "MuiTouchRipple",
    });
    const { center: centerProp = false, classes = {}, className } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded$R);
    const [ripples, setRipples] = reactExports.useState([]);
    const nextKey = reactExports.useRef(0);
    const rippleCallback = reactExports.useRef(null);
    reactExports.useEffect(() => {
        if (rippleCallback.current) {
            rippleCallback.current();
            rippleCallback.current = null;
        }
    }, [ripples]);
    const ignoringMouseDown = reactExports.useRef(false);
    const startTimer = reactExports.useRef(null);
    const startTimerCommit = reactExports.useRef(null);
    const container2 = reactExports.useRef(null);
    reactExports.useEffect(() => {
        return () => {
            clearTimeout(startTimer.current);
        };
    }, []);
    const startCommit = reactExports.useCallback(
        (params) => {
            const { pulsate: pulsate2, rippleX, rippleY, rippleSize, cb } = params;
            setRipples((oldRipples) => [
                ...oldRipples,
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                    TouchRippleRipple,
                    {
                        classes: {
                            ripple: clsx$1(classes.ripple, touchRippleClasses$1.ripple),
                            rippleVisible: clsx$1(classes.rippleVisible, touchRippleClasses$1.rippleVisible),
                            ripplePulsate: clsx$1(classes.ripplePulsate, touchRippleClasses$1.ripplePulsate),
                            child: clsx$1(classes.child, touchRippleClasses$1.child),
                            childLeaving: clsx$1(classes.childLeaving, touchRippleClasses$1.childLeaving),
                            childPulsate: clsx$1(classes.childPulsate, touchRippleClasses$1.childPulsate),
                        },
                        timeout: DURATION,
                        pulsate: pulsate2,
                        rippleX,
                        rippleY,
                        rippleSize,
                    },
                    nextKey.current
                ),
            ]);
            nextKey.current += 1;
            rippleCallback.current = cb;
        },
        [classes]
    );
    const start2 = reactExports.useCallback(
        (event = {}, options = {}, cb = () => {}) => {
            const {
                pulsate: pulsate2 = false,
                center = centerProp || options.pulsate,
                fakeElement = false,
                // For test purposes
            } = options;
            if ((event == null ? void 0 : event.type) === "mousedown" && ignoringMouseDown.current) {
                ignoringMouseDown.current = false;
                return;
            }
            if ((event == null ? void 0 : event.type) === "touchstart") {
                ignoringMouseDown.current = true;
            }
            const element = fakeElement ? null : container2.current;
            const rect = element
                ? element.getBoundingClientRect()
                : {
                      width: 0,
                      height: 0,
                      left: 0,
                      top: 0,
                  };
            let rippleX;
            let rippleY;
            let rippleSize;
            if (center || event === void 0 || (event.clientX === 0 && event.clientY === 0) || (!event.clientX && !event.touches)) {
                rippleX = Math.round(rect.width / 2);
                rippleY = Math.round(rect.height / 2);
            } else {
                const { clientX, clientY } = event.touches && event.touches.length > 0 ? event.touches[0] : event;
                rippleX = Math.round(clientX - rect.left);
                rippleY = Math.round(clientY - rect.top);
            }
            if (center) {
                rippleSize = Math.sqrt((2 * rect.width ** 2 + rect.height ** 2) / 3);
                if (rippleSize % 2 === 0) {
                    rippleSize += 1;
                }
            } else {
                const sizeX = Math.max(Math.abs((element ? element.clientWidth : 0) - rippleX), rippleX) * 2 + 2;
                const sizeY = Math.max(Math.abs((element ? element.clientHeight : 0) - rippleY), rippleY) * 2 + 2;
                rippleSize = Math.sqrt(sizeX ** 2 + sizeY ** 2);
            }
            if (event != null && event.touches) {
                if (startTimerCommit.current === null) {
                    startTimerCommit.current = () => {
                        startCommit({
                            pulsate: pulsate2,
                            rippleX,
                            rippleY,
                            rippleSize,
                            cb,
                        });
                    };
                    startTimer.current = setTimeout(() => {
                        if (startTimerCommit.current) {
                            startTimerCommit.current();
                            startTimerCommit.current = null;
                        }
                    }, DELAY_RIPPLE);
                }
            } else {
                startCommit({
                    pulsate: pulsate2,
                    rippleX,
                    rippleY,
                    rippleSize,
                    cb,
                });
            }
        },
        [centerProp, startCommit]
    );
    const pulsate = reactExports.useCallback(() => {
        start2(
            {},
            {
                pulsate: true,
            }
        );
    }, [start2]);
    const stop = reactExports.useCallback((event, cb) => {
        clearTimeout(startTimer.current);
        if ((event == null ? void 0 : event.type) === "touchend" && startTimerCommit.current) {
            startTimerCommit.current();
            startTimerCommit.current = null;
            startTimer.current = setTimeout(() => {
                stop(event, cb);
            });
            return;
        }
        startTimerCommit.current = null;
        setRipples((oldRipples) => {
            if (oldRipples.length > 0) {
                return oldRipples.slice(1);
            }
            return oldRipples;
        });
        rippleCallback.current = cb;
    }, []);
    reactExports.useImperativeHandle(
        ref,
        () => ({
            pulsate,
            start: start2,
            stop,
        }),
        [pulsate, start2, stop]
    );
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
        TouchRippleRoot,
        _extends(
            {
                className: clsx$1(touchRippleClasses$1.root, classes.root, className),
                ref: container2,
            },
            other,
            {
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionGroup$1, {
                    component: null,
                    exit: true,
                    children: ripples,
                }),
            }
        )
    );
});
const TouchRipple$1 = TouchRipple;
function getButtonBaseUtilityClass(slot) {
    return generateUtilityClass("MuiButtonBase", slot);
}
const buttonBaseClasses = generateUtilityClasses("MuiButtonBase", ["root", "disabled", "focusVisible"]);
const buttonBaseClasses$1 = buttonBaseClasses;
const _excluded$Q = [
    "action",
    "centerRipple",
    "children",
    "className",
    "component",
    "disabled",
    "disableRipple",
    "disableTouchRipple",
    "focusRipple",
    "focusVisibleClassName",
    "LinkComponent",
    "onBlur",
    "onClick",
    "onContextMenu",
    "onDragLeave",
    "onFocus",
    "onFocusVisible",
    "onKeyDown",
    "onKeyUp",
    "onMouseDown",
    "onMouseLeave",
    "onMouseUp",
    "onTouchEnd",
    "onTouchMove",
    "onTouchStart",
    "tabIndex",
    "TouchRippleProps",
    "touchRippleRef",
    "type",
];
const useUtilityClasses$H = (ownerState) => {
    const { disabled, focusVisible, focusVisibleClassName, classes } = ownerState;
    const slots = {
        root: ["root", disabled && "disabled", focusVisible && "focusVisible"],
    };
    const composedClasses = composeClasses(slots, getButtonBaseUtilityClass, classes);
    if (focusVisible && focusVisibleClassName) {
        composedClasses.root += ` ${focusVisibleClassName}`;
    }
    return composedClasses;
};
const ButtonBaseRoot = styled$1("button", {
    name: "MuiButtonBase",
    slot: "Root",
    overridesResolver: (props, styles2) => styles2.root,
})({
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    position: "relative",
    boxSizing: "border-box",
    WebkitTapHighlightColor: "transparent",
    backgroundColor: "transparent",
    // Reset default value
    // We disable the focus ring for mouse, touch and keyboard users.
    outline: 0,
    border: 0,
    margin: 0,
    // Remove the margin in Safari
    borderRadius: 0,
    padding: 0,
    // Remove the padding in Firefox
    cursor: "pointer",
    userSelect: "none",
    verticalAlign: "middle",
    MozAppearance: "none",
    // Reset
    WebkitAppearance: "none",
    // Reset
    textDecoration: "none",
    // So we take precedent over the style of a native <a /> element.
    color: "inherit",
    "&::-moz-focus-inner": {
        borderStyle: "none",
        // Remove Firefox dotted outline.
    },
    [`&.${buttonBaseClasses$1.disabled}`]: {
        pointerEvents: "none",
        // Disable link interactions
        cursor: "default",
    },
    "@media print": {
        colorAdjust: "exact",
    },
});
const ButtonBase = /* @__PURE__ */ reactExports.forwardRef(function ButtonBase2(inProps, ref) {
    const props = useThemeProps({
        props: inProps,
        name: "MuiButtonBase",
    });
    const {
            action,
            centerRipple = false,
            children,
            className,
            component = "button",
            disabled = false,
            disableRipple = false,
            disableTouchRipple = false,
            focusRipple = false,
            LinkComponent = "a",
            onBlur,
            onClick,
            onContextMenu,
            onDragLeave,
            onFocus,
            onFocusVisible,
            onKeyDown,
            onKeyUp,
            onMouseDown,
            onMouseLeave,
            onMouseUp,
            onTouchEnd,
            onTouchMove,
            onTouchStart,
            tabIndex = 0,
            TouchRippleProps,
            touchRippleRef,
            type,
        } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded$Q);
    const buttonRef = reactExports.useRef(null);
    const rippleRef = reactExports.useRef(null);
    const handleRippleRef = useForkRef(rippleRef, touchRippleRef);
    const { isFocusVisibleRef, onFocus: handleFocusVisible, onBlur: handleBlurVisible, ref: focusVisibleRef } = useIsFocusVisible();
    const [focusVisible, setFocusVisible] = reactExports.useState(false);
    if (disabled && focusVisible) {
        setFocusVisible(false);
    }
    reactExports.useImperativeHandle(
        action,
        () => ({
            focusVisible: () => {
                setFocusVisible(true);
                buttonRef.current.focus();
            },
        }),
        []
    );
    const [mountedState, setMountedState] = reactExports.useState(false);
    reactExports.useEffect(() => {
        setMountedState(true);
    }, []);
    const enableTouchRipple = mountedState && !disableRipple && !disabled;
    reactExports.useEffect(() => {
        if (focusVisible && focusRipple && !disableRipple && mountedState) {
            rippleRef.current.pulsate();
        }
    }, [disableRipple, focusRipple, focusVisible, mountedState]);
    function useRippleHandler(rippleAction, eventCallback, skipRippleAction = disableTouchRipple) {
        return useEventCallback((event) => {
            if (eventCallback) {
                eventCallback(event);
            }
            const ignore = skipRippleAction;
            if (!ignore && rippleRef.current) {
                rippleRef.current[rippleAction](event);
            }
            return true;
        });
    }
    const handleMouseDown = useRippleHandler("start", onMouseDown);
    const handleContextMenu = useRippleHandler("stop", onContextMenu);
    const handleDragLeave = useRippleHandler("stop", onDragLeave);
    const handleMouseUp = useRippleHandler("stop", onMouseUp);
    const handleMouseLeave = useRippleHandler("stop", (event) => {
        if (focusVisible) {
            event.preventDefault();
        }
        if (onMouseLeave) {
            onMouseLeave(event);
        }
    });
    const handleTouchStart = useRippleHandler("start", onTouchStart);
    const handleTouchEnd = useRippleHandler("stop", onTouchEnd);
    const handleTouchMove = useRippleHandler("stop", onTouchMove);
    const handleBlur = useRippleHandler(
        "stop",
        (event) => {
            handleBlurVisible(event);
            if (isFocusVisibleRef.current === false) {
                setFocusVisible(false);
            }
            if (onBlur) {
                onBlur(event);
            }
        },
        false
    );
    const handleFocus = useEventCallback((event) => {
        if (!buttonRef.current) {
            buttonRef.current = event.currentTarget;
        }
        handleFocusVisible(event);
        if (isFocusVisibleRef.current === true) {
            setFocusVisible(true);
            if (onFocusVisible) {
                onFocusVisible(event);
            }
        }
        if (onFocus) {
            onFocus(event);
        }
    });
    const isNonNativeButton = () => {
        const button = buttonRef.current;
        return component && component !== "button" && !(button.tagName === "A" && button.href);
    };
    const keydownRef = reactExports.useRef(false);
    const handleKeyDown2 = useEventCallback((event) => {
        if (focusRipple && !keydownRef.current && focusVisible && rippleRef.current && event.key === " ") {
            keydownRef.current = true;
            rippleRef.current.stop(event, () => {
                rippleRef.current.start(event);
            });
        }
        if (event.target === event.currentTarget && isNonNativeButton() && event.key === " ") {
            event.preventDefault();
        }
        if (onKeyDown) {
            onKeyDown(event);
        }
        if (event.target === event.currentTarget && isNonNativeButton() && event.key === "Enter" && !disabled) {
            event.preventDefault();
            if (onClick) {
                onClick(event);
            }
        }
    });
    const handleKeyUp = useEventCallback((event) => {
        if (focusRipple && event.key === " " && rippleRef.current && focusVisible && !event.defaultPrevented) {
            keydownRef.current = false;
            rippleRef.current.stop(event, () => {
                rippleRef.current.pulsate(event);
            });
        }
        if (onKeyUp) {
            onKeyUp(event);
        }
        if (onClick && event.target === event.currentTarget && isNonNativeButton() && event.key === " " && !event.defaultPrevented) {
            onClick(event);
        }
    });
    let ComponentProp = component;
    if (ComponentProp === "button" && (other.href || other.to)) {
        ComponentProp = LinkComponent;
    }
    const buttonProps = {};
    if (ComponentProp === "button") {
        buttonProps.type = type === void 0 ? "button" : type;
        buttonProps.disabled = disabled;
    } else {
        if (!other.href && !other.to) {
            buttonProps.role = "button";
        }
        if (disabled) {
            buttonProps["aria-disabled"] = disabled;
        }
    }
    const handleRef = useForkRef(ref, focusVisibleRef, buttonRef);
    const ownerState = _extends({}, props, {
        centerRipple,
        component,
        disabled,
        disableRipple,
        disableTouchRipple,
        focusRipple,
        tabIndex,
        focusVisible,
    });
    const classes = useUtilityClasses$H(ownerState);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        ButtonBaseRoot,
        _extends(
            {
                as: ComponentProp,
                className: clsx$1(classes.root, className),
                ownerState,
                onBlur: handleBlur,
                onClick,
                onContextMenu: handleContextMenu,
                onFocus: handleFocus,
                onKeyDown: handleKeyDown2,
                onKeyUp: handleKeyUp,
                onMouseDown: handleMouseDown,
                onMouseLeave: handleMouseLeave,
                onMouseUp: handleMouseUp,
                onDragLeave: handleDragLeave,
                onTouchEnd: handleTouchEnd,
                onTouchMove: handleTouchMove,
                onTouchStart: handleTouchStart,
                ref: handleRef,
                tabIndex: disabled ? -1 : tabIndex,
                type,
            },
            buttonProps,
            other,
            {
                children: [
                    children,
                    enableTouchRipple
                        ? /* TouchRipple is only needed client-side, x2 boost on the server. */
                          /* @__PURE__ */ jsxRuntimeExports.jsx(
                              TouchRipple$1,
                              _extends(
                                  {
                                      ref: handleRippleRef,
                                      center: centerRipple,
                                  },
                                  TouchRippleProps
                              )
                          )
                        : null,
                ],
            }
        )
    );
});
const ButtonBase$1 = ButtonBase;
function getIconButtonUtilityClass(slot) {
    return generateUtilityClass("MuiIconButton", slot);
}
const iconButtonClasses = generateUtilityClasses("MuiIconButton", [
    "root",
    "disabled",
    "colorInherit",
    "colorPrimary",
    "colorSecondary",
    "colorError",
    "colorInfo",
    "colorSuccess",
    "colorWarning",
    "edgeStart",
    "edgeEnd",
    "sizeSmall",
    "sizeMedium",
    "sizeLarge",
]);
const iconButtonClasses$1 = iconButtonClasses;
const _excluded$P = ["edge", "children", "className", "color", "disabled", "disableFocusRipple", "size"];
const useUtilityClasses$G = (ownerState) => {
    const { classes, disabled, color: color2, edge, size } = ownerState;
    const slots = {
        root: ["root", disabled && "disabled", color2 !== "default" && `color${capitalize(color2)}`, edge && `edge${capitalize(edge)}`, `size${capitalize(size)}`],
    };
    return composeClasses(slots, getIconButtonUtilityClass, classes);
};
const IconButtonRoot = styled$1(ButtonBase$1, {
    name: "MuiIconButton",
    slot: "Root",
    overridesResolver: (props, styles2) => {
        const { ownerState } = props;
        return [
            styles2.root,
            ownerState.color !== "default" && styles2[`color${capitalize(ownerState.color)}`],
            ownerState.edge && styles2[`edge${capitalize(ownerState.edge)}`],
            styles2[`size${capitalize(ownerState.size)}`],
        ];
    },
})(
    ({ theme, ownerState }) =>
        _extends(
            {
                textAlign: "center",
                flex: "0 0 auto",
                fontSize: theme.typography.pxToRem(24),
                padding: 8,
                borderRadius: "50%",
                overflow: "visible",
                // Explicitly set the default value to solve a bug on IE11.
                color: (theme.vars || theme).palette.action.active,
                transition: theme.transitions.create("background-color", {
                    duration: theme.transitions.duration.shortest,
                }),
            },
            !ownerState.disableRipple && {
                "&:hover": {
                    backgroundColor: theme.vars
                        ? `rgba(${theme.vars.palette.action.activeChannel} / ${theme.vars.palette.action.hoverOpacity})`
                        : alpha(theme.palette.action.active, theme.palette.action.hoverOpacity),
                    // Reset on touch devices, it doesn't add specificity
                    "@media (hover: none)": {
                        backgroundColor: "transparent",
                    },
                },
            },
            ownerState.edge === "start" && {
                marginLeft: ownerState.size === "small" ? -3 : -12,
            },
            ownerState.edge === "end" && {
                marginRight: ownerState.size === "small" ? -3 : -12,
            }
        ),
    ({ theme, ownerState }) => {
        var _palette;
        const palette = (_palette = (theme.vars || theme).palette) == null ? void 0 : _palette[ownerState.color];
        return _extends(
            {},
            ownerState.color === "inherit" && {
                color: "inherit",
            },
            ownerState.color !== "inherit" &&
                ownerState.color !== "default" &&
                _extends(
                    {
                        color: palette == null ? void 0 : palette.main,
                    },
                    !ownerState.disableRipple && {
                        "&:hover": _extends(
                            {},
                            palette && {
                                backgroundColor: theme.vars ? `rgba(${palette.mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(palette.main, theme.palette.action.hoverOpacity),
                            },
                            {
                                // Reset on touch devices, it doesn't add specificity
                                "@media (hover: none)": {
                                    backgroundColor: "transparent",
                                },
                            }
                        ),
                    }
                ),
            ownerState.size === "small" && {
                padding: 5,
                fontSize: theme.typography.pxToRem(18),
            },
            ownerState.size === "large" && {
                padding: 12,
                fontSize: theme.typography.pxToRem(28),
            },
            {
                [`&.${iconButtonClasses$1.disabled}`]: {
                    backgroundColor: "transparent",
                    color: (theme.vars || theme).palette.action.disabled,
                },
            }
        );
    }
);
const IconButton = /* @__PURE__ */ reactExports.forwardRef(function IconButton2(inProps, ref) {
    const props = useThemeProps({
        props: inProps,
        name: "MuiIconButton",
    });
    const { edge = false, children, className, color: color2 = "default", disabled = false, disableFocusRipple = false, size = "medium" } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded$P);
    const ownerState = _extends({}, props, {
        edge,
        color: color2,
        disabled,
        disableFocusRipple,
        size,
    });
    const classes = useUtilityClasses$G(ownerState);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
        IconButtonRoot,
        _extends(
            {
                className: clsx$1(classes.root, className),
                centerRipple: true,
                focusRipple: !disableFocusRipple,
                disabled,
                ref,
                ownerState,
            },
            other,
            {
                children,
            }
        )
    );
});
const IconButton$1 = IconButton;
const ClearIcon = createSvgIcon$1(
    /* @__PURE__ */ jsxRuntimeExports.jsx("path", {
        d: "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z",
    }),
    "Close"
);
function getTypographyUtilityClass(slot) {
    return generateUtilityClass("MuiTypography", slot);
}
generateUtilityClasses("MuiTypography", [
    "root",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "subtitle1",
    "subtitle2",
    "body1",
    "body2",
    "inherit",
    "button",
    "caption",
    "overline",
    "alignLeft",
    "alignRight",
    "alignCenter",
    "alignJustify",
    "noWrap",
    "gutterBottom",
    "paragraph",
]);
const _excluded$O = ["align", "className", "component", "gutterBottom", "noWrap", "paragraph", "variant", "variantMapping"];
const useUtilityClasses$F = (ownerState) => {
    const { align, gutterBottom, noWrap, paragraph, variant, classes } = ownerState;
    const slots = {
        root: ["root", variant, ownerState.align !== "inherit" && `align${capitalize(align)}`, gutterBottom && "gutterBottom", noWrap && "noWrap", paragraph && "paragraph"],
    };
    return composeClasses(slots, getTypographyUtilityClass, classes);
};
const TypographyRoot = styled$1("span", {
    name: "MuiTypography",
    slot: "Root",
    overridesResolver: (props, styles2) => {
        const { ownerState } = props;
        return [
            styles2.root,
            ownerState.variant && styles2[ownerState.variant],
            ownerState.align !== "inherit" && styles2[`align${capitalize(ownerState.align)}`],
            ownerState.noWrap && styles2.noWrap,
            ownerState.gutterBottom && styles2.gutterBottom,
            ownerState.paragraph && styles2.paragraph,
        ];
    },
})(({ theme, ownerState }) =>
    _extends(
        {
            margin: 0,
        },
        ownerState.variant && theme.typography[ownerState.variant],
        ownerState.align !== "inherit" && {
            textAlign: ownerState.align,
        },
        ownerState.noWrap && {
            overflow: "hidden",
            textOverflow: "ellipsis",
            whiteSpace: "nowrap",
        },
        ownerState.gutterBottom && {
            marginBottom: "0.35em",
        },
        ownerState.paragraph && {
            marginBottom: 16,
        }
    )
);
const defaultVariantMapping = {
    h1: "h1",
    h2: "h2",
    h3: "h3",
    h4: "h4",
    h5: "h5",
    h6: "h6",
    subtitle1: "h6",
    subtitle2: "h6",
    body1: "p",
    body2: "p",
    inherit: "p",
};
const colorTransformations = {
    primary: "primary.main",
    textPrimary: "text.primary",
    secondary: "secondary.main",
    textSecondary: "text.secondary",
    error: "error.main",
};
const transformDeprecatedColors = (color2) => {
    return colorTransformations[color2] || color2;
};
const Typography = /* @__PURE__ */ reactExports.forwardRef(function Typography2(inProps, ref) {
    const themeProps = useThemeProps({
        props: inProps,
        name: "MuiTypography",
    });
    const color2 = transformDeprecatedColors(themeProps.color);
    const props = extendSxProp(
        _extends({}, themeProps, {
            color: color2,
        })
    );
    const { align = "inherit", className, component, gutterBottom = false, noWrap = false, paragraph = false, variant = "body1", variantMapping = defaultVariantMapping } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded$O);
    const ownerState = _extends({}, props, {
        align,
        color: color2,
        className,
        component,
        gutterBottom,
        noWrap,
        paragraph,
        variant,
        variantMapping,
    });
    const Component = component || (paragraph ? "p" : variantMapping[variant] || defaultVariantMapping[variant]) || "span";
    const classes = useUtilityClasses$F(ownerState);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
        TypographyRoot,
        _extends(
            {
                as: Component,
                ref,
                ownerState,
                className: clsx$1(classes.root, className),
            },
            other
        )
    );
});
const Typography$1 = Typography;
const _excluded$N = [
    "anchorEl",
    "component",
    "components",
    "componentsProps",
    "container",
    "disablePortal",
    "keepMounted",
    "modifiers",
    "open",
    "placement",
    "popperOptions",
    "popperRef",
    "transition",
    "slots",
    "slotProps",
];
const PopperRoot = styled$1(BasePopper, {
    name: "MuiPopper",
    slot: "Root",
    overridesResolver: (props, styles2) => styles2.root,
})({});
const Popper2 = /* @__PURE__ */ reactExports.forwardRef(function Popper3(inProps, ref) {
    var _slots$root;
    const theme = useTheme$2();
    const props = useThemeProps({
        props: inProps,
        name: "MuiPopper",
    });
    const {
            anchorEl,
            component,
            components,
            componentsProps,
            container: container2,
            disablePortal,
            keepMounted,
            modifiers,
            open: open2,
            placement,
            popperOptions,
            popperRef,
            transition,
            slots,
            slotProps,
        } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded$N);
    const RootComponent = (_slots$root = slots == null ? void 0 : slots.root) != null ? _slots$root : components == null ? void 0 : components.Root;
    const otherProps = _extends(
        {
            anchorEl,
            component,
            container: container2,
            disablePortal,
            keepMounted,
            modifiers,
            open: open2,
            placement,
            popperOptions,
            popperRef,
            transition,
        },
        other
    );
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
        PopperRoot,
        _extends(
            {
                direction: theme == null ? void 0 : theme.direction,
                slots: {
                    root: RootComponent,
                },
                slotProps: slotProps != null ? slotProps : componentsProps,
            },
            otherProps,
            {
                ref,
            }
        )
    );
});
const Popper$1 = Popper2;
function getListSubheaderUtilityClass(slot) {
    return generateUtilityClass("MuiListSubheader", slot);
}
generateUtilityClasses("MuiListSubheader", ["root", "colorPrimary", "colorInherit", "gutters", "inset", "sticky"]);
const _excluded$M = ["className", "color", "component", "disableGutters", "disableSticky", "inset"];
const useUtilityClasses$E = (ownerState) => {
    const { classes, color: color2, disableGutters, inset, disableSticky } = ownerState;
    const slots = {
        root: ["root", color2 !== "default" && `color${capitalize(color2)}`, !disableGutters && "gutters", inset && "inset", !disableSticky && "sticky"],
    };
    return composeClasses(slots, getListSubheaderUtilityClass, classes);
};
const ListSubheaderRoot = styled$1("li", {
    name: "MuiListSubheader",
    slot: "Root",
    overridesResolver: (props, styles2) => {
        const { ownerState } = props;
        return [
            styles2.root,
            ownerState.color !== "default" && styles2[`color${capitalize(ownerState.color)}`],
            !ownerState.disableGutters && styles2.gutters,
            ownerState.inset && styles2.inset,
            !ownerState.disableSticky && styles2.sticky,
        ];
    },
})(({ theme, ownerState }) =>
    _extends(
        {
            boxSizing: "border-box",
            lineHeight: "48px",
            listStyle: "none",
            color: (theme.vars || theme).palette.text.secondary,
            fontFamily: theme.typography.fontFamily,
            fontWeight: theme.typography.fontWeightMedium,
            fontSize: theme.typography.pxToRem(14),
        },
        ownerState.color === "primary" && {
            color: (theme.vars || theme).palette.primary.main,
        },
        ownerState.color === "inherit" && {
            color: "inherit",
        },
        !ownerState.disableGutters && {
            paddingLeft: 16,
            paddingRight: 16,
        },
        ownerState.inset && {
            paddingLeft: 72,
        },
        !ownerState.disableSticky && {
            position: "sticky",
            top: 0,
            zIndex: 1,
            backgroundColor: (theme.vars || theme).palette.background.paper,
        }
    )
);
const ListSubheader = /* @__PURE__ */ reactExports.forwardRef(function ListSubheader2(inProps, ref) {
    const props = useThemeProps({
        props: inProps,
        name: "MuiListSubheader",
    });
    const { className, color: color2 = "default", component = "li", disableGutters = false, disableSticky = false, inset = false } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded$M);
    const ownerState = _extends({}, props, {
        color: color2,
        component,
        disableGutters,
        disableSticky,
        inset,
    });
    const classes = useUtilityClasses$E(ownerState);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
        ListSubheaderRoot,
        _extends(
            {
                as: component,
                className: clsx$1(classes.root, className),
                ref,
                ownerState,
            },
            other
        )
    );
});
ListSubheader.muiSkipListHighlight = true;
const ListSubheader$1 = ListSubheader;
const CancelIcon = createSvgIcon$1(
    /* @__PURE__ */ jsxRuntimeExports.jsx("path", {
        d: "M12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2zm5 13.59L15.59 17 12 13.41 8.41 17 7 15.59 10.59 12 7 8.41 8.41 7 12 10.59 15.59 7 17 8.41 13.41 12 17 15.59z",
    }),
    "Cancel"
);
function getChipUtilityClass(slot) {
    return generateUtilityClass("MuiChip", slot);
}
const chipClasses = generateUtilityClasses("MuiChip", [
    "root",
    "sizeSmall",
    "sizeMedium",
    "colorError",
    "colorInfo",
    "colorPrimary",
    "colorSecondary",
    "colorSuccess",
    "colorWarning",
    "disabled",
    "clickable",
    "clickableColorPrimary",
    "clickableColorSecondary",
    "deletable",
    "deletableColorPrimary",
    "deletableColorSecondary",
    "outlined",
    "filled",
    "outlinedPrimary",
    "outlinedSecondary",
    "filledPrimary",
    "filledSecondary",
    "avatar",
    "avatarSmall",
    "avatarMedium",
    "avatarColorPrimary",
    "avatarColorSecondary",
    "icon",
    "iconSmall",
    "iconMedium",
    "iconColorPrimary",
    "iconColorSecondary",
    "label",
    "labelSmall",
    "labelMedium",
    "deleteIcon",
    "deleteIconSmall",
    "deleteIconMedium",
    "deleteIconColorPrimary",
    "deleteIconColorSecondary",
    "deleteIconOutlinedColorPrimary",
    "deleteIconOutlinedColorSecondary",
    "deleteIconFilledColorPrimary",
    "deleteIconFilledColorSecondary",
    "focusVisible",
]);
const chipClasses$1 = chipClasses;
const _excluded$L = [
    "avatar",
    "className",
    "clickable",
    "color",
    "component",
    "deleteIcon",
    "disabled",
    "icon",
    "label",
    "onClick",
    "onDelete",
    "onKeyDown",
    "onKeyUp",
    "size",
    "variant",
    "tabIndex",
    "skipFocusWhenDisabled",
];
const useUtilityClasses$D = (ownerState) => {
    const { classes, disabled, size, color: color2, iconColor, onDelete, clickable, variant } = ownerState;
    const slots = {
        root: [
            "root",
            variant,
            disabled && "disabled",
            `size${capitalize(size)}`,
            `color${capitalize(color2)}`,
            clickable && "clickable",
            clickable && `clickableColor${capitalize(color2)}`,
            onDelete && "deletable",
            onDelete && `deletableColor${capitalize(color2)}`,
            `${variant}${capitalize(color2)}`,
        ],
        label: ["label", `label${capitalize(size)}`],
        avatar: ["avatar", `avatar${capitalize(size)}`, `avatarColor${capitalize(color2)}`],
        icon: ["icon", `icon${capitalize(size)}`, `iconColor${capitalize(iconColor)}`],
        deleteIcon: ["deleteIcon", `deleteIcon${capitalize(size)}`, `deleteIconColor${capitalize(color2)}`, `deleteIcon${capitalize(variant)}Color${capitalize(color2)}`],
    };
    return composeClasses(slots, getChipUtilityClass, classes);
};
const ChipRoot = styled$1("div", {
    name: "MuiChip",
    slot: "Root",
    overridesResolver: (props, styles2) => {
        const { ownerState } = props;
        const { color: color2, iconColor, clickable, onDelete, size, variant } = ownerState;
        return [
            {
                [`& .${chipClasses$1.avatar}`]: styles2.avatar,
            },
            {
                [`& .${chipClasses$1.avatar}`]: styles2[`avatar${capitalize(size)}`],
            },
            {
                [`& .${chipClasses$1.avatar}`]: styles2[`avatarColor${capitalize(color2)}`],
            },
            {
                [`& .${chipClasses$1.icon}`]: styles2.icon,
            },
            {
                [`& .${chipClasses$1.icon}`]: styles2[`icon${capitalize(size)}`],
            },
            {
                [`& .${chipClasses$1.icon}`]: styles2[`iconColor${capitalize(iconColor)}`],
            },
            {
                [`& .${chipClasses$1.deleteIcon}`]: styles2.deleteIcon,
            },
            {
                [`& .${chipClasses$1.deleteIcon}`]: styles2[`deleteIcon${capitalize(size)}`],
            },
            {
                [`& .${chipClasses$1.deleteIcon}`]: styles2[`deleteIconColor${capitalize(color2)}`],
            },
            {
                [`& .${chipClasses$1.deleteIcon}`]: styles2[`deleteIcon${capitalize(variant)}Color${capitalize(color2)}`],
            },
            styles2.root,
            styles2[`size${capitalize(size)}`],
            styles2[`color${capitalize(color2)}`],
            clickable && styles2.clickable,
            clickable && color2 !== "default" && styles2[`clickableColor${capitalize(color2)})`],
            onDelete && styles2.deletable,
            onDelete && color2 !== "default" && styles2[`deletableColor${capitalize(color2)}`],
            styles2[variant],
            styles2[`${variant}${capitalize(color2)}`],
        ];
    },
})(
    ({ theme, ownerState }) => {
        const textColor = theme.palette.mode === "light" ? theme.palette.grey[700] : theme.palette.grey[300];
        return _extends(
            {
                maxWidth: "100%",
                fontFamily: theme.typography.fontFamily,
                fontSize: theme.typography.pxToRem(13),
                display: "inline-flex",
                alignItems: "center",
                justifyContent: "center",
                height: 32,
                color: (theme.vars || theme).palette.text.primary,
                backgroundColor: (theme.vars || theme).palette.action.selected,
                borderRadius: 32 / 2,
                whiteSpace: "nowrap",
                transition: theme.transitions.create(["background-color", "box-shadow"]),
                // label will inherit this from root, then `clickable` class overrides this for both
                cursor: "default",
                // We disable the focus ring for mouse, touch and keyboard users.
                outline: 0,
                textDecoration: "none",
                border: 0,
                // Remove `button` border
                padding: 0,
                // Remove `button` padding
                verticalAlign: "middle",
                boxSizing: "border-box",
                [`&.${chipClasses$1.disabled}`]: {
                    opacity: (theme.vars || theme).palette.action.disabledOpacity,
                    pointerEvents: "none",
                },
                [`& .${chipClasses$1.avatar}`]: {
                    marginLeft: 5,
                    marginRight: -6,
                    width: 24,
                    height: 24,
                    color: theme.vars ? theme.vars.palette.Chip.defaultAvatarColor : textColor,
                    fontSize: theme.typography.pxToRem(12),
                },
                [`& .${chipClasses$1.avatarColorPrimary}`]: {
                    color: (theme.vars || theme).palette.primary.contrastText,
                    backgroundColor: (theme.vars || theme).palette.primary.dark,
                },
                [`& .${chipClasses$1.avatarColorSecondary}`]: {
                    color: (theme.vars || theme).palette.secondary.contrastText,
                    backgroundColor: (theme.vars || theme).palette.secondary.dark,
                },
                [`& .${chipClasses$1.avatarSmall}`]: {
                    marginLeft: 4,
                    marginRight: -4,
                    width: 18,
                    height: 18,
                    fontSize: theme.typography.pxToRem(10),
                },
                [`& .${chipClasses$1.icon}`]: _extends(
                    {
                        marginLeft: 5,
                        marginRight: -6,
                    },
                    ownerState.size === "small" && {
                        fontSize: 18,
                        marginLeft: 4,
                        marginRight: -4,
                    },
                    ownerState.iconColor === ownerState.color &&
                        _extends(
                            {
                                color: theme.vars ? theme.vars.palette.Chip.defaultIconColor : textColor,
                            },
                            ownerState.color !== "default" && {
                                color: "inherit",
                            }
                        )
                ),
                [`& .${chipClasses$1.deleteIcon}`]: _extends(
                    {
                        WebkitTapHighlightColor: "transparent",
                        color: theme.vars ? `rgba(${theme.vars.palette.text.primaryChannel} / 0.26)` : alpha(theme.palette.text.primary, 0.26),
                        fontSize: 22,
                        cursor: "pointer",
                        margin: "0 5px 0 -6px",
                        "&:hover": {
                            color: theme.vars ? `rgba(${theme.vars.palette.text.primaryChannel} / 0.4)` : alpha(theme.palette.text.primary, 0.4),
                        },
                    },
                    ownerState.size === "small" && {
                        fontSize: 16,
                        marginRight: 4,
                        marginLeft: -4,
                    },
                    ownerState.color !== "default" && {
                        color: theme.vars ? `rgba(${theme.vars.palette[ownerState.color].contrastTextChannel} / 0.7)` : alpha(theme.palette[ownerState.color].contrastText, 0.7),
                        "&:hover, &:active": {
                            color: (theme.vars || theme).palette[ownerState.color].contrastText,
                        },
                    }
                ),
            },
            ownerState.size === "small" && {
                height: 24,
            },
            ownerState.color !== "default" && {
                backgroundColor: (theme.vars || theme).palette[ownerState.color].main,
                color: (theme.vars || theme).palette[ownerState.color].contrastText,
            },
            ownerState.onDelete && {
                [`&.${chipClasses$1.focusVisible}`]: {
                    backgroundColor: theme.vars
                        ? `rgba(${theme.vars.palette.action.selectedChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.focusOpacity}))`
                        : alpha(theme.palette.action.selected, theme.palette.action.selectedOpacity + theme.palette.action.focusOpacity),
                },
            },
            ownerState.onDelete &&
                ownerState.color !== "default" && {
                    [`&.${chipClasses$1.focusVisible}`]: {
                        backgroundColor: (theme.vars || theme).palette[ownerState.color].dark,
                    },
                }
        );
    },
    ({ theme, ownerState }) =>
        _extends(
            {},
            ownerState.clickable && {
                userSelect: "none",
                WebkitTapHighlightColor: "transparent",
                cursor: "pointer",
                "&:hover": {
                    backgroundColor: theme.vars
                        ? `rgba(${theme.vars.palette.action.selectedChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.hoverOpacity}))`
                        : alpha(theme.palette.action.selected, theme.palette.action.selectedOpacity + theme.palette.action.hoverOpacity),
                },
                [`&.${chipClasses$1.focusVisible}`]: {
                    backgroundColor: theme.vars
                        ? `rgba(${theme.vars.palette.action.selectedChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.focusOpacity}))`
                        : alpha(theme.palette.action.selected, theme.palette.action.selectedOpacity + theme.palette.action.focusOpacity),
                },
                "&:active": {
                    boxShadow: (theme.vars || theme).shadows[1],
                },
            },
            ownerState.clickable &&
                ownerState.color !== "default" && {
                    [`&:hover, &.${chipClasses$1.focusVisible}`]: {
                        backgroundColor: (theme.vars || theme).palette[ownerState.color].dark,
                    },
                }
        ),
    ({ theme, ownerState }) =>
        _extends(
            {},
            ownerState.variant === "outlined" && {
                backgroundColor: "transparent",
                border: theme.vars ? `1px solid ${theme.vars.palette.Chip.defaultBorder}` : `1px solid ${theme.palette.mode === "light" ? theme.palette.grey[400] : theme.palette.grey[700]}`,
                [`&.${chipClasses$1.clickable}:hover`]: {
                    backgroundColor: (theme.vars || theme).palette.action.hover,
                },
                [`&.${chipClasses$1.focusVisible}`]: {
                    backgroundColor: (theme.vars || theme).palette.action.focus,
                },
                [`& .${chipClasses$1.avatar}`]: {
                    marginLeft: 4,
                },
                [`& .${chipClasses$1.avatarSmall}`]: {
                    marginLeft: 2,
                },
                [`& .${chipClasses$1.icon}`]: {
                    marginLeft: 4,
                },
                [`& .${chipClasses$1.iconSmall}`]: {
                    marginLeft: 2,
                },
                [`& .${chipClasses$1.deleteIcon}`]: {
                    marginRight: 5,
                },
                [`& .${chipClasses$1.deleteIconSmall}`]: {
                    marginRight: 3,
                },
            },
            ownerState.variant === "outlined" &&
                ownerState.color !== "default" && {
                    color: (theme.vars || theme).palette[ownerState.color].main,
                    border: `1px solid ${theme.vars ? `rgba(${theme.vars.palette[ownerState.color].mainChannel} / 0.7)` : alpha(theme.palette[ownerState.color].main, 0.7)}`,
                    [`&.${chipClasses$1.clickable}:hover`]: {
                        backgroundColor: theme.vars
                            ? `rgba(${theme.vars.palette[ownerState.color].mainChannel} / ${theme.vars.palette.action.hoverOpacity})`
                            : alpha(theme.palette[ownerState.color].main, theme.palette.action.hoverOpacity),
                    },
                    [`&.${chipClasses$1.focusVisible}`]: {
                        backgroundColor: theme.vars
                            ? `rgba(${theme.vars.palette[ownerState.color].mainChannel} / ${theme.vars.palette.action.focusOpacity})`
                            : alpha(theme.palette[ownerState.color].main, theme.palette.action.focusOpacity),
                    },
                    [`& .${chipClasses$1.deleteIcon}`]: {
                        color: theme.vars ? `rgba(${theme.vars.palette[ownerState.color].mainChannel} / 0.7)` : alpha(theme.palette[ownerState.color].main, 0.7),
                        "&:hover, &:active": {
                            color: (theme.vars || theme).palette[ownerState.color].main,
                        },
                    },
                }
        )
);
const ChipLabel = styled$1("span", {
    name: "MuiChip",
    slot: "Label",
    overridesResolver: (props, styles2) => {
        const { ownerState } = props;
        const { size } = ownerState;
        return [styles2.label, styles2[`label${capitalize(size)}`]];
    },
})(({ ownerState }) =>
    _extends(
        {
            overflow: "hidden",
            textOverflow: "ellipsis",
            paddingLeft: 12,
            paddingRight: 12,
            whiteSpace: "nowrap",
        },
        ownerState.size === "small" && {
            paddingLeft: 8,
            paddingRight: 8,
        }
    )
);
function isDeleteKeyboardEvent(keyboardEvent) {
    return keyboardEvent.key === "Backspace" || keyboardEvent.key === "Delete";
}
const Chip = /* @__PURE__ */ reactExports.forwardRef(function Chip2(inProps, ref) {
    const props = useThemeProps({
        props: inProps,
        name: "MuiChip",
    });
    const {
            avatar: avatarProp,
            className,
            clickable: clickableProp,
            color: color2 = "default",
            component: ComponentProp,
            deleteIcon: deleteIconProp,
            disabled = false,
            icon: iconProp,
            label,
            onClick,
            onDelete,
            onKeyDown,
            onKeyUp,
            size = "medium",
            variant = "filled",
            tabIndex,
            skipFocusWhenDisabled = false,
        } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded$L);
    const chipRef = reactExports.useRef(null);
    const handleRef = useForkRef(chipRef, ref);
    const handleDeleteIconClick = (event) => {
        event.stopPropagation();
        if (onDelete) {
            onDelete(event);
        }
    };
    const handleKeyDown2 = (event) => {
        if (event.currentTarget === event.target && isDeleteKeyboardEvent(event)) {
            event.preventDefault();
        }
        if (onKeyDown) {
            onKeyDown(event);
        }
    };
    const handleKeyUp = (event) => {
        if (event.currentTarget === event.target) {
            if (onDelete && isDeleteKeyboardEvent(event)) {
                onDelete(event);
            } else if (event.key === "Escape" && chipRef.current) {
                chipRef.current.blur();
            }
        }
        if (onKeyUp) {
            onKeyUp(event);
        }
    };
    const clickable = clickableProp !== false && onClick ? true : clickableProp;
    const component = clickable || onDelete ? ButtonBase$1 : ComponentProp || "div";
    const ownerState = _extends({}, props, {
        component,
        disabled,
        size,
        color: color2,
        iconColor: /* @__PURE__ */ reactExports.isValidElement(iconProp) ? iconProp.props.color || color2 : color2,
        onDelete: !!onDelete,
        clickable,
        variant,
    });
    const classes = useUtilityClasses$D(ownerState);
    const moreProps =
        component === ButtonBase$1
            ? _extends(
                  {
                      component: ComponentProp || "div",
                      focusVisibleClassName: classes.focusVisible,
                  },
                  onDelete && {
                      disableRipple: true,
                  }
              )
            : {};
    let deleteIcon = null;
    if (onDelete) {
        deleteIcon =
            deleteIconProp && /* @__PURE__ */ reactExports.isValidElement(deleteIconProp)
                ? /* @__PURE__ */ reactExports.cloneElement(deleteIconProp, {
                      className: clsx$1(deleteIconProp.props.className, classes.deleteIcon),
                      onClick: handleDeleteIconClick,
                  })
                : /* @__PURE__ */ jsxRuntimeExports.jsx(CancelIcon, {
                      className: clsx$1(classes.deleteIcon),
                      onClick: handleDeleteIconClick,
                  });
    }
    let avatar = null;
    if (avatarProp && /* @__PURE__ */ reactExports.isValidElement(avatarProp)) {
        avatar = /* @__PURE__ */ reactExports.cloneElement(avatarProp, {
            className: clsx$1(classes.avatar, avatarProp.props.className),
        });
    }
    let icon = null;
    if (iconProp && /* @__PURE__ */ reactExports.isValidElement(iconProp)) {
        icon = /* @__PURE__ */ reactExports.cloneElement(iconProp, {
            className: clsx$1(classes.icon, iconProp.props.className),
        });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        ChipRoot,
        _extends(
            {
                as: component,
                className: clsx$1(classes.root, className),
                disabled: clickable && disabled ? true : void 0,
                onClick,
                onKeyDown: handleKeyDown2,
                onKeyUp: handleKeyUp,
                ref: handleRef,
                tabIndex: skipFocusWhenDisabled && disabled ? -1 : tabIndex,
                ownerState,
            },
            moreProps,
            other,
            {
                children: [
                    avatar || icon,
                    /* @__PURE__ */ jsxRuntimeExports.jsx(ChipLabel, {
                        className: clsx$1(classes.label),
                        ownerState,
                        children: label,
                    }),
                    deleteIcon,
                ],
            }
        )
    );
});
const Chip$1 = Chip;
function formControlState({ props, states, muiFormControl }) {
    return states.reduce((acc, state) => {
        acc[state] = props[state];
        if (muiFormControl) {
            if (typeof props[state] === "undefined") {
                acc[state] = muiFormControl[state];
            }
        }
        return acc;
    }, {});
}
const FormControlContext = /* @__PURE__ */ reactExports.createContext(void 0);
const FormControlContext$1 = FormControlContext;
function useFormControl() {
    return reactExports.useContext(FormControlContext$1);
}
function GlobalStyles(props) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
        GlobalStyles$1,
        _extends({}, props, {
            defaultTheme: defaultTheme$2,
            themeId: THEME_ID,
        })
    );
}
function hasValue(value) {
    return value != null && !(Array.isArray(value) && value.length === 0);
}
function isFilled(obj, SSR = false) {
    return obj && ((hasValue(obj.value) && obj.value !== "") || (SSR && hasValue(obj.defaultValue) && obj.defaultValue !== ""));
}
function isAdornedStart(obj) {
    return obj.startAdornment;
}
function getInputBaseUtilityClass(slot) {
    return generateUtilityClass("MuiInputBase", slot);
}
const inputBaseClasses = generateUtilityClasses("MuiInputBase", [
    "root",
    "formControl",
    "focused",
    "disabled",
    "adornedStart",
    "adornedEnd",
    "error",
    "sizeSmall",
    "multiline",
    "colorSecondary",
    "fullWidth",
    "hiddenLabel",
    "readOnly",
    "input",
    "inputSizeSmall",
    "inputMultiline",
    "inputTypeSearch",
    "inputAdornedStart",
    "inputAdornedEnd",
    "inputHiddenLabel",
]);
const inputBaseClasses$1 = inputBaseClasses;
const _excluded$K = [
    "aria-describedby",
    "autoComplete",
    "autoFocus",
    "className",
    "color",
    "components",
    "componentsProps",
    "defaultValue",
    "disabled",
    "disableInjectingGlobalStyles",
    "endAdornment",
    "error",
    "fullWidth",
    "id",
    "inputComponent",
    "inputProps",
    "inputRef",
    "margin",
    "maxRows",
    "minRows",
    "multiline",
    "name",
    "onBlur",
    "onChange",
    "onClick",
    "onFocus",
    "onKeyDown",
    "onKeyUp",
    "placeholder",
    "readOnly",
    "renderSuffix",
    "rows",
    "size",
    "slotProps",
    "slots",
    "startAdornment",
    "type",
    "value",
];
const rootOverridesResolver = (props, styles2) => {
    const { ownerState } = props;
    return [
        styles2.root,
        ownerState.formControl && styles2.formControl,
        ownerState.startAdornment && styles2.adornedStart,
        ownerState.endAdornment && styles2.adornedEnd,
        ownerState.error && styles2.error,
        ownerState.size === "small" && styles2.sizeSmall,
        ownerState.multiline && styles2.multiline,
        ownerState.color && styles2[`color${capitalize(ownerState.color)}`],
        ownerState.fullWidth && styles2.fullWidth,
        ownerState.hiddenLabel && styles2.hiddenLabel,
    ];
};
const inputOverridesResolver = (props, styles2) => {
    const { ownerState } = props;
    return [
        styles2.input,
        ownerState.size === "small" && styles2.inputSizeSmall,
        ownerState.multiline && styles2.inputMultiline,
        ownerState.type === "search" && styles2.inputTypeSearch,
        ownerState.startAdornment && styles2.inputAdornedStart,
        ownerState.endAdornment && styles2.inputAdornedEnd,
        ownerState.hiddenLabel && styles2.inputHiddenLabel,
    ];
};
const useUtilityClasses$C = (ownerState) => {
    const { classes, color: color2, disabled, error, endAdornment, focused, formControl, fullWidth, hiddenLabel, multiline, readOnly, size, startAdornment, type } = ownerState;
    const slots = {
        root: [
            "root",
            `color${capitalize(color2)}`,
            disabled && "disabled",
            error && "error",
            fullWidth && "fullWidth",
            focused && "focused",
            formControl && "formControl",
            size === "small" && "sizeSmall",
            multiline && "multiline",
            startAdornment && "adornedStart",
            endAdornment && "adornedEnd",
            hiddenLabel && "hiddenLabel",
            readOnly && "readOnly",
        ],
        input: [
            "input",
            disabled && "disabled",
            type === "search" && "inputTypeSearch",
            multiline && "inputMultiline",
            size === "small" && "inputSizeSmall",
            hiddenLabel && "inputHiddenLabel",
            startAdornment && "inputAdornedStart",
            endAdornment && "inputAdornedEnd",
            readOnly && "readOnly",
        ],
    };
    return composeClasses(slots, getInputBaseUtilityClass, classes);
};
const InputBaseRoot = styled$1("div", {
    name: "MuiInputBase",
    slot: "Root",
    overridesResolver: rootOverridesResolver,
})(({ theme, ownerState }) =>
    _extends(
        {},
        theme.typography.body1,
        {
            color: (theme.vars || theme).palette.text.primary,
            lineHeight: "1.4375em",
            // 23px
            boxSizing: "border-box",
            // Prevent padding issue with fullWidth.
            position: "relative",
            cursor: "text",
            display: "inline-flex",
            alignItems: "center",
            [`&.${inputBaseClasses$1.disabled}`]: {
                color: (theme.vars || theme).palette.text.disabled,
                cursor: "default",
            },
        },
        ownerState.multiline &&
            _extends(
                {
                    padding: "4px 0 5px",
                },
                ownerState.size === "small" && {
                    paddingTop: 1,
                }
            ),
        ownerState.fullWidth && {
            width: "100%",
        }
    )
);
const InputBaseComponent = styled$1("input", {
    name: "MuiInputBase",
    slot: "Input",
    overridesResolver: inputOverridesResolver,
})(({ theme, ownerState }) => {
    const light2 = theme.palette.mode === "light";
    const placeholder = _extends(
        {
            color: "currentColor",
        },
        theme.vars
            ? {
                  opacity: theme.vars.opacity.inputPlaceholder,
              }
            : {
                  opacity: light2 ? 0.42 : 0.5,
              },
        {
            transition: theme.transitions.create("opacity", {
                duration: theme.transitions.duration.shorter,
            }),
        }
    );
    const placeholderHidden = {
        opacity: "0 !important",
    };
    const placeholderVisible = theme.vars
        ? {
              opacity: theme.vars.opacity.inputPlaceholder,
          }
        : {
              opacity: light2 ? 0.42 : 0.5,
          };
    return _extends(
        {
            font: "inherit",
            letterSpacing: "inherit",
            color: "currentColor",
            padding: "4px 0 5px",
            border: 0,
            boxSizing: "content-box",
            background: "none",
            height: "1.4375em",
            // Reset 23pxthe native input line-height
            margin: 0,
            // Reset for Safari
            WebkitTapHighlightColor: "transparent",
            display: "block",
            // Make the flex item shrink with Firefox
            minWidth: 0,
            width: "100%",
            // Fix IE11 width issue
            animationName: "mui-auto-fill-cancel",
            animationDuration: "10ms",
            "&::-webkit-input-placeholder": placeholder,
            "&::-moz-placeholder": placeholder,
            // Firefox 19+
            "&:-ms-input-placeholder": placeholder,
            // IE11
            "&::-ms-input-placeholder": placeholder,
            // Edge
            "&:focus": {
                outline: 0,
            },
            // Reset Firefox invalid required input style
            "&:invalid": {
                boxShadow: "none",
            },
            "&::-webkit-search-decoration": {
                // Remove the padding when type=search.
                WebkitAppearance: "none",
            },
            // Show and hide the placeholder logic
            [`label[data-shrink=false] + .${inputBaseClasses$1.formControl} &`]: {
                "&::-webkit-input-placeholder": placeholderHidden,
                "&::-moz-placeholder": placeholderHidden,
                // Firefox 19+
                "&:-ms-input-placeholder": placeholderHidden,
                // IE11
                "&::-ms-input-placeholder": placeholderHidden,
                // Edge
                "&:focus::-webkit-input-placeholder": placeholderVisible,
                "&:focus::-moz-placeholder": placeholderVisible,
                // Firefox 19+
                "&:focus:-ms-input-placeholder": placeholderVisible,
                // IE11
                "&:focus::-ms-input-placeholder": placeholderVisible,
                // Edge
            },
            [`&.${inputBaseClasses$1.disabled}`]: {
                opacity: 1,
                // Reset iOS opacity
                WebkitTextFillColor: (theme.vars || theme).palette.text.disabled,
                // Fix opacity Safari bug
            },
            "&:-webkit-autofill": {
                animationDuration: "5000s",
                animationName: "mui-auto-fill",
            },
        },
        ownerState.size === "small" && {
            paddingTop: 1,
        },
        ownerState.multiline && {
            height: "auto",
            resize: "none",
            padding: 0,
            paddingTop: 0,
        },
        ownerState.type === "search" && {
            // Improve type search style.
            MozAppearance: "textfield",
        }
    );
});
const inputGlobalStyles = /* @__PURE__ */ jsxRuntimeExports.jsx(GlobalStyles, {
    styles: {
        "@keyframes mui-auto-fill": {
            from: {
                display: "block",
            },
        },
        "@keyframes mui-auto-fill-cancel": {
            from: {
                display: "block",
            },
        },
    },
});
const InputBase = /* @__PURE__ */ reactExports.forwardRef(function InputBase2(inProps, ref) {
    var _slotProps$input;
    const props = useThemeProps({
        props: inProps,
        name: "MuiInputBase",
    });
    const {
            "aria-describedby": ariaDescribedby,
            autoComplete,
            autoFocus,
            className,
            components = {},
            componentsProps = {},
            defaultValue,
            disabled,
            disableInjectingGlobalStyles,
            endAdornment,
            fullWidth = false,
            id,
            inputComponent = "input",
            inputProps: inputPropsProp = {},
            inputRef: inputRefProp,
            maxRows,
            minRows,
            multiline = false,
            name,
            onBlur,
            onChange,
            onClick,
            onFocus,
            onKeyDown,
            onKeyUp,
            placeholder,
            readOnly,
            renderSuffix,
            rows,
            slotProps = {},
            slots = {},
            startAdornment,
            type = "text",
            value: valueProp,
        } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded$K);
    const value = inputPropsProp.value != null ? inputPropsProp.value : valueProp;
    const { current: isControlled } = reactExports.useRef(value != null);
    const inputRef = reactExports.useRef();
    const handleInputRefWarning = reactExports.useCallback((instance) => {}, []);
    const handleInputRef = useForkRef(inputRef, inputRefProp, inputPropsProp.ref, handleInputRefWarning);
    const [focused, setFocused] = reactExports.useState(false);
    const muiFormControl = useFormControl();
    const fcs = formControlState({
        props,
        muiFormControl,
        states: ["color", "disabled", "error", "hiddenLabel", "size", "required", "filled"],
    });
    fcs.focused = muiFormControl ? muiFormControl.focused : focused;
    reactExports.useEffect(() => {
        if (!muiFormControl && disabled && focused) {
            setFocused(false);
            if (onBlur) {
                onBlur();
            }
        }
    }, [muiFormControl, disabled, focused, onBlur]);
    const onFilled = muiFormControl && muiFormControl.onFilled;
    const onEmpty = muiFormControl && muiFormControl.onEmpty;
    const checkDirty = reactExports.useCallback(
        (obj) => {
            if (isFilled(obj)) {
                if (onFilled) {
                    onFilled();
                }
            } else if (onEmpty) {
                onEmpty();
            }
        },
        [onFilled, onEmpty]
    );
    useEnhancedEffect$1(() => {
        if (isControlled) {
            checkDirty({
                value,
            });
        }
    }, [value, checkDirty, isControlled]);
    const handleFocus = (event) => {
        if (fcs.disabled) {
            event.stopPropagation();
            return;
        }
        if (onFocus) {
            onFocus(event);
        }
        if (inputPropsProp.onFocus) {
            inputPropsProp.onFocus(event);
        }
        if (muiFormControl && muiFormControl.onFocus) {
            muiFormControl.onFocus(event);
        } else {
            setFocused(true);
        }
    };
    const handleBlur = (event) => {
        if (onBlur) {
            onBlur(event);
        }
        if (inputPropsProp.onBlur) {
            inputPropsProp.onBlur(event);
        }
        if (muiFormControl && muiFormControl.onBlur) {
            muiFormControl.onBlur(event);
        } else {
            setFocused(false);
        }
    };
    const handleChange = (event, ...args) => {
        if (!isControlled) {
            const element = event.target || inputRef.current;
            if (element == null) {
                throw new Error(formatMuiErrorMessage(1));
            }
            checkDirty({
                value: element.value,
            });
        }
        if (inputPropsProp.onChange) {
            inputPropsProp.onChange(event, ...args);
        }
        if (onChange) {
            onChange(event, ...args);
        }
    };
    reactExports.useEffect(() => {
        checkDirty(inputRef.current);
    }, []);
    const handleClick = (event) => {
        if (inputRef.current && event.currentTarget === event.target) {
            inputRef.current.focus();
        }
        if (onClick) {
            onClick(event);
        }
    };
    let InputComponent = inputComponent;
    let inputProps = inputPropsProp;
    if (multiline && InputComponent === "input") {
        if (rows) {
            inputProps = _extends(
                {
                    type: void 0,
                    minRows: rows,
                    maxRows: rows,
                },
                inputProps
            );
        } else {
            inputProps = _extends(
                {
                    type: void 0,
                    maxRows,
                    minRows,
                },
                inputProps
            );
        }
        InputComponent = TextareaAutosize$1;
    }
    const handleAutoFill = (event) => {
        checkDirty(
            event.animationName === "mui-auto-fill-cancel"
                ? inputRef.current
                : {
                      value: "x",
                  }
        );
    };
    reactExports.useEffect(() => {
        if (muiFormControl) {
            muiFormControl.setAdornedStart(Boolean(startAdornment));
        }
    }, [muiFormControl, startAdornment]);
    const ownerState = _extends({}, props, {
        color: fcs.color || "primary",
        disabled: fcs.disabled,
        endAdornment,
        error: fcs.error,
        focused: fcs.focused,
        formControl: muiFormControl,
        fullWidth,
        hiddenLabel: fcs.hiddenLabel,
        multiline,
        size: fcs.size,
        startAdornment,
        type,
    });
    const classes = useUtilityClasses$C(ownerState);
    const Root = slots.root || components.Root || InputBaseRoot;
    const rootProps = slotProps.root || componentsProps.root || {};
    const Input3 = slots.input || components.Input || InputBaseComponent;
    inputProps = _extends({}, inputProps, (_slotProps$input = slotProps.input) != null ? _slotProps$input : componentsProps.input);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
        children: [
            !disableInjectingGlobalStyles && inputGlobalStyles,
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
                Root,
                _extends(
                    {},
                    rootProps,
                    !isHostComponent(Root) && {
                        ownerState: _extends({}, ownerState, rootProps.ownerState),
                    },
                    {
                        ref,
                        onClick: handleClick,
                    },
                    other,
                    {
                        className: clsx$1(classes.root, rootProps.className, className, readOnly && "MuiInputBase-readOnly"),
                        children: [
                            startAdornment,
                            /* @__PURE__ */ jsxRuntimeExports.jsx(FormControlContext$1.Provider, {
                                value: null,
                                children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                                    Input3,
                                    _extends(
                                        {
                                            ownerState,
                                            "aria-invalid": fcs.error,
                                            "aria-describedby": ariaDescribedby,
                                            autoComplete,
                                            autoFocus,
                                            defaultValue,
                                            disabled: fcs.disabled,
                                            id,
                                            onAnimationStart: handleAutoFill,
                                            name,
                                            placeholder,
                                            readOnly,
                                            required: fcs.required,
                                            rows,
                                            value,
                                            onKeyDown,
                                            onKeyUp,
                                            type,
                                        },
                                        inputProps,
                                        !isHostComponent(Input3) && {
                                            as: InputComponent,
                                            ownerState: _extends({}, ownerState, inputProps.ownerState),
                                        },
                                        {
                                            ref: handleInputRef,
                                            className: clsx$1(classes.input, inputProps.className, readOnly && "MuiInputBase-readOnly"),
                                            onBlur: handleBlur,
                                            onChange: handleChange,
                                            onFocus: handleFocus,
                                        }
                                    )
                                ),
                            }),
                            endAdornment,
                            renderSuffix
                                ? renderSuffix(
                                      _extends({}, fcs, {
                                          startAdornment,
                                      })
                                  )
                                : null,
                        ],
                    }
                )
            ),
        ],
    });
});
const InputBase$1 = InputBase;
function getInputUtilityClass(slot) {
    return generateUtilityClass("MuiInput", slot);
}
const inputClasses = _extends({}, inputBaseClasses$1, generateUtilityClasses("MuiInput", ["root", "underline", "input"]));
const inputClasses$1 = inputClasses;
function getOutlinedInputUtilityClass(slot) {
    return generateUtilityClass("MuiOutlinedInput", slot);
}
const outlinedInputClasses = _extends({}, inputBaseClasses$1, generateUtilityClasses("MuiOutlinedInput", ["root", "notchedOutline", "input"]));
const outlinedInputClasses$1 = outlinedInputClasses;
function getFilledInputUtilityClass(slot) {
    return generateUtilityClass("MuiFilledInput", slot);
}
const filledInputClasses = _extends({}, inputBaseClasses$1, generateUtilityClasses("MuiFilledInput", ["root", "underline", "input"]));
const filledInputClasses$1 = filledInputClasses;
const ArrowDropDownIcon = createSvgIcon$1(
    /* @__PURE__ */ jsxRuntimeExports.jsx("path", {
        d: "M7 10l5 5 5-5z",
    }),
    "ArrowDropDown"
);
function getAutocompleteUtilityClass(slot) {
    return generateUtilityClass("MuiAutocomplete", slot);
}
const autocompleteClasses = generateUtilityClasses("MuiAutocomplete", [
    "root",
    "expanded",
    "fullWidth",
    "focused",
    "focusVisible",
    "tag",
    "tagSizeSmall",
    "tagSizeMedium",
    "hasPopupIcon",
    "hasClearIcon",
    "inputRoot",
    "input",
    "inputFocused",
    "endAdornment",
    "clearIndicator",
    "popupIndicator",
    "popupIndicatorOpen",
    "popper",
    "popperDisablePortal",
    "paper",
    "listbox",
    "loading",
    "noOptions",
    "option",
    "groupLabel",
    "groupUl",
]);
const autocompleteClasses$1 = autocompleteClasses;
var _ClearIcon, _ArrowDropDownIcon;
const _excluded$J = [
    "autoComplete",
    "autoHighlight",
    "autoSelect",
    "blurOnSelect",
    "ChipProps",
    "className",
    "clearIcon",
    "clearOnBlur",
    "clearOnEscape",
    "clearText",
    "closeText",
    "componentsProps",
    "defaultValue",
    "disableClearable",
    "disableCloseOnSelect",
    "disabled",
    "disabledItemsFocusable",
    "disableListWrap",
    "disablePortal",
    "filterOptions",
    "filterSelectedOptions",
    "forcePopupIcon",
    "freeSolo",
    "fullWidth",
    "getLimitTagsText",
    "getOptionDisabled",
    "getOptionLabel",
    "isOptionEqualToValue",
    "groupBy",
    "handleHomeEndKeys",
    "id",
    "includeInputInList",
    "inputValue",
    "limitTags",
    "ListboxComponent",
    "ListboxProps",
    "loading",
    "loadingText",
    "multiple",
    "noOptionsText",
    "onChange",
    "onClose",
    "onHighlightChange",
    "onInputChange",
    "onOpen",
    "open",
    "openOnFocus",
    "openText",
    "options",
    "PaperComponent",
    "PopperComponent",
    "popupIcon",
    "readOnly",
    "renderGroup",
    "renderInput",
    "renderOption",
    "renderTags",
    "selectOnFocus",
    "size",
    "slotProps",
    "value",
];
const useUtilityClasses$B = (ownerState) => {
    const { classes, disablePortal, expanded, focused, fullWidth, hasClearIcon, hasPopupIcon, inputFocused, popupOpen, size } = ownerState;
    const slots = {
        root: ["root", expanded && "expanded", focused && "focused", fullWidth && "fullWidth", hasClearIcon && "hasClearIcon", hasPopupIcon && "hasPopupIcon"],
        inputRoot: ["inputRoot"],
        input: ["input", inputFocused && "inputFocused"],
        tag: ["tag", `tagSize${capitalize(size)}`],
        endAdornment: ["endAdornment"],
        clearIndicator: ["clearIndicator"],
        popupIndicator: ["popupIndicator", popupOpen && "popupIndicatorOpen"],
        popper: ["popper", disablePortal && "popperDisablePortal"],
        paper: ["paper"],
        listbox: ["listbox"],
        loading: ["loading"],
        noOptions: ["noOptions"],
        option: ["option"],
        groupLabel: ["groupLabel"],
        groupUl: ["groupUl"],
    };
    return composeClasses(slots, getAutocompleteUtilityClass, classes);
};
const AutocompleteRoot = styled$1("div", {
    name: "MuiAutocomplete",
    slot: "Root",
    overridesResolver: (props, styles2) => {
        const { ownerState } = props;
        const { fullWidth, hasClearIcon, hasPopupIcon, inputFocused, size } = ownerState;
        return [
            {
                [`& .${autocompleteClasses$1.tag}`]: styles2.tag,
            },
            {
                [`& .${autocompleteClasses$1.tag}`]: styles2[`tagSize${capitalize(size)}`],
            },
            {
                [`& .${autocompleteClasses$1.inputRoot}`]: styles2.inputRoot,
            },
            {
                [`& .${autocompleteClasses$1.input}`]: styles2.input,
            },
            {
                [`& .${autocompleteClasses$1.input}`]: inputFocused && styles2.inputFocused,
            },
            styles2.root,
            fullWidth && styles2.fullWidth,
            hasPopupIcon && styles2.hasPopupIcon,
            hasClearIcon && styles2.hasClearIcon,
        ];
    },
})(({ ownerState }) =>
    _extends(
        {
            [`&.${autocompleteClasses$1.focused} .${autocompleteClasses$1.clearIndicator}`]: {
                visibility: "visible",
            },
            /* Avoid double tap issue on iOS */
            "@media (pointer: fine)": {
                [`&:hover .${autocompleteClasses$1.clearIndicator}`]: {
                    visibility: "visible",
                },
            },
        },
        ownerState.fullWidth && {
            width: "100%",
        },
        {
            [`& .${autocompleteClasses$1.tag}`]: _extends(
                {
                    margin: 3,
                    maxWidth: "calc(100% - 6px)",
                },
                ownerState.size === "small" && {
                    margin: 2,
                    maxWidth: "calc(100% - 4px)",
                }
            ),
            [`& .${autocompleteClasses$1.inputRoot}`]: {
                flexWrap: "wrap",
                [`.${autocompleteClasses$1.hasPopupIcon}&, .${autocompleteClasses$1.hasClearIcon}&`]: {
                    paddingRight: 26 + 4,
                },
                [`.${autocompleteClasses$1.hasPopupIcon}.${autocompleteClasses$1.hasClearIcon}&`]: {
                    paddingRight: 52 + 4,
                },
                [`& .${autocompleteClasses$1.input}`]: {
                    width: 0,
                    minWidth: 30,
                },
            },
            [`& .${inputClasses$1.root}`]: {
                paddingBottom: 1,
                "& .MuiInput-input": {
                    padding: "4px 4px 4px 0px",
                },
            },
            [`& .${inputClasses$1.root}.${inputBaseClasses$1.sizeSmall}`]: {
                [`& .${inputClasses$1.input}`]: {
                    padding: "2px 4px 3px 0",
                },
            },
            [`& .${outlinedInputClasses$1.root}`]: {
                padding: 9,
                [`.${autocompleteClasses$1.hasPopupIcon}&, .${autocompleteClasses$1.hasClearIcon}&`]: {
                    paddingRight: 26 + 4 + 9,
                },
                [`.${autocompleteClasses$1.hasPopupIcon}.${autocompleteClasses$1.hasClearIcon}&`]: {
                    paddingRight: 52 + 4 + 9,
                },
                [`& .${autocompleteClasses$1.input}`]: {
                    padding: "7.5px 4px 7.5px 5px",
                },
                [`& .${autocompleteClasses$1.endAdornment}`]: {
                    right: 9,
                },
            },
            [`& .${outlinedInputClasses$1.root}.${inputBaseClasses$1.sizeSmall}`]: {
                // Don't specify paddingRight, as it overrides the default value set when there is only
                // one of the popup or clear icon as the specificity is equal so the latter one wins
                paddingTop: 6,
                paddingBottom: 6,
                paddingLeft: 6,
                [`& .${autocompleteClasses$1.input}`]: {
                    padding: "2.5px 4px 2.5px 8px",
                },
            },
            [`& .${filledInputClasses$1.root}`]: {
                paddingTop: 19,
                paddingLeft: 8,
                [`.${autocompleteClasses$1.hasPopupIcon}&, .${autocompleteClasses$1.hasClearIcon}&`]: {
                    paddingRight: 26 + 4 + 9,
                },
                [`.${autocompleteClasses$1.hasPopupIcon}.${autocompleteClasses$1.hasClearIcon}&`]: {
                    paddingRight: 52 + 4 + 9,
                },
                [`& .${filledInputClasses$1.input}`]: {
                    padding: "7px 4px",
                },
                [`& .${autocompleteClasses$1.endAdornment}`]: {
                    right: 9,
                },
            },
            [`& .${filledInputClasses$1.root}.${inputBaseClasses$1.sizeSmall}`]: {
                paddingBottom: 1,
                [`& .${filledInputClasses$1.input}`]: {
                    padding: "2.5px 4px",
                },
            },
            [`& .${inputBaseClasses$1.hiddenLabel}`]: {
                paddingTop: 8,
            },
            [`& .${filledInputClasses$1.root}.${inputBaseClasses$1.hiddenLabel}`]: {
                paddingTop: 0,
                paddingBottom: 0,
                [`& .${autocompleteClasses$1.input}`]: {
                    paddingTop: 16,
                    paddingBottom: 17,
                },
            },
            [`& .${filledInputClasses$1.root}.${inputBaseClasses$1.hiddenLabel}.${inputBaseClasses$1.sizeSmall}`]: {
                [`& .${autocompleteClasses$1.input}`]: {
                    paddingTop: 8,
                    paddingBottom: 9,
                },
            },
            [`& .${autocompleteClasses$1.input}`]: _extends(
                {
                    flexGrow: 1,
                    textOverflow: "ellipsis",
                    opacity: 0,
                },
                ownerState.inputFocused && {
                    opacity: 1,
                }
            ),
        }
    )
);
const AutocompleteEndAdornment = styled$1("div", {
    name: "MuiAutocomplete",
    slot: "EndAdornment",
    overridesResolver: (props, styles2) => styles2.endAdornment,
})({
    // We use a position absolute to support wrapping tags.
    position: "absolute",
    right: 0,
    top: "calc(50% - 14px)",
    // Center vertically
});
const AutocompleteClearIndicator = styled$1(IconButton$1, {
    name: "MuiAutocomplete",
    slot: "ClearIndicator",
    overridesResolver: (props, styles2) => styles2.clearIndicator,
})({
    marginRight: -2,
    padding: 4,
    visibility: "hidden",
});
const AutocompletePopupIndicator = styled$1(IconButton$1, {
    name: "MuiAutocomplete",
    slot: "PopupIndicator",
    overridesResolver: ({ ownerState }, styles2) => _extends({}, styles2.popupIndicator, ownerState.popupOpen && styles2.popupIndicatorOpen),
})(({ ownerState }) =>
    _extends(
        {
            padding: 2,
            marginRight: -2,
        },
        ownerState.popupOpen && {
            transform: "rotate(180deg)",
        }
    )
);
const AutocompletePopper = styled$1(Popper$1, {
    name: "MuiAutocomplete",
    slot: "Popper",
    overridesResolver: (props, styles2) => {
        const { ownerState } = props;
        return [
            {
                [`& .${autocompleteClasses$1.option}`]: styles2.option,
            },
            styles2.popper,
            ownerState.disablePortal && styles2.popperDisablePortal,
        ];
    },
})(({ theme, ownerState }) =>
    _extends(
        {
            zIndex: (theme.vars || theme).zIndex.modal,
        },
        ownerState.disablePortal && {
            position: "absolute",
        }
    )
);
const AutocompletePaper = styled$1(Paper$1, {
    name: "MuiAutocomplete",
    slot: "Paper",
    overridesResolver: (props, styles2) => styles2.paper,
})(({ theme }) =>
    _extends({}, theme.typography.body1, {
        overflow: "auto",
    })
);
const AutocompleteLoading = styled$1("div", {
    name: "MuiAutocomplete",
    slot: "Loading",
    overridesResolver: (props, styles2) => styles2.loading,
})(({ theme }) => ({
    color: (theme.vars || theme).palette.text.secondary,
    padding: "14px 16px",
}));
const AutocompleteNoOptions = styled$1("div", {
    name: "MuiAutocomplete",
    slot: "NoOptions",
    overridesResolver: (props, styles2) => styles2.noOptions,
})(({ theme }) => ({
    color: (theme.vars || theme).palette.text.secondary,
    padding: "14px 16px",
}));
const AutocompleteListbox = styled$1("div", {
    name: "MuiAutocomplete",
    slot: "Listbox",
    overridesResolver: (props, styles2) => styles2.listbox,
})(({ theme }) => ({
    listStyle: "none",
    margin: 0,
    padding: "8px 0",
    maxHeight: "40vh",
    overflow: "auto",
    position: "relative",
    [`& .${autocompleteClasses$1.option}`]: {
        minHeight: 48,
        display: "flex",
        overflow: "hidden",
        justifyContent: "flex-start",
        alignItems: "center",
        cursor: "pointer",
        paddingTop: 6,
        boxSizing: "border-box",
        outline: "0",
        WebkitTapHighlightColor: "transparent",
        paddingBottom: 6,
        paddingLeft: 16,
        paddingRight: 16,
        [theme.breakpoints.up("sm")]: {
            minHeight: "auto",
        },
        [`&.${autocompleteClasses$1.focused}`]: {
            backgroundColor: (theme.vars || theme).palette.action.hover,
            // Reset on touch devices, it doesn't add specificity
            "@media (hover: none)": {
                backgroundColor: "transparent",
            },
        },
        '&[aria-disabled="true"]': {
            opacity: (theme.vars || theme).palette.action.disabledOpacity,
            pointerEvents: "none",
        },
        [`&.${autocompleteClasses$1.focusVisible}`]: {
            backgroundColor: (theme.vars || theme).palette.action.focus,
        },
        '&[aria-selected="true"]': {
            backgroundColor: theme.vars
                ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.selectedOpacity})`
                : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity),
            [`&.${autocompleteClasses$1.focused}`]: {
                backgroundColor: theme.vars
                    ? `rgba(${theme.vars.palette.primary.mainChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.hoverOpacity}))`
                    : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity + theme.palette.action.hoverOpacity),
                // Reset on touch devices, it doesn't add specificity
                "@media (hover: none)": {
                    backgroundColor: (theme.vars || theme).palette.action.selected,
                },
            },
            [`&.${autocompleteClasses$1.focusVisible}`]: {
                backgroundColor: theme.vars
                    ? `rgba(${theme.vars.palette.primary.mainChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.focusOpacity}))`
                    : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity + theme.palette.action.focusOpacity),
            },
        },
    },
}));
const AutocompleteGroupLabel = styled$1(ListSubheader$1, {
    name: "MuiAutocomplete",
    slot: "GroupLabel",
    overridesResolver: (props, styles2) => styles2.groupLabel,
})(({ theme }) => ({
    backgroundColor: (theme.vars || theme).palette.background.paper,
    top: -8,
}));
const AutocompleteGroupUl = styled$1("ul", {
    name: "MuiAutocomplete",
    slot: "GroupUl",
    overridesResolver: (props, styles2) => styles2.groupUl,
})({
    padding: 0,
    [`& .${autocompleteClasses$1.option}`]: {
        paddingLeft: 24,
    },
});
const Autocomplete = /* @__PURE__ */ reactExports.forwardRef(function Autocomplete2(inProps, ref) {
    var _slotProps$clearIndic, _slotProps$paper, _slotProps$popper, _slotProps$popupIndic;
    const props = useThemeProps({
        props: inProps,
        name: "MuiAutocomplete",
    });
    const {
            autoComplete = false,
            autoHighlight = false,
            autoSelect = false,
            blurOnSelect = false,
            ChipProps,
            className,
            clearIcon = _ClearIcon ||
                (_ClearIcon = /* @__PURE__ */ jsxRuntimeExports.jsx(ClearIcon, {
                    fontSize: "small",
                })),
            clearOnBlur = !props.freeSolo,
            clearOnEscape = false,
            clearText = "Clear",
            closeText = "Close",
            componentsProps = {},
            defaultValue = props.multiple ? [] : null,
            disableClearable = false,
            disableCloseOnSelect = false,
            disabled = false,
            disabledItemsFocusable = false,
            disableListWrap = false,
            disablePortal = false,
            filterSelectedOptions = false,
            forcePopupIcon = "auto",
            freeSolo = false,
            fullWidth = false,
            getLimitTagsText = (more) => `+${more}`,
            getOptionLabel = (option) => {
                var _option$label;
                return (_option$label = option.label) != null ? _option$label : option;
            },
            groupBy,
            handleHomeEndKeys = !props.freeSolo,
            includeInputInList = false,
            limitTags = -1,
            ListboxComponent = "ul",
            ListboxProps,
            loading: loading2 = false,
            loadingText = "Loading",
            multiple = false,
            noOptionsText = "No options",
            openOnFocus = false,
            openText = "Open",
            PaperComponent = Paper$1,
            PopperComponent = Popper$1,
            popupIcon = _ArrowDropDownIcon || (_ArrowDropDownIcon = /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowDropDownIcon, {})),
            readOnly = false,
            renderGroup: renderGroupProp,
            renderInput,
            renderOption: renderOptionProp,
            renderTags,
            selectOnFocus = !props.freeSolo,
            size = "medium",
            slotProps = {},
        } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded$J);
    const {
        getRootProps,
        getInputProps,
        getInputLabelProps,
        getPopupIndicatorProps,
        getClearProps,
        getTagProps,
        getListboxProps,
        getOptionProps,
        value,
        dirty,
        expanded,
        id,
        popupOpen,
        focused,
        focusedTag,
        anchorEl,
        setAnchorEl,
        inputValue,
        groupedOptions,
    } = useAutocomplete(
        _extends({}, props, {
            componentName: "Autocomplete",
        })
    );
    const hasClearIcon = !disableClearable && !disabled && dirty && !readOnly;
    const hasPopupIcon = (!freeSolo || forcePopupIcon === true) && forcePopupIcon !== false;
    const { onMouseDown: handleInputMouseDown } = getInputProps();
    const ownerState = _extends({}, props, {
        disablePortal,
        expanded,
        focused,
        fullWidth,
        hasClearIcon,
        hasPopupIcon,
        inputFocused: focusedTag === -1,
        popupOpen,
        size,
    });
    const classes = useUtilityClasses$B(ownerState);
    let startAdornment;
    if (multiple && value.length > 0) {
        const getCustomizedTagProps = (params) =>
            _extends(
                {
                    className: classes.tag,
                    disabled,
                },
                getTagProps(params)
            );
        if (renderTags) {
            startAdornment = renderTags(value, getCustomizedTagProps, ownerState);
        } else {
            startAdornment = value.map((option, index) =>
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Chip$1,
                    _extends(
                        {
                            label: getOptionLabel(option),
                            size,
                        },
                        getCustomizedTagProps({
                            index,
                        }),
                        ChipProps
                    )
                )
            );
        }
    }
    if (limitTags > -1 && Array.isArray(startAdornment)) {
        const more = startAdornment.length - limitTags;
        if (!focused && more > 0) {
            startAdornment = startAdornment.splice(0, limitTags);
            startAdornment.push(
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "span",
                    {
                        className: classes.tag,
                        children: getLimitTagsText(more),
                    },
                    startAdornment.length
                )
            );
        }
    }
    const defaultRenderGroup = (params) =>
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "li",
            {
                children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(AutocompleteGroupLabel, {
                        className: classes.groupLabel,
                        ownerState,
                        component: "div",
                        children: params.group,
                    }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(AutocompleteGroupUl, {
                        className: classes.groupUl,
                        ownerState,
                        children: params.children,
                    }),
                ],
            },
            params.key
        );
    const renderGroup = renderGroupProp || defaultRenderGroup;
    const defaultRenderOption = (props2, option) =>
        /* @__PURE__ */ jsxRuntimeExports.jsx(
            "li",
            _extends({}, props2, {
                children: getOptionLabel(option),
            })
        );
    const renderOption = renderOptionProp || defaultRenderOption;
    const renderListOption = (option, index) => {
        const optionProps = getOptionProps({
            option,
            index,
        });
        return renderOption(
            _extends({}, optionProps, {
                className: classes.option,
            }),
            option,
            {
                selected: optionProps["aria-selected"],
                index,
                inputValue,
            }
        );
    };
    const clearIndicatorSlotProps = (_slotProps$clearIndic = slotProps.clearIndicator) != null ? _slotProps$clearIndic : componentsProps.clearIndicator;
    const paperSlotProps = (_slotProps$paper = slotProps.paper) != null ? _slotProps$paper : componentsProps.paper;
    const popperSlotProps = (_slotProps$popper = slotProps.popper) != null ? _slotProps$popper : componentsProps.popper;
    const popupIndicatorSlotProps = (_slotProps$popupIndic = slotProps.popupIndicator) != null ? _slotProps$popupIndic : componentsProps.popupIndicator;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
        children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
                AutocompleteRoot,
                _extends(
                    {
                        ref,
                        className: clsx$1(classes.root, className),
                        ownerState,
                    },
                    getRootProps(other),
                    {
                        children: renderInput({
                            id,
                            disabled,
                            fullWidth: true,
                            size: size === "small" ? "small" : void 0,
                            InputLabelProps: getInputLabelProps(),
                            InputProps: _extends(
                                {
                                    ref: setAnchorEl,
                                    className: classes.inputRoot,
                                    startAdornment,
                                    onClick: (event) => {
                                        if (event.target === event.currentTarget) {
                                            handleInputMouseDown(event);
                                        }
                                    },
                                },
                                (hasClearIcon || hasPopupIcon) && {
                                    endAdornment: /* @__PURE__ */ jsxRuntimeExports.jsxs(AutocompleteEndAdornment, {
                                        className: classes.endAdornment,
                                        ownerState,
                                        children: [
                                            hasClearIcon
                                                ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                                                      AutocompleteClearIndicator,
                                                      _extends(
                                                          {},
                                                          getClearProps(),
                                                          {
                                                              "aria-label": clearText,
                                                              title: clearText,
                                                              ownerState,
                                                          },
                                                          clearIndicatorSlotProps,
                                                          {
                                                              className: clsx$1(classes.clearIndicator, clearIndicatorSlotProps == null ? void 0 : clearIndicatorSlotProps.className),
                                                              children: clearIcon,
                                                          }
                                                      )
                                                  )
                                                : null,
                                            hasPopupIcon
                                                ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                                                      AutocompletePopupIndicator,
                                                      _extends(
                                                          {},
                                                          getPopupIndicatorProps(),
                                                          {
                                                              disabled,
                                                              "aria-label": popupOpen ? closeText : openText,
                                                              title: popupOpen ? closeText : openText,
                                                              ownerState,
                                                          },
                                                          popupIndicatorSlotProps,
                                                          {
                                                              className: clsx$1(classes.popupIndicator, popupIndicatorSlotProps == null ? void 0 : popupIndicatorSlotProps.className),
                                                              children: popupIcon,
                                                          }
                                                      )
                                                  )
                                                : null,
                                        ],
                                    }),
                                }
                            ),
                            inputProps: _extends(
                                {
                                    className: classes.input,
                                    disabled,
                                    readOnly,
                                },
                                getInputProps()
                            ),
                        }),
                    }
                )
            ),
            anchorEl
                ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                      AutocompletePopper,
                      _extends(
                          {
                              as: PopperComponent,
                              disablePortal,
                              style: {
                                  width: anchorEl ? anchorEl.clientWidth : null,
                              },
                              ownerState,
                              role: "presentation",
                              anchorEl,
                              open: popupOpen,
                          },
                          popperSlotProps,
                          {
                              className: clsx$1(classes.popper, popperSlotProps == null ? void 0 : popperSlotProps.className),
                              children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
                                  AutocompletePaper,
                                  _extends(
                                      {
                                          ownerState,
                                          as: PaperComponent,
                                      },
                                      paperSlotProps,
                                      {
                                          className: clsx$1(classes.paper, paperSlotProps == null ? void 0 : paperSlotProps.className),
                                          children: [
                                              loading2 && groupedOptions.length === 0
                                                  ? /* @__PURE__ */ jsxRuntimeExports.jsx(AutocompleteLoading, {
                                                        className: classes.loading,
                                                        ownerState,
                                                        children: loadingText,
                                                    })
                                                  : null,
                                              groupedOptions.length === 0 && !freeSolo && !loading2
                                                  ? /* @__PURE__ */ jsxRuntimeExports.jsx(AutocompleteNoOptions, {
                                                        className: classes.noOptions,
                                                        ownerState,
                                                        role: "presentation",
                                                        onMouseDown: (event) => {
                                                            event.preventDefault();
                                                        },
                                                        children: noOptionsText,
                                                    })
                                                  : null,
                                              groupedOptions.length > 0
                                                  ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                                                        AutocompleteListbox,
                                                        _extends(
                                                            {
                                                                as: ListboxComponent,
                                                                className: classes.listbox,
                                                                ownerState,
                                                            },
                                                            getListboxProps(),
                                                            ListboxProps,
                                                            {
                                                                children: groupedOptions.map((option, index) => {
                                                                    if (groupBy) {
                                                                        return renderGroup({
                                                                            key: option.key,
                                                                            group: option.group,
                                                                            children: option.options.map((option2, index2) => renderListOption(option2, option.index + index2)),
                                                                        });
                                                                    }
                                                                    return renderListOption(option, index);
                                                                }),
                                                            }
                                                        )
                                                    )
                                                  : null,
                                          ],
                                      }
                                  )
                              ),
                          }
                      )
                  )
                : null,
        ],
    });
});
const Autocomplete$1 = Autocomplete;
const _excluded$I = ["addEndListener", "appear", "children", "easing", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "style", "timeout", "TransitionComponent"];
const styles$2 = {
    entering: {
        opacity: 1,
    },
    entered: {
        opacity: 1,
    },
};
const Fade = /* @__PURE__ */ reactExports.forwardRef(function Fade2(props, ref) {
    const theme = useTheme();
    const defaultTimeout = {
        enter: theme.transitions.duration.enteringScreen,
        exit: theme.transitions.duration.leavingScreen,
    };
    const {
            addEndListener,
            appear = true,
            children,
            easing: easing2,
            in: inProp,
            onEnter,
            onEntered,
            onEntering,
            onExit,
            onExited,
            onExiting,
            style: style2,
            timeout = defaultTimeout,
            // eslint-disable-next-line react/prop-types
            TransitionComponent = Transition,
        } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded$I);
    const nodeRef = reactExports.useRef(null);
    const handleRef = useForkRef(nodeRef, children.ref, ref);
    const normalizedTransitionCallback = (callback) => (maybeIsAppearing) => {
        if (callback) {
            const node2 = nodeRef.current;
            if (maybeIsAppearing === void 0) {
                callback(node2);
            } else {
                callback(node2, maybeIsAppearing);
            }
        }
    };
    const handleEntering = normalizedTransitionCallback(onEntering);
    const handleEnter = normalizedTransitionCallback((node2, isAppearing) => {
        reflow(node2);
        const transitionProps = getTransitionProps(
            {
                style: style2,
                timeout,
                easing: easing2,
            },
            {
                mode: "enter",
            }
        );
        node2.style.webkitTransition = theme.transitions.create("opacity", transitionProps);
        node2.style.transition = theme.transitions.create("opacity", transitionProps);
        if (onEnter) {
            onEnter(node2, isAppearing);
        }
    });
    const handleEntered = normalizedTransitionCallback(onEntered);
    const handleExiting = normalizedTransitionCallback(onExiting);
    const handleExit = normalizedTransitionCallback((node2) => {
        const transitionProps = getTransitionProps(
            {
                style: style2,
                timeout,
                easing: easing2,
            },
            {
                mode: "exit",
            }
        );
        node2.style.webkitTransition = theme.transitions.create("opacity", transitionProps);
        node2.style.transition = theme.transitions.create("opacity", transitionProps);
        if (onExit) {
            onExit(node2);
        }
    });
    const handleExited = normalizedTransitionCallback(onExited);
    const handleAddEndListener = (next2) => {
        if (addEndListener) {
            addEndListener(nodeRef.current, next2);
        }
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
        TransitionComponent,
        _extends(
            {
                appear,
                in: inProp,
                nodeRef,
                onEnter: handleEnter,
                onEntered: handleEntered,
                onEntering: handleEntering,
                onExit: handleExit,
                onExited: handleExited,
                onExiting: handleExiting,
                addEndListener: handleAddEndListener,
                timeout,
            },
            other,
            {
                children: (state, childProps) => {
                    return /* @__PURE__ */ reactExports.cloneElement(
                        children,
                        _extends(
                            {
                                style: _extends(
                                    {
                                        opacity: 0,
                                        visibility: state === "exited" && !inProp ? "hidden" : void 0,
                                    },
                                    styles$2[state],
                                    style2,
                                    children.props.style
                                ),
                                ref: handleRef,
                            },
                            childProps
                        )
                    );
                },
            }
        )
    );
});
const Fade$1 = Fade;
function getBackdropUtilityClass(slot) {
    return generateUtilityClass("MuiBackdrop", slot);
}
generateUtilityClasses("MuiBackdrop", ["root", "invisible"]);
const _excluded$H = ["children", "className", "component", "components", "componentsProps", "invisible", "open", "slotProps", "slots", "TransitionComponent", "transitionDuration"];
const useUtilityClasses$A = (ownerState) => {
    const { classes, invisible } = ownerState;
    const slots = {
        root: ["root", invisible && "invisible"],
    };
    return composeClasses(slots, getBackdropUtilityClass, classes);
};
const BackdropRoot = styled$1("div", {
    name: "MuiBackdrop",
    slot: "Root",
    overridesResolver: (props, styles2) => {
        const { ownerState } = props;
        return [styles2.root, ownerState.invisible && styles2.invisible];
    },
})(({ ownerState }) =>
    _extends(
        {
            position: "fixed",
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            right: 0,
            bottom: 0,
            top: 0,
            left: 0,
            backgroundColor: "rgba(0, 0, 0, 0.5)",
            WebkitTapHighlightColor: "transparent",
        },
        ownerState.invisible && {
            backgroundColor: "transparent",
        }
    )
);
const Backdrop = /* @__PURE__ */ reactExports.forwardRef(function Backdrop2(inProps, ref) {
    var _slotProps$root, _ref, _slots$root;
    const props = useThemeProps({
        props: inProps,
        name: "MuiBackdrop",
    });
    const {
            children,
            className,
            component = "div",
            components = {},
            componentsProps = {},
            invisible = false,
            open: open2,
            slotProps = {},
            slots = {},
            TransitionComponent = Fade$1,
            transitionDuration,
        } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded$H);
    const ownerState = _extends({}, props, {
        component,
        invisible,
    });
    const classes = useUtilityClasses$A(ownerState);
    const rootSlotProps = (_slotProps$root = slotProps.root) != null ? _slotProps$root : componentsProps.root;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
        TransitionComponent,
        _extends(
            {
                in: open2,
                timeout: transitionDuration,
            },
            other,
            {
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    BackdropRoot,
                    _extends(
                        {
                            "aria-hidden": true,
                        },
                        rootSlotProps,
                        {
                            as: (_ref = (_slots$root = slots.root) != null ? _slots$root : components.Root) != null ? _ref : component,
                            className: clsx$1(classes.root, className, rootSlotProps == null ? void 0 : rootSlotProps.className),
                            ownerState: _extends({}, ownerState, rootSlotProps == null ? void 0 : rootSlotProps.ownerState),
                            classes,
                            ref,
                            children,
                        }
                    )
                ),
            }
        )
    );
});
const Backdrop$1 = Backdrop;
const defaultTheme = createTheme();
const Box = createBox({
    themeId: THEME_ID,
    defaultTheme,
    defaultClassName: "MuiBox-root",
    generateClassName: ClassNameGenerator$1.generate,
});
const Box$1 = Box;
function getButtonUtilityClass(slot) {
    return generateUtilityClass("MuiButton", slot);
}
const buttonClasses = generateUtilityClasses("MuiButton", [
    "root",
    "text",
    "textInherit",
    "textPrimary",
    "textSecondary",
    "textSuccess",
    "textError",
    "textInfo",
    "textWarning",
    "outlined",
    "outlinedInherit",
    "outlinedPrimary",
    "outlinedSecondary",
    "outlinedSuccess",
    "outlinedError",
    "outlinedInfo",
    "outlinedWarning",
    "contained",
    "containedInherit",
    "containedPrimary",
    "containedSecondary",
    "containedSuccess",
    "containedError",
    "containedInfo",
    "containedWarning",
    "disableElevation",
    "focusVisible",
    "disabled",
    "colorInherit",
    "textSizeSmall",
    "textSizeMedium",
    "textSizeLarge",
    "outlinedSizeSmall",
    "outlinedSizeMedium",
    "outlinedSizeLarge",
    "containedSizeSmall",
    "containedSizeMedium",
    "containedSizeLarge",
    "sizeMedium",
    "sizeSmall",
    "sizeLarge",
    "fullWidth",
    "startIcon",
    "endIcon",
    "iconSizeSmall",
    "iconSizeMedium",
    "iconSizeLarge",
]);
const buttonClasses$1 = buttonClasses;
const ButtonGroupContext = /* @__PURE__ */ reactExports.createContext({});
const ButtonGroupContext$1 = ButtonGroupContext;
const _excluded$G = [
    "children",
    "color",
    "component",
    "className",
    "disabled",
    "disableElevation",
    "disableFocusRipple",
    "endIcon",
    "focusVisibleClassName",
    "fullWidth",
    "size",
    "startIcon",
    "type",
    "variant",
];
const useUtilityClasses$z = (ownerState) => {
    const { color: color2, disableElevation, fullWidth, size, variant, classes } = ownerState;
    const slots = {
        root: [
            "root",
            variant,
            `${variant}${capitalize(color2)}`,
            `size${capitalize(size)}`,
            `${variant}Size${capitalize(size)}`,
            color2 === "inherit" && "colorInherit",
            disableElevation && "disableElevation",
            fullWidth && "fullWidth",
        ],
        label: ["label"],
        startIcon: ["startIcon", `iconSize${capitalize(size)}`],
        endIcon: ["endIcon", `iconSize${capitalize(size)}`],
    };
    const composedClasses = composeClasses(slots, getButtonUtilityClass, classes);
    return _extends({}, classes, composedClasses);
};
const commonIconStyles = (ownerState) =>
    _extends(
        {},
        ownerState.size === "small" && {
            "& > *:nth-of-type(1)": {
                fontSize: 18,
            },
        },
        ownerState.size === "medium" && {
            "& > *:nth-of-type(1)": {
                fontSize: 20,
            },
        },
        ownerState.size === "large" && {
            "& > *:nth-of-type(1)": {
                fontSize: 22,
            },
        }
    );
const ButtonRoot = styled$1(ButtonBase$1, {
    shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
    name: "MuiButton",
    slot: "Root",
    overridesResolver: (props, styles2) => {
        const { ownerState } = props;
        return [
            styles2.root,
            styles2[ownerState.variant],
            styles2[`${ownerState.variant}${capitalize(ownerState.color)}`],
            styles2[`size${capitalize(ownerState.size)}`],
            styles2[`${ownerState.variant}Size${capitalize(ownerState.size)}`],
            ownerState.color === "inherit" && styles2.colorInherit,
            ownerState.disableElevation && styles2.disableElevation,
            ownerState.fullWidth && styles2.fullWidth,
        ];
    },
})(
    ({ theme, ownerState }) => {
        var _theme$palette$getCon, _theme$palette;
        const inheritContainedBackgroundColor = theme.palette.mode === "light" ? theme.palette.grey[300] : theme.palette.grey[800];
        const inheritContainedHoverBackgroundColor = theme.palette.mode === "light" ? theme.palette.grey.A100 : theme.palette.grey[700];
        return _extends(
            {},
            theme.typography.button,
            {
                minWidth: 64,
                padding: "6px 16px",
                borderRadius: (theme.vars || theme).shape.borderRadius,
                transition: theme.transitions.create(["background-color", "box-shadow", "border-color", "color"], {
                    duration: theme.transitions.duration.short,
                }),
                "&:hover": _extends(
                    {
                        textDecoration: "none",
                        backgroundColor: theme.vars
                            ? `rgba(${theme.vars.palette.text.primaryChannel} / ${theme.vars.palette.action.hoverOpacity})`
                            : alpha(theme.palette.text.primary, theme.palette.action.hoverOpacity),
                        // Reset on touch devices, it doesn't add specificity
                        "@media (hover: none)": {
                            backgroundColor: "transparent",
                        },
                    },
                    ownerState.variant === "text" &&
                        ownerState.color !== "inherit" && {
                            backgroundColor: theme.vars
                                ? `rgba(${theme.vars.palette[ownerState.color].mainChannel} / ${theme.vars.palette.action.hoverOpacity})`
                                : alpha(theme.palette[ownerState.color].main, theme.palette.action.hoverOpacity),
                            // Reset on touch devices, it doesn't add specificity
                            "@media (hover: none)": {
                                backgroundColor: "transparent",
                            },
                        },
                    ownerState.variant === "outlined" &&
                        ownerState.color !== "inherit" && {
                            border: `1px solid ${(theme.vars || theme).palette[ownerState.color].main}`,
                            backgroundColor: theme.vars
                                ? `rgba(${theme.vars.palette[ownerState.color].mainChannel} / ${theme.vars.palette.action.hoverOpacity})`
                                : alpha(theme.palette[ownerState.color].main, theme.palette.action.hoverOpacity),
                            // Reset on touch devices, it doesn't add specificity
                            "@media (hover: none)": {
                                backgroundColor: "transparent",
                            },
                        },
                    ownerState.variant === "contained" && {
                        backgroundColor: theme.vars ? theme.vars.palette.Button.inheritContainedHoverBg : inheritContainedHoverBackgroundColor,
                        boxShadow: (theme.vars || theme).shadows[4],
                        // Reset on touch devices, it doesn't add specificity
                        "@media (hover: none)": {
                            boxShadow: (theme.vars || theme).shadows[2],
                            backgroundColor: (theme.vars || theme).palette.grey[300],
                        },
                    },
                    ownerState.variant === "contained" &&
                        ownerState.color !== "inherit" && {
                            backgroundColor: (theme.vars || theme).palette[ownerState.color].dark,
                            // Reset on touch devices, it doesn't add specificity
                            "@media (hover: none)": {
                                backgroundColor: (theme.vars || theme).palette[ownerState.color].main,
                            },
                        }
                ),
                "&:active": _extends(
                    {},
                    ownerState.variant === "contained" && {
                        boxShadow: (theme.vars || theme).shadows[8],
                    }
                ),
                [`&.${buttonClasses$1.focusVisible}`]: _extends(
                    {},
                    ownerState.variant === "contained" && {
                        boxShadow: (theme.vars || theme).shadows[6],
                    }
                ),
                [`&.${buttonClasses$1.disabled}`]: _extends(
                    {
                        color: (theme.vars || theme).palette.action.disabled,
                    },
                    ownerState.variant === "outlined" && {
                        border: `1px solid ${(theme.vars || theme).palette.action.disabledBackground}`,
                    },
                    ownerState.variant === "contained" && {
                        color: (theme.vars || theme).palette.action.disabled,
                        boxShadow: (theme.vars || theme).shadows[0],
                        backgroundColor: (theme.vars || theme).palette.action.disabledBackground,
                    }
                ),
            },
            ownerState.variant === "text" && {
                padding: "6px 8px",
            },
            ownerState.variant === "text" &&
                ownerState.color !== "inherit" && {
                    color: (theme.vars || theme).palette[ownerState.color].main,
                },
            ownerState.variant === "outlined" && {
                padding: "5px 15px",
                border: "1px solid currentColor",
            },
            ownerState.variant === "outlined" &&
                ownerState.color !== "inherit" && {
                    color: (theme.vars || theme).palette[ownerState.color].main,
                    border: theme.vars ? `1px solid rgba(${theme.vars.palette[ownerState.color].mainChannel} / 0.5)` : `1px solid ${alpha(theme.palette[ownerState.color].main, 0.5)}`,
                },
            ownerState.variant === "contained" && {
                color: theme.vars
                    ? // this is safe because grey does not change between default light/dark mode
                      theme.vars.palette.text.primary
                    : (_theme$palette$getCon = (_theme$palette = theme.palette).getContrastText) == null
                    ? void 0
                    : _theme$palette$getCon.call(_theme$palette, theme.palette.grey[300]),
                backgroundColor: theme.vars ? theme.vars.palette.Button.inheritContainedBg : inheritContainedBackgroundColor,
                boxShadow: (theme.vars || theme).shadows[2],
            },
            ownerState.variant === "contained" &&
                ownerState.color !== "inherit" && {
                    color: (theme.vars || theme).palette[ownerState.color].contrastText,
                    backgroundColor: (theme.vars || theme).palette[ownerState.color].main,
                },
            ownerState.color === "inherit" && {
                color: "inherit",
                borderColor: "currentColor",
            },
            ownerState.size === "small" &&
                ownerState.variant === "text" && {
                    padding: "4px 5px",
                    fontSize: theme.typography.pxToRem(13),
                },
            ownerState.size === "large" &&
                ownerState.variant === "text" && {
                    padding: "8px 11px",
                    fontSize: theme.typography.pxToRem(15),
                },
            ownerState.size === "small" &&
                ownerState.variant === "outlined" && {
                    padding: "3px 9px",
                    fontSize: theme.typography.pxToRem(13),
                },
            ownerState.size === "large" &&
                ownerState.variant === "outlined" && {
                    padding: "7px 21px",
                    fontSize: theme.typography.pxToRem(15),
                },
            ownerState.size === "small" &&
                ownerState.variant === "contained" && {
                    padding: "4px 10px",
                    fontSize: theme.typography.pxToRem(13),
                },
            ownerState.size === "large" &&
                ownerState.variant === "contained" && {
                    padding: "8px 22px",
                    fontSize: theme.typography.pxToRem(15),
                },
            ownerState.fullWidth && {
                width: "100%",
            }
        );
    },
    ({ ownerState }) =>
        ownerState.disableElevation && {
            boxShadow: "none",
            "&:hover": {
                boxShadow: "none",
            },
            [`&.${buttonClasses$1.focusVisible}`]: {
                boxShadow: "none",
            },
            "&:active": {
                boxShadow: "none",
            },
            [`&.${buttonClasses$1.disabled}`]: {
                boxShadow: "none",
            },
        }
);
const ButtonStartIcon = styled$1("span", {
    name: "MuiButton",
    slot: "StartIcon",
    overridesResolver: (props, styles2) => {
        const { ownerState } = props;
        return [styles2.startIcon, styles2[`iconSize${capitalize(ownerState.size)}`]];
    },
})(({ ownerState }) =>
    _extends(
        {
            display: "inherit",
            marginRight: 8,
            marginLeft: -4,
        },
        ownerState.size === "small" && {
            marginLeft: -2,
        },
        commonIconStyles(ownerState)
    )
);
const ButtonEndIcon = styled$1("span", {
    name: "MuiButton",
    slot: "EndIcon",
    overridesResolver: (props, styles2) => {
        const { ownerState } = props;
        return [styles2.endIcon, styles2[`iconSize${capitalize(ownerState.size)}`]];
    },
})(({ ownerState }) =>
    _extends(
        {
            display: "inherit",
            marginRight: -4,
            marginLeft: 8,
        },
        ownerState.size === "small" && {
            marginRight: -2,
        },
        commonIconStyles(ownerState)
    )
);
const Button = /* @__PURE__ */ reactExports.forwardRef(function Button2(inProps, ref) {
    const contextProps = reactExports.useContext(ButtonGroupContext$1);
    const resolvedProps = resolveProps(contextProps, inProps);
    const props = useThemeProps({
        props: resolvedProps,
        name: "MuiButton",
    });
    const {
            children,
            color: color2 = "primary",
            component = "button",
            className,
            disabled = false,
            disableElevation = false,
            disableFocusRipple = false,
            endIcon: endIconProp,
            focusVisibleClassName,
            fullWidth = false,
            size = "medium",
            startIcon: startIconProp,
            type,
            variant = "text",
        } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded$G);
    const ownerState = _extends({}, props, {
        color: color2,
        component,
        disabled,
        disableElevation,
        disableFocusRipple,
        fullWidth,
        size,
        type,
        variant,
    });
    const classes = useUtilityClasses$z(ownerState);
    const startIcon =
        startIconProp &&
        /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonStartIcon, {
            className: classes.startIcon,
            ownerState,
            children: startIconProp,
        });
    const endIcon =
        endIconProp &&
        /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonEndIcon, {
            className: classes.endIcon,
            ownerState,
            children: endIconProp,
        });
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        ButtonRoot,
        _extends(
            {
                ownerState,
                className: clsx$1(contextProps.className, classes.root, className),
                component,
                disabled,
                focusRipple: !disableFocusRipple,
                focusVisibleClassName: clsx$1(classes.focusVisible, focusVisibleClassName),
                ref,
                type,
            },
            other,
            {
                classes,
                children: [startIcon, children, endIcon],
            }
        )
    );
});
const Button$1 = Button;
function getSwitchBaseUtilityClass(slot) {
    return generateUtilityClass("PrivateSwitchBase", slot);
}
generateUtilityClasses("PrivateSwitchBase", ["root", "checked", "disabled", "input", "edgeStart", "edgeEnd"]);
const _excluded$F = [
    "autoFocus",
    "checked",
    "checkedIcon",
    "className",
    "defaultChecked",
    "disabled",
    "disableFocusRipple",
    "edge",
    "icon",
    "id",
    "inputProps",
    "inputRef",
    "name",
    "onBlur",
    "onChange",
    "onFocus",
    "readOnly",
    "required",
    "tabIndex",
    "type",
    "value",
];
const useUtilityClasses$y = (ownerState) => {
    const { classes, checked, disabled, edge } = ownerState;
    const slots = {
        root: ["root", checked && "checked", disabled && "disabled", edge && `edge${capitalize(edge)}`],
        input: ["input"],
    };
    return composeClasses(slots, getSwitchBaseUtilityClass, classes);
};
const SwitchBaseRoot = styled$1(ButtonBase$1)(({ ownerState }) =>
    _extends(
        {
            padding: 9,
            borderRadius: "50%",
        },
        ownerState.edge === "start" && {
            marginLeft: ownerState.size === "small" ? -3 : -12,
        },
        ownerState.edge === "end" && {
            marginRight: ownerState.size === "small" ? -3 : -12,
        }
    )
);
const SwitchBaseInput = styled$1("input")({
    cursor: "inherit",
    position: "absolute",
    opacity: 0,
    width: "100%",
    height: "100%",
    top: 0,
    left: 0,
    margin: 0,
    padding: 0,
    zIndex: 1,
});
const SwitchBase = /* @__PURE__ */ reactExports.forwardRef(function SwitchBase2(props, ref) {
    const {
            autoFocus,
            checked: checkedProp,
            checkedIcon,
            className,
            defaultChecked,
            disabled: disabledProp,
            disableFocusRipple = false,
            edge = false,
            icon,
            id,
            inputProps,
            inputRef,
            name,
            onBlur,
            onChange,
            onFocus,
            readOnly,
            required = false,
            tabIndex,
            type,
            value,
        } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded$F);
    const [checked, setCheckedState] = useControlled({
        controlled: checkedProp,
        default: Boolean(defaultChecked),
        name: "SwitchBase",
        state: "checked",
    });
    const muiFormControl = useFormControl();
    const handleFocus = (event) => {
        if (onFocus) {
            onFocus(event);
        }
        if (muiFormControl && muiFormControl.onFocus) {
            muiFormControl.onFocus(event);
        }
    };
    const handleBlur = (event) => {
        if (onBlur) {
            onBlur(event);
        }
        if (muiFormControl && muiFormControl.onBlur) {
            muiFormControl.onBlur(event);
        }
    };
    const handleInputChange = (event) => {
        if (event.nativeEvent.defaultPrevented) {
            return;
        }
        const newChecked = event.target.checked;
        setCheckedState(newChecked);
        if (onChange) {
            onChange(event, newChecked);
        }
    };
    let disabled = disabledProp;
    if (muiFormControl) {
        if (typeof disabled === "undefined") {
            disabled = muiFormControl.disabled;
        }
    }
    const hasLabelFor = type === "checkbox" || type === "radio";
    const ownerState = _extends({}, props, {
        checked,
        disabled,
        disableFocusRipple,
        edge,
    });
    const classes = useUtilityClasses$y(ownerState);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        SwitchBaseRoot,
        _extends(
            {
                component: "span",
                className: clsx$1(classes.root, className),
                centerRipple: true,
                focusRipple: !disableFocusRipple,
                disabled,
                tabIndex: null,
                role: void 0,
                onFocus: handleFocus,
                onBlur: handleBlur,
                ownerState,
                ref,
            },
            other,
            {
                children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                        SwitchBaseInput,
                        _extends(
                            {
                                autoFocus,
                                checked: checkedProp,
                                defaultChecked,
                                className: classes.input,
                                disabled,
                                id: hasLabelFor ? id : void 0,
                                name,
                                onChange: handleInputChange,
                                readOnly,
                                ref: inputRef,
                                required,
                                ownerState,
                                tabIndex,
                                type,
                            },
                            type === "checkbox" && value === void 0
                                ? {}
                                : {
                                      value,
                                  },
                            inputProps
                        )
                    ),
                    checked ? checkedIcon : icon,
                ],
            }
        )
    );
});
const SwitchBase$1 = SwitchBase;
const CheckBoxOutlineBlankIcon = createSvgIcon$1(
    /* @__PURE__ */ jsxRuntimeExports.jsx("path", {
        d: "M19 5v14H5V5h14m0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z",
    }),
    "CheckBoxOutlineBlank"
);
const CheckBoxIcon = createSvgIcon$1(
    /* @__PURE__ */ jsxRuntimeExports.jsx("path", {
        d: "M19 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.11 0 2-.9 2-2V5c0-1.1-.89-2-2-2zm-9 14l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z",
    }),
    "CheckBox"
);
const IndeterminateCheckBoxIcon = createSvgIcon$1(
    /* @__PURE__ */ jsxRuntimeExports.jsx("path", {
        d: "M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-2 10H7v-2h10v2z",
    }),
    "IndeterminateCheckBox"
);
function getCheckboxUtilityClass(slot) {
    return generateUtilityClass("MuiCheckbox", slot);
}
const checkboxClasses = generateUtilityClasses("MuiCheckbox", ["root", "checked", "disabled", "indeterminate", "colorPrimary", "colorSecondary"]);
const checkboxClasses$1 = checkboxClasses;
const _excluded$E = ["checkedIcon", "color", "icon", "indeterminate", "indeterminateIcon", "inputProps", "size", "className"];
const useUtilityClasses$x = (ownerState) => {
    const { classes, indeterminate, color: color2 } = ownerState;
    const slots = {
        root: ["root", indeterminate && "indeterminate", `color${capitalize(color2)}`],
    };
    const composedClasses = composeClasses(slots, getCheckboxUtilityClass, classes);
    return _extends({}, classes, composedClasses);
};
const CheckboxRoot = styled$1(SwitchBase$1, {
    shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
    name: "MuiCheckbox",
    slot: "Root",
    overridesResolver: (props, styles2) => {
        const { ownerState } = props;
        return [styles2.root, ownerState.indeterminate && styles2.indeterminate, ownerState.color !== "default" && styles2[`color${capitalize(ownerState.color)}`]];
    },
})(({ theme, ownerState }) =>
    _extends(
        {
            color: (theme.vars || theme).palette.text.secondary,
        },
        !ownerState.disableRipple && {
            "&:hover": {
                backgroundColor: theme.vars
                    ? `rgba(${ownerState.color === "default" ? theme.vars.palette.action.activeChannel : theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.hoverOpacity})`
                    : alpha(ownerState.color === "default" ? theme.palette.action.active : theme.palette[ownerState.color].main, theme.palette.action.hoverOpacity),
                // Reset on touch devices, it doesn't add specificity
                "@media (hover: none)": {
                    backgroundColor: "transparent",
                },
            },
        },
        ownerState.color !== "default" && {
            [`&.${checkboxClasses$1.checked}, &.${checkboxClasses$1.indeterminate}`]: {
                color: (theme.vars || theme).palette[ownerState.color].main,
            },
            [`&.${checkboxClasses$1.disabled}`]: {
                color: (theme.vars || theme).palette.action.disabled,
            },
        }
    )
);
const defaultCheckedIcon = /* @__PURE__ */ jsxRuntimeExports.jsx(CheckBoxIcon, {});
const defaultIcon = /* @__PURE__ */ jsxRuntimeExports.jsx(CheckBoxOutlineBlankIcon, {});
const defaultIndeterminateIcon = /* @__PURE__ */ jsxRuntimeExports.jsx(IndeterminateCheckBoxIcon, {});
const Checkbox = /* @__PURE__ */ reactExports.forwardRef(function Checkbox2(inProps, ref) {
    var _icon$props$fontSize, _indeterminateIcon$pr;
    const props = useThemeProps({
        props: inProps,
        name: "MuiCheckbox",
    });
    const {
            checkedIcon = defaultCheckedIcon,
            color: color2 = "primary",
            icon: iconProp = defaultIcon,
            indeterminate = false,
            indeterminateIcon: indeterminateIconProp = defaultIndeterminateIcon,
            inputProps,
            size = "medium",
            className,
        } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded$E);
    const icon = indeterminate ? indeterminateIconProp : iconProp;
    const indeterminateIcon = indeterminate ? indeterminateIconProp : checkedIcon;
    const ownerState = _extends({}, props, {
        color: color2,
        indeterminate,
        size,
    });
    const classes = useUtilityClasses$x(ownerState);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
        CheckboxRoot,
        _extends(
            {
                type: "checkbox",
                inputProps: _extends(
                    {
                        "data-indeterminate": indeterminate,
                    },
                    inputProps
                ),
                icon: /* @__PURE__ */ reactExports.cloneElement(icon, {
                    fontSize: (_icon$props$fontSize = icon.props.fontSize) != null ? _icon$props$fontSize : size,
                }),
                checkedIcon: /* @__PURE__ */ reactExports.cloneElement(indeterminateIcon, {
                    fontSize: (_indeterminateIcon$pr = indeterminateIcon.props.fontSize) != null ? _indeterminateIcon$pr : size,
                }),
                ownerState,
                ref,
                className: clsx$1(classes.root, className),
            },
            other,
            {
                classes,
            }
        )
    );
});
const Checkbox$1 = Checkbox;
function getCircularProgressUtilityClass(slot) {
    return generateUtilityClass("MuiCircularProgress", slot);
}
generateUtilityClasses("MuiCircularProgress", [
    "root",
    "determinate",
    "indeterminate",
    "colorPrimary",
    "colorSecondary",
    "svg",
    "circle",
    "circleDeterminate",
    "circleIndeterminate",
    "circleDisableShrink",
]);
const _excluded$D = ["className", "color", "disableShrink", "size", "style", "thickness", "value", "variant"];
let _ = (t2) => t2,
    _t,
    _t2,
    _t3,
    _t4;
const SIZE = 44;
const circularRotateKeyframe = keyframes(
    _t ||
        (_t = _`
  0% {
    transform: rotate(0deg);
  }

  100% {
    transform: rotate(360deg);
  }
`)
);
const circularDashKeyframe = keyframes(
    _t2 ||
        (_t2 = _`
  0% {
    stroke-dasharray: 1px, 200px;
    stroke-dashoffset: 0;
  }

  50% {
    stroke-dasharray: 100px, 200px;
    stroke-dashoffset: -15px;
  }

  100% {
    stroke-dasharray: 100px, 200px;
    stroke-dashoffset: -125px;
  }
`)
);
const useUtilityClasses$w = (ownerState) => {
    const { classes, variant, color: color2, disableShrink } = ownerState;
    const slots = {
        root: ["root", variant, `color${capitalize(color2)}`],
        svg: ["svg"],
        circle: ["circle", `circle${capitalize(variant)}`, disableShrink && "circleDisableShrink"],
    };
    return composeClasses(slots, getCircularProgressUtilityClass, classes);
};
const CircularProgressRoot = styled$1("span", {
    name: "MuiCircularProgress",
    slot: "Root",
    overridesResolver: (props, styles2) => {
        const { ownerState } = props;
        return [styles2.root, styles2[ownerState.variant], styles2[`color${capitalize(ownerState.color)}`]];
    },
})(
    ({ ownerState, theme }) =>
        _extends(
            {
                display: "inline-block",
            },
            ownerState.variant === "determinate" && {
                transition: theme.transitions.create("transform"),
            },
            ownerState.color !== "inherit" && {
                color: (theme.vars || theme).palette[ownerState.color].main,
            }
        ),
    ({ ownerState }) =>
        ownerState.variant === "indeterminate" &&
        css(
            _t3 ||
                (_t3 = _`
      animation: ${0} 1.4s linear infinite;
    `),
            circularRotateKeyframe
        )
);
const CircularProgressSVG = styled$1("svg", {
    name: "MuiCircularProgress",
    slot: "Svg",
    overridesResolver: (props, styles2) => styles2.svg,
})({
    display: "block",
    // Keeps the progress centered
});
const CircularProgressCircle = styled$1("circle", {
    name: "MuiCircularProgress",
    slot: "Circle",
    overridesResolver: (props, styles2) => {
        const { ownerState } = props;
        return [styles2.circle, styles2[`circle${capitalize(ownerState.variant)}`], ownerState.disableShrink && styles2.circleDisableShrink];
    },
})(
    ({ ownerState, theme }) =>
        _extends(
            {
                stroke: "currentColor",
            },
            ownerState.variant === "determinate" && {
                transition: theme.transitions.create("stroke-dashoffset"),
            },
            ownerState.variant === "indeterminate" && {
                // Some default value that looks fine waiting for the animation to kicks in.
                strokeDasharray: "80px, 200px",
                strokeDashoffset: 0,
                // Add the unit to fix a Edge 16 and below bug.
            }
        ),
    ({ ownerState }) =>
        ownerState.variant === "indeterminate" &&
        !ownerState.disableShrink &&
        css(
            _t4 ||
                (_t4 = _`
      animation: ${0} 1.4s ease-in-out infinite;
    `),
            circularDashKeyframe
        )
);
const CircularProgress = /* @__PURE__ */ reactExports.forwardRef(function CircularProgress2(inProps, ref) {
    const props = useThemeProps({
        props: inProps,
        name: "MuiCircularProgress",
    });
    const { className, color: color2 = "primary", disableShrink = false, size = 40, style: style2, thickness = 3.6, value = 0, variant = "indeterminate" } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded$D);
    const ownerState = _extends({}, props, {
        color: color2,
        disableShrink,
        size,
        thickness,
        value,
        variant,
    });
    const classes = useUtilityClasses$w(ownerState);
    const circleStyle = {};
    const rootStyle = {};
    const rootProps = {};
    if (variant === "determinate") {
        const circumference = 2 * Math.PI * ((SIZE - thickness) / 2);
        circleStyle.strokeDasharray = circumference.toFixed(3);
        rootProps["aria-valuenow"] = Math.round(value);
        circleStyle.strokeDashoffset = `${(((100 - value) / 100) * circumference).toFixed(3)}px`;
        rootStyle.transform = "rotate(-90deg)";
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
        CircularProgressRoot,
        _extends(
            {
                className: clsx$1(classes.root, className),
                style: _extends(
                    {
                        width: size,
                        height: size,
                    },
                    rootStyle,
                    style2
                ),
                ownerState,
                ref,
                role: "progressbar",
            },
            rootProps,
            other,
            {
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgressSVG, {
                    className: classes.svg,
                    ownerState,
                    viewBox: `${SIZE / 2} ${SIZE / 2} ${SIZE} ${SIZE}`,
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgressCircle, {
                        className: classes.circle,
                        style: circleStyle,
                        ownerState,
                        cx: SIZE,
                        cy: SIZE,
                        r: (SIZE - thickness) / 2,
                        fill: "none",
                        strokeWidth: thickness,
                    }),
                }),
            }
        )
    );
});
const CircularProgress$1 = CircularProgress;
const _excluded$C = [
    "BackdropComponent",
    "BackdropProps",
    "classes",
    "className",
    "closeAfterTransition",
    "children",
    "container",
    "component",
    "components",
    "componentsProps",
    "disableAutoFocus",
    "disableEnforceFocus",
    "disableEscapeKeyDown",
    "disablePortal",
    "disableRestoreFocus",
    "disableScrollLock",
    "hideBackdrop",
    "keepMounted",
    "onBackdropClick",
    "onClose",
    "open",
    "slotProps",
    "slots",
    "theme",
];
const ModalRoot = styled$1("div", {
    name: "MuiModal",
    slot: "Root",
    overridesResolver: (props, styles2) => {
        const { ownerState } = props;
        return [styles2.root, !ownerState.open && ownerState.exited && styles2.hidden];
    },
})(({ theme, ownerState }) =>
    _extends(
        {
            position: "fixed",
            zIndex: (theme.vars || theme).zIndex.modal,
            right: 0,
            bottom: 0,
            top: 0,
            left: 0,
        },
        !ownerState.open &&
            ownerState.exited && {
                visibility: "hidden",
            }
    )
);
const ModalBackdrop = styled$1(Backdrop$1, {
    name: "MuiModal",
    slot: "Backdrop",
    overridesResolver: (props, styles2) => {
        return styles2.backdrop;
    },
})({
    zIndex: -1,
});
const Modal2 = /* @__PURE__ */ reactExports.forwardRef(function Modal3(inProps, ref) {
    var _ref, _slots$root, _ref2, _slots$backdrop, _slotProps$root, _slotProps$backdrop;
    const props = useThemeProps({
        name: "MuiModal",
        props: inProps,
    });
    const {
            BackdropComponent = ModalBackdrop,
            BackdropProps,
            classes,
            className,
            closeAfterTransition = false,
            children,
            container: container2,
            component,
            components = {},
            componentsProps = {},
            disableAutoFocus = false,
            disableEnforceFocus = false,
            disableEscapeKeyDown = false,
            disablePortal = false,
            disableRestoreFocus = false,
            disableScrollLock = false,
            hideBackdrop = false,
            keepMounted = false,
            onBackdropClick,
            onClose,
            open: open2,
            slotProps,
            slots,
            // eslint-disable-next-line react/prop-types
            theme,
        } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded$C);
    const [exited, setExited] = reactExports.useState(true);
    const commonProps = {
        container: container2,
        closeAfterTransition,
        disableAutoFocus,
        disableEnforceFocus,
        disableEscapeKeyDown,
        disablePortal,
        disableRestoreFocus,
        disableScrollLock,
        hideBackdrop,
        keepMounted,
        onBackdropClick,
        onClose,
        open: open2,
    };
    const ownerState = _extends({}, props, commonProps, {
        exited,
    });
    const RootSlot = (_ref = (_slots$root = slots == null ? void 0 : slots.root) != null ? _slots$root : components.Root) != null ? _ref : ModalRoot;
    const BackdropSlot = (_ref2 = (_slots$backdrop = slots == null ? void 0 : slots.backdrop) != null ? _slots$backdrop : components.Backdrop) != null ? _ref2 : BackdropComponent;
    const rootSlotProps = (_slotProps$root = slotProps == null ? void 0 : slotProps.root) != null ? _slotProps$root : componentsProps.root;
    const backdropSlotProps = (_slotProps$backdrop = slotProps == null ? void 0 : slotProps.backdrop) != null ? _slotProps$backdrop : componentsProps.backdrop;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
        ModalUnstyled,
        _extends(
            {
                slots: {
                    root: RootSlot,
                    backdrop: BackdropSlot,
                },
                slotProps: {
                    root: () =>
                        _extends(
                            {},
                            resolveComponentProps(rootSlotProps, ownerState),
                            !isHostComponent(RootSlot) && {
                                as: component,
                                theme,
                            },
                            {
                                className: clsx$1(
                                    className,
                                    rootSlotProps == null ? void 0 : rootSlotProps.className,
                                    classes == null ? void 0 : classes.root,
                                    !ownerState.open && ownerState.exited && (classes == null ? void 0 : classes.hidden)
                                ),
                            }
                        ),
                    backdrop: () =>
                        _extends({}, BackdropProps, resolveComponentProps(backdropSlotProps, ownerState), {
                            className: clsx$1(backdropSlotProps == null ? void 0 : backdropSlotProps.className, classes == null ? void 0 : classes.backdrop),
                        }),
                },
                onTransitionEnter: () => setExited(false),
                onTransitionExited: () => setExited(true),
                ref,
            },
            other,
            commonProps,
            {
                children,
            }
        )
    );
});
const Modal$1 = Modal2;
const dividerClasses = generateUtilityClasses("MuiDivider", [
    "root",
    "absolute",
    "fullWidth",
    "inset",
    "middle",
    "flexItem",
    "light",
    "vertical",
    "withChildren",
    "withChildrenVertical",
    "textAlignRight",
    "textAlignLeft",
    "wrapper",
    "wrapperVertical",
]);
const dividerClasses$1 = dividerClasses;
const _excluded$B = ["disableUnderline", "components", "componentsProps", "fullWidth", "hiddenLabel", "inputComponent", "multiline", "slotProps", "slots", "type"];
const useUtilityClasses$v = (ownerState) => {
    const { classes, disableUnderline } = ownerState;
    const slots = {
        root: ["root", !disableUnderline && "underline"],
        input: ["input"],
    };
    const composedClasses = composeClasses(slots, getFilledInputUtilityClass, classes);
    return _extends({}, classes, composedClasses);
};
const FilledInputRoot = styled$1(InputBaseRoot, {
    shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
    name: "MuiFilledInput",
    slot: "Root",
    overridesResolver: (props, styles2) => {
        const { ownerState } = props;
        return [...rootOverridesResolver(props, styles2), !ownerState.disableUnderline && styles2.underline];
    },
})(({ theme, ownerState }) => {
    var _palette;
    const light2 = theme.palette.mode === "light";
    const bottomLineColor = light2 ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)";
    const backgroundColor2 = light2 ? "rgba(0, 0, 0, 0.06)" : "rgba(255, 255, 255, 0.09)";
    const hoverBackground = light2 ? "rgba(0, 0, 0, 0.09)" : "rgba(255, 255, 255, 0.13)";
    const disabledBackground = light2 ? "rgba(0, 0, 0, 0.12)" : "rgba(255, 255, 255, 0.12)";
    return _extends(
        {
            position: "relative",
            backgroundColor: theme.vars ? theme.vars.palette.FilledInput.bg : backgroundColor2,
            borderTopLeftRadius: (theme.vars || theme).shape.borderRadius,
            borderTopRightRadius: (theme.vars || theme).shape.borderRadius,
            transition: theme.transitions.create("background-color", {
                duration: theme.transitions.duration.shorter,
                easing: theme.transitions.easing.easeOut,
            }),
            "&:hover": {
                backgroundColor: theme.vars ? theme.vars.palette.FilledInput.hoverBg : hoverBackground,
                // Reset on touch devices, it doesn't add specificity
                "@media (hover: none)": {
                    backgroundColor: theme.vars ? theme.vars.palette.FilledInput.bg : backgroundColor2,
                },
            },
            [`&.${filledInputClasses$1.focused}`]: {
                backgroundColor: theme.vars ? theme.vars.palette.FilledInput.bg : backgroundColor2,
            },
            [`&.${filledInputClasses$1.disabled}`]: {
                backgroundColor: theme.vars ? theme.vars.palette.FilledInput.disabledBg : disabledBackground,
            },
        },
        !ownerState.disableUnderline && {
            "&:after": {
                borderBottom: `2px solid ${(_palette = (theme.vars || theme).palette[ownerState.color || "primary"]) == null ? void 0 : _palette.main}`,
                left: 0,
                bottom: 0,
                // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
                content: '""',
                position: "absolute",
                right: 0,
                transform: "scaleX(0)",
                transition: theme.transitions.create("transform", {
                    duration: theme.transitions.duration.shorter,
                    easing: theme.transitions.easing.easeOut,
                }),
                pointerEvents: "none",
                // Transparent to the hover style.
            },
            [`&.${filledInputClasses$1.focused}:after`]: {
                // translateX(0) is a workaround for Safari transform scale bug
                // See https://github.com/mui/material-ui/issues/31766
                transform: "scaleX(1) translateX(0)",
            },
            [`&.${filledInputClasses$1.error}`]: {
                "&:before, &:after": {
                    borderBottomColor: (theme.vars || theme).palette.error.main,
                },
            },
            "&:before": {
                borderBottom: `1px solid ${theme.vars ? `rgba(${theme.vars.palette.common.onBackgroundChannel} / ${theme.vars.opacity.inputUnderline})` : bottomLineColor}`,
                left: 0,
                bottom: 0,
                // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
                content: '"\\00a0"',
                position: "absolute",
                right: 0,
                transition: theme.transitions.create("border-bottom-color", {
                    duration: theme.transitions.duration.shorter,
                }),
                pointerEvents: "none",
                // Transparent to the hover style.
            },
            [`&:hover:not(.${filledInputClasses$1.disabled}, .${filledInputClasses$1.error}):before`]: {
                borderBottom: `1px solid ${(theme.vars || theme).palette.text.primary}`,
            },
            [`&.${filledInputClasses$1.disabled}:before`]: {
                borderBottomStyle: "dotted",
            },
        },
        ownerState.startAdornment && {
            paddingLeft: 12,
        },
        ownerState.endAdornment && {
            paddingRight: 12,
        },
        ownerState.multiline &&
            _extends(
                {
                    padding: "25px 12px 8px",
                },
                ownerState.size === "small" && {
                    paddingTop: 21,
                    paddingBottom: 4,
                },
                ownerState.hiddenLabel && {
                    paddingTop: 16,
                    paddingBottom: 17,
                }
            )
    );
});
const FilledInputInput = styled$1(InputBaseComponent, {
    name: "MuiFilledInput",
    slot: "Input",
    overridesResolver: inputOverridesResolver,
})(({ theme, ownerState }) =>
    _extends(
        {
            paddingTop: 25,
            paddingRight: 12,
            paddingBottom: 8,
            paddingLeft: 12,
        },
        !theme.vars && {
            "&:-webkit-autofill": {
                WebkitBoxShadow: theme.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
                WebkitTextFillColor: theme.palette.mode === "light" ? null : "#fff",
                caretColor: theme.palette.mode === "light" ? null : "#fff",
                borderTopLeftRadius: "inherit",
                borderTopRightRadius: "inherit",
            },
        },
        theme.vars && {
            "&:-webkit-autofill": {
                borderTopLeftRadius: "inherit",
                borderTopRightRadius: "inherit",
            },
            [theme.getColorSchemeSelector("dark")]: {
                "&:-webkit-autofill": {
                    WebkitBoxShadow: "0 0 0 100px #266798 inset",
                    WebkitTextFillColor: "#fff",
                    caretColor: "#fff",
                },
            },
        },
        ownerState.size === "small" && {
            paddingTop: 21,
            paddingBottom: 4,
        },
        ownerState.hiddenLabel && {
            paddingTop: 16,
            paddingBottom: 17,
        },
        ownerState.multiline && {
            paddingTop: 0,
            paddingBottom: 0,
            paddingLeft: 0,
            paddingRight: 0,
        },
        ownerState.startAdornment && {
            paddingLeft: 0,
        },
        ownerState.endAdornment && {
            paddingRight: 0,
        },
        ownerState.hiddenLabel &&
            ownerState.size === "small" && {
                paddingTop: 8,
                paddingBottom: 9,
            }
    )
);
const FilledInput = /* @__PURE__ */ reactExports.forwardRef(function FilledInput2(inProps, ref) {
    var _ref, _slots$root, _ref2, _slots$input;
    const props = useThemeProps({
        props: inProps,
        name: "MuiFilledInput",
    });
    const {
            components = {},
            componentsProps: componentsPropsProp,
            fullWidth = false,
            // declare here to prevent spreading to DOM
            inputComponent = "input",
            multiline = false,
            slotProps,
            slots = {},
            type = "text",
        } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded$B);
    const ownerState = _extends({}, props, {
        fullWidth,
        inputComponent,
        multiline,
        type,
    });
    const classes = useUtilityClasses$v(props);
    const filledInputComponentsProps = {
        root: {
            ownerState,
        },
        input: {
            ownerState,
        },
    };
    const componentsProps = (slotProps != null ? slotProps : componentsPropsProp)
        ? deepmerge(slotProps != null ? slotProps : componentsPropsProp, filledInputComponentsProps)
        : filledInputComponentsProps;
    const RootSlot = (_ref = (_slots$root = slots.root) != null ? _slots$root : components.Root) != null ? _ref : FilledInputRoot;
    const InputSlot = (_ref2 = (_slots$input = slots.input) != null ? _slots$input : components.Input) != null ? _ref2 : FilledInputInput;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
        InputBase$1,
        _extends(
            {
                slots: {
                    root: RootSlot,
                    input: InputSlot,
                },
                componentsProps,
                fullWidth,
                inputComponent,
                multiline,
                ref,
                type,
            },
            other,
            {
                classes,
            }
        )
    );
});
FilledInput.muiName = "Input";
const FilledInput$1 = FilledInput;
function getFormControlUtilityClasses(slot) {
    return generateUtilityClass("MuiFormControl", slot);
}
generateUtilityClasses("MuiFormControl", ["root", "marginNone", "marginNormal", "marginDense", "fullWidth", "disabled"]);
const _excluded$A = ["children", "className", "color", "component", "disabled", "error", "focused", "fullWidth", "hiddenLabel", "margin", "required", "size", "variant"];
const useUtilityClasses$u = (ownerState) => {
    const { classes, margin: margin2, fullWidth } = ownerState;
    const slots = {
        root: ["root", margin2 !== "none" && `margin${capitalize(margin2)}`, fullWidth && "fullWidth"],
    };
    return composeClasses(slots, getFormControlUtilityClasses, classes);
};
const FormControlRoot = styled$1("div", {
    name: "MuiFormControl",
    slot: "Root",
    overridesResolver: ({ ownerState }, styles2) => {
        return _extends({}, styles2.root, styles2[`margin${capitalize(ownerState.margin)}`], ownerState.fullWidth && styles2.fullWidth);
    },
})(({ ownerState }) =>
    _extends(
        {
            display: "inline-flex",
            flexDirection: "column",
            position: "relative",
            // Reset fieldset default style.
            minWidth: 0,
            padding: 0,
            margin: 0,
            border: 0,
            verticalAlign: "top",
        },
        ownerState.margin === "normal" && {
            marginTop: 16,
            marginBottom: 8,
        },
        ownerState.margin === "dense" && {
            marginTop: 8,
            marginBottom: 4,
        },
        ownerState.fullWidth && {
            width: "100%",
        }
    )
);
const FormControl = /* @__PURE__ */ reactExports.forwardRef(function FormControl2(inProps, ref) {
    const props = useThemeProps({
        props: inProps,
        name: "MuiFormControl",
    });
    const {
            children,
            className,
            color: color2 = "primary",
            component = "div",
            disabled = false,
            error = false,
            focused: visuallyFocused,
            fullWidth = false,
            hiddenLabel = false,
            margin: margin2 = "none",
            required = false,
            size = "medium",
            variant = "outlined",
        } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded$A);
    const ownerState = _extends({}, props, {
        color: color2,
        component,
        disabled,
        error,
        fullWidth,
        hiddenLabel,
        margin: margin2,
        required,
        size,
        variant,
    });
    const classes = useUtilityClasses$u(ownerState);
    const [adornedStart, setAdornedStart] = reactExports.useState(() => {
        let initialAdornedStart = false;
        if (children) {
            reactExports.Children.forEach(children, (child) => {
                if (!isMuiElement(child, ["Input", "Select"])) {
                    return;
                }
                const input = isMuiElement(child, ["Select"]) ? child.props.input : child;
                if (input && isAdornedStart(input.props)) {
                    initialAdornedStart = true;
                }
            });
        }
        return initialAdornedStart;
    });
    const [filled, setFilled] = reactExports.useState(() => {
        let initialFilled = false;
        if (children) {
            reactExports.Children.forEach(children, (child) => {
                if (!isMuiElement(child, ["Input", "Select"])) {
                    return;
                }
                if (isFilled(child.props, true) || isFilled(child.props.inputProps, true)) {
                    initialFilled = true;
                }
            });
        }
        return initialFilled;
    });
    const [focusedState, setFocused] = reactExports.useState(false);
    if (disabled && focusedState) {
        setFocused(false);
    }
    const focused = visuallyFocused !== void 0 && !disabled ? visuallyFocused : focusedState;
    let registerEffect;
    const childContext = reactExports.useMemo(() => {
        return {
            adornedStart,
            setAdornedStart,
            color: color2,
            disabled,
            error,
            filled,
            focused,
            fullWidth,
            hiddenLabel,
            size,
            onBlur: () => {
                setFocused(false);
            },
            onEmpty: () => {
                setFilled(false);
            },
            onFilled: () => {
                setFilled(true);
            },
            onFocus: () => {
                setFocused(true);
            },
            registerEffect,
            required,
            variant,
        };
    }, [adornedStart, color2, disabled, error, filled, focused, fullWidth, hiddenLabel, registerEffect, required, size, variant]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(FormControlContext$1.Provider, {
        value: childContext,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            FormControlRoot,
            _extends(
                {
                    as: component,
                    ownerState,
                    className: clsx$1(classes.root, className),
                    ref,
                },
                other,
                {
                    children,
                }
            )
        ),
    });
});
const FormControl$1 = FormControl;
function getFormControlLabelUtilityClasses(slot) {
    return generateUtilityClass("MuiFormControlLabel", slot);
}
const formControlLabelClasses = generateUtilityClasses("MuiFormControlLabel", [
    "root",
    "labelPlacementStart",
    "labelPlacementTop",
    "labelPlacementBottom",
    "disabled",
    "label",
    "error",
    "required",
    "asterisk",
]);
const formControlLabelClasses$1 = formControlLabelClasses;
const _excluded$z = [
    "checked",
    "className",
    "componentsProps",
    "control",
    "disabled",
    "disableTypography",
    "inputRef",
    "label",
    "labelPlacement",
    "name",
    "onChange",
    "required",
    "slotProps",
    "value",
];
const useUtilityClasses$t = (ownerState) => {
    const { classes, disabled, labelPlacement, error, required } = ownerState;
    const slots = {
        root: ["root", disabled && "disabled", `labelPlacement${capitalize(labelPlacement)}`, error && "error", required && "required"],
        label: ["label", disabled && "disabled"],
        asterisk: ["asterisk", error && "error"],
    };
    return composeClasses(slots, getFormControlLabelUtilityClasses, classes);
};
const FormControlLabelRoot = styled$1("label", {
    name: "MuiFormControlLabel",
    slot: "Root",
    overridesResolver: (props, styles2) => {
        const { ownerState } = props;
        return [
            {
                [`& .${formControlLabelClasses$1.label}`]: styles2.label,
            },
            styles2.root,
            styles2[`labelPlacement${capitalize(ownerState.labelPlacement)}`],
        ];
    },
})(({ theme, ownerState }) =>
    _extends(
        {
            display: "inline-flex",
            alignItems: "center",
            cursor: "pointer",
            // For correct alignment with the text.
            verticalAlign: "middle",
            WebkitTapHighlightColor: "transparent",
            marginLeft: -11,
            marginRight: 16,
            // used for row presentation of radio/checkbox
            [`&.${formControlLabelClasses$1.disabled}`]: {
                cursor: "default",
            },
        },
        ownerState.labelPlacement === "start" && {
            flexDirection: "row-reverse",
            marginLeft: 16,
            // used for row presentation of radio/checkbox
            marginRight: -11,
        },
        ownerState.labelPlacement === "top" && {
            flexDirection: "column-reverse",
            marginLeft: 16,
        },
        ownerState.labelPlacement === "bottom" && {
            flexDirection: "column",
            marginLeft: 16,
        },
        {
            [`& .${formControlLabelClasses$1.label}`]: {
                [`&.${formControlLabelClasses$1.disabled}`]: {
                    color: (theme.vars || theme).palette.text.disabled,
                },
            },
        }
    )
);
const AsteriskComponent$1 = styled$1("span", {
    name: "MuiFormControlLabel",
    slot: "Asterisk",
    overridesResolver: (props, styles2) => styles2.asterisk,
})(({ theme }) => ({
    [`&.${formControlLabelClasses$1.error}`]: {
        color: (theme.vars || theme).palette.error.main,
    },
}));
const FormControlLabel = /* @__PURE__ */ reactExports.forwardRef(function FormControlLabel2(inProps, ref) {
    var _ref, _slotProps$typography;
    const props = useThemeProps({
        props: inProps,
        name: "MuiFormControlLabel",
    });
    const { className, componentsProps = {}, control, disabled: disabledProp, disableTypography, label: labelProp, labelPlacement = "end", required: requiredProp, slotProps = {} } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded$z);
    const muiFormControl = useFormControl();
    const disabled = (_ref = disabledProp != null ? disabledProp : control.props.disabled) != null ? _ref : muiFormControl == null ? void 0 : muiFormControl.disabled;
    const required = requiredProp != null ? requiredProp : control.props.required;
    const controlProps = {
        disabled,
        required,
    };
    ["checked", "name", "onChange", "value", "inputRef"].forEach((key) => {
        if (typeof control.props[key] === "undefined" && typeof props[key] !== "undefined") {
            controlProps[key] = props[key];
        }
    });
    const fcs = formControlState({
        props,
        muiFormControl,
        states: ["error"],
    });
    const ownerState = _extends({}, props, {
        disabled,
        labelPlacement,
        required,
        error: fcs.error,
    });
    const classes = useUtilityClasses$t(ownerState);
    const typographySlotProps = (_slotProps$typography = slotProps.typography) != null ? _slotProps$typography : componentsProps.typography;
    let label = labelProp;
    if (label != null && label.type !== Typography$1 && !disableTypography) {
        label = /* @__PURE__ */ jsxRuntimeExports.jsx(
            Typography$1,
            _extends(
                {
                    component: "span",
                },
                typographySlotProps,
                {
                    className: clsx$1(classes.label, typographySlotProps == null ? void 0 : typographySlotProps.className),
                    children: label,
                }
            )
        );
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        FormControlLabelRoot,
        _extends(
            {
                className: clsx$1(classes.root, className),
                ownerState,
                ref,
            },
            other,
            {
                children: [
                    /* @__PURE__ */ reactExports.cloneElement(control, controlProps),
                    label,
                    required &&
                        /* @__PURE__ */ jsxRuntimeExports.jsxs(AsteriskComponent$1, {
                            ownerState,
                            "aria-hidden": true,
                            className: classes.asterisk,
                            children: ["", "*"],
                        }),
                ],
            }
        )
    );
});
const FormControlLabel$1 = FormControlLabel;
function getFormGroupUtilityClass(slot) {
    return generateUtilityClass("MuiFormGroup", slot);
}
generateUtilityClasses("MuiFormGroup", ["root", "row", "error"]);
const _excluded$y = ["className", "row"];
const useUtilityClasses$s = (ownerState) => {
    const { classes, row, error } = ownerState;
    const slots = {
        root: ["root", row && "row", error && "error"],
    };
    return composeClasses(slots, getFormGroupUtilityClass, classes);
};
const FormGroupRoot = styled$1("div", {
    name: "MuiFormGroup",
    slot: "Root",
    overridesResolver: (props, styles2) => {
        const { ownerState } = props;
        return [styles2.root, ownerState.row && styles2.row];
    },
})(({ ownerState }) =>
    _extends(
        {
            display: "flex",
            flexDirection: "column",
            flexWrap: "wrap",
        },
        ownerState.row && {
            flexDirection: "row",
        }
    )
);
const FormGroup = /* @__PURE__ */ reactExports.forwardRef(function FormGroup2(inProps, ref) {
    const props = useThemeProps({
        props: inProps,
        name: "MuiFormGroup",
    });
    const { className, row = false } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded$y);
    const muiFormControl = useFormControl();
    const fcs = formControlState({
        props,
        muiFormControl,
        states: ["error"],
    });
    const ownerState = _extends({}, props, {
        row,
        error: fcs.error,
    });
    const classes = useUtilityClasses$s(ownerState);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
        FormGroupRoot,
        _extends(
            {
                className: clsx$1(classes.root, className),
                ownerState,
                ref,
            },
            other
        )
    );
});
const FormGroup$1 = FormGroup;
function getFormHelperTextUtilityClasses(slot) {
    return generateUtilityClass("MuiFormHelperText", slot);
}
const formHelperTextClasses = generateUtilityClasses("MuiFormHelperText", ["root", "error", "disabled", "sizeSmall", "sizeMedium", "contained", "focused", "filled", "required"]);
const formHelperTextClasses$1 = formHelperTextClasses;
var _span$3;
const _excluded$x = ["children", "className", "component", "disabled", "error", "filled", "focused", "margin", "required", "variant"];
const useUtilityClasses$r = (ownerState) => {
    const { classes, contained, size, disabled, error, filled, focused, required } = ownerState;
    const slots = {
        root: ["root", disabled && "disabled", error && "error", size && `size${capitalize(size)}`, contained && "contained", focused && "focused", filled && "filled", required && "required"],
    };
    return composeClasses(slots, getFormHelperTextUtilityClasses, classes);
};
const FormHelperTextRoot = styled$1("p", {
    name: "MuiFormHelperText",
    slot: "Root",
    overridesResolver: (props, styles2) => {
        const { ownerState } = props;
        return [styles2.root, ownerState.size && styles2[`size${capitalize(ownerState.size)}`], ownerState.contained && styles2.contained, ownerState.filled && styles2.filled];
    },
})(({ theme, ownerState }) =>
    _extends(
        {
            color: (theme.vars || theme).palette.text.secondary,
        },
        theme.typography.caption,
        {
            textAlign: "left",
            marginTop: 3,
            marginRight: 0,
            marginBottom: 0,
            marginLeft: 0,
            [`&.${formHelperTextClasses$1.disabled}`]: {
                color: (theme.vars || theme).palette.text.disabled,
            },
            [`&.${formHelperTextClasses$1.error}`]: {
                color: (theme.vars || theme).palette.error.main,
            },
        },
        ownerState.size === "small" && {
            marginTop: 4,
        },
        ownerState.contained && {
            marginLeft: 14,
            marginRight: 14,
        }
    )
);
const FormHelperText = /* @__PURE__ */ reactExports.forwardRef(function FormHelperText2(inProps, ref) {
    const props = useThemeProps({
        props: inProps,
        name: "MuiFormHelperText",
    });
    const { children, className, component = "p" } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded$x);
    const muiFormControl = useFormControl();
    const fcs = formControlState({
        props,
        muiFormControl,
        states: ["variant", "size", "disabled", "error", "filled", "focused", "required"],
    });
    const ownerState = _extends({}, props, {
        component,
        contained: fcs.variant === "filled" || fcs.variant === "outlined",
        variant: fcs.variant,
        size: fcs.size,
        disabled: fcs.disabled,
        error: fcs.error,
        filled: fcs.filled,
        focused: fcs.focused,
        required: fcs.required,
    });
    const classes = useUtilityClasses$r(ownerState);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
        FormHelperTextRoot,
        _extends(
            {
                as: component,
                ownerState,
                className: clsx$1(classes.root, className),
                ref,
            },
            other,
            {
                children:
                    children === " "
                        ? // notranslate needed while Google Translate will not fix zero-width space issue
                          _span$3 ||
                          (_span$3 = /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
                              className: "notranslate",
                              children: "",
                          }))
                        : children,
            }
        )
    );
});
const FormHelperText$1 = FormHelperText;
function getFormLabelUtilityClasses(slot) {
    return generateUtilityClass("MuiFormLabel", slot);
}
const formLabelClasses = generateUtilityClasses("MuiFormLabel", ["root", "colorSecondary", "focused", "disabled", "error", "filled", "required", "asterisk"]);
const formLabelClasses$1 = formLabelClasses;
const _excluded$w = ["children", "className", "color", "component", "disabled", "error", "filled", "focused", "required"];
const useUtilityClasses$q = (ownerState) => {
    const { classes, color: color2, focused, disabled, error, filled, required } = ownerState;
    const slots = {
        root: ["root", `color${capitalize(color2)}`, disabled && "disabled", error && "error", filled && "filled", focused && "focused", required && "required"],
        asterisk: ["asterisk", error && "error"],
    };
    return composeClasses(slots, getFormLabelUtilityClasses, classes);
};
const FormLabelRoot = styled$1("label", {
    name: "MuiFormLabel",
    slot: "Root",
    overridesResolver: ({ ownerState }, styles2) => {
        return _extends({}, styles2.root, ownerState.color === "secondary" && styles2.colorSecondary, ownerState.filled && styles2.filled);
    },
})(({ theme, ownerState }) =>
    _extends(
        {
            color: (theme.vars || theme).palette.text.secondary,
        },
        theme.typography.body1,
        {
            lineHeight: "1.4375em",
            padding: 0,
            position: "relative",
            [`&.${formLabelClasses$1.focused}`]: {
                color: (theme.vars || theme).palette[ownerState.color].main,
            },
            [`&.${formLabelClasses$1.disabled}`]: {
                color: (theme.vars || theme).palette.text.disabled,
            },
            [`&.${formLabelClasses$1.error}`]: {
                color: (theme.vars || theme).palette.error.main,
            },
        }
    )
);
const AsteriskComponent = styled$1("span", {
    name: "MuiFormLabel",
    slot: "Asterisk",
    overridesResolver: (props, styles2) => styles2.asterisk,
})(({ theme }) => ({
    [`&.${formLabelClasses$1.error}`]: {
        color: (theme.vars || theme).palette.error.main,
    },
}));
const FormLabel = /* @__PURE__ */ reactExports.forwardRef(function FormLabel2(inProps, ref) {
    const props = useThemeProps({
        props: inProps,
        name: "MuiFormLabel",
    });
    const { children, className, component = "label" } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded$w);
    const muiFormControl = useFormControl();
    const fcs = formControlState({
        props,
        muiFormControl,
        states: ["color", "required", "focused", "disabled", "error", "filled"],
    });
    const ownerState = _extends({}, props, {
        color: fcs.color || "primary",
        component,
        disabled: fcs.disabled,
        error: fcs.error,
        filled: fcs.filled,
        focused: fcs.focused,
        required: fcs.required,
    });
    const classes = useUtilityClasses$q(ownerState);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        FormLabelRoot,
        _extends(
            {
                as: component,
                ownerState,
                className: clsx$1(classes.root, className),
                ref,
            },
            other,
            {
                children: [
                    children,
                    fcs.required &&
                        /* @__PURE__ */ jsxRuntimeExports.jsxs(AsteriskComponent, {
                            ownerState,
                            "aria-hidden": true,
                            className: classes.asterisk,
                            children: ["", "*"],
                        }),
                ],
            }
        )
    );
});
const FormLabel$1 = FormLabel;
const GridContext = /* @__PURE__ */ reactExports.createContext();
const GridContext$1 = GridContext;
function getGridUtilityClass(slot) {
    return generateUtilityClass("MuiGrid", slot);
}
const SPACINGS = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
const DIRECTIONS = ["column-reverse", "column", "row-reverse", "row"];
const WRAPS = ["nowrap", "wrap-reverse", "wrap"];
const GRID_SIZES = ["auto", true, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];
const gridClasses = generateUtilityClasses("MuiGrid", [
    "root",
    "container",
    "item",
    "zeroMinWidth",
    // spacings
    ...SPACINGS.map((spacing) => `spacing-xs-${spacing}`),
    // direction values
    ...DIRECTIONS.map((direction) => `direction-xs-${direction}`),
    // wrap values
    ...WRAPS.map((wrap) => `wrap-xs-${wrap}`),
    // grid sizes for all breakpoints
    ...GRID_SIZES.map((size) => `grid-xs-${size}`),
    ...GRID_SIZES.map((size) => `grid-sm-${size}`),
    ...GRID_SIZES.map((size) => `grid-md-${size}`),
    ...GRID_SIZES.map((size) => `grid-lg-${size}`),
    ...GRID_SIZES.map((size) => `grid-xl-${size}`),
]);
const _excluded$v = ["className", "columns", "columnSpacing", "component", "container", "direction", "item", "rowSpacing", "spacing", "wrap", "zeroMinWidth"];
function getOffset(val) {
    const parse2 = parseFloat(val);
    return `${parse2}${String(val).replace(String(parse2), "") || "px"}`;
}
function generateGrid({ theme, ownerState }) {
    let size;
    return theme.breakpoints.keys.reduce((globalStyles, breakpoint) => {
        let styles2 = {};
        if (ownerState[breakpoint]) {
            size = ownerState[breakpoint];
        }
        if (!size) {
            return globalStyles;
        }
        if (size === true) {
            styles2 = {
                flexBasis: 0,
                flexGrow: 1,
                maxWidth: "100%",
            };
        } else if (size === "auto") {
            styles2 = {
                flexBasis: "auto",
                flexGrow: 0,
                flexShrink: 0,
                maxWidth: "none",
                width: "auto",
            };
        } else {
            const columnsBreakpointValues = resolveBreakpointValues({
                values: ownerState.columns,
                breakpoints: theme.breakpoints.values,
            });
            const columnValue = typeof columnsBreakpointValues === "object" ? columnsBreakpointValues[breakpoint] : columnsBreakpointValues;
            if (columnValue === void 0 || columnValue === null) {
                return globalStyles;
            }
            const width2 = `${Math.round((size / columnValue) * 1e8) / 1e6}%`;
            let more = {};
            if (ownerState.container && ownerState.item && ownerState.columnSpacing !== 0) {
                const themeSpacing = theme.spacing(ownerState.columnSpacing);
                if (themeSpacing !== "0px") {
                    const fullWidth = `calc(${width2} + ${getOffset(themeSpacing)})`;
                    more = {
                        flexBasis: fullWidth,
                        maxWidth: fullWidth,
                    };
                }
            }
            styles2 = _extends(
                {
                    flexBasis: width2,
                    flexGrow: 0,
                    maxWidth: width2,
                },
                more
            );
        }
        if (theme.breakpoints.values[breakpoint] === 0) {
            Object.assign(globalStyles, styles2);
        } else {
            globalStyles[theme.breakpoints.up(breakpoint)] = styles2;
        }
        return globalStyles;
    }, {});
}
function generateDirection({ theme, ownerState }) {
    const directionValues = resolveBreakpointValues({
        values: ownerState.direction,
        breakpoints: theme.breakpoints.values,
    });
    return handleBreakpoints(
        {
            theme,
        },
        directionValues,
        (propValue) => {
            const output = {
                flexDirection: propValue,
            };
            if (propValue.indexOf("column") === 0) {
                output[`& > .${gridClasses.item}`] = {
                    maxWidth: "none",
                };
            }
            return output;
        }
    );
}
function extractZeroValueBreakpointKeys({ breakpoints, values: values2 }) {
    let nonZeroKey = "";
    Object.keys(values2).forEach((key) => {
        if (nonZeroKey !== "") {
            return;
        }
        if (values2[key] !== 0) {
            nonZeroKey = key;
        }
    });
    const sortedBreakpointKeysByValue = Object.keys(breakpoints).sort((a, b2) => {
        return breakpoints[a] - breakpoints[b2];
    });
    return sortedBreakpointKeysByValue.slice(0, sortedBreakpointKeysByValue.indexOf(nonZeroKey));
}
function generateRowGap({ theme, ownerState }) {
    const { container: container2, rowSpacing } = ownerState;
    let styles2 = {};
    if (container2 && rowSpacing !== 0) {
        const rowSpacingValues = resolveBreakpointValues({
            values: rowSpacing,
            breakpoints: theme.breakpoints.values,
        });
        let zeroValueBreakpointKeys;
        if (typeof rowSpacingValues === "object") {
            zeroValueBreakpointKeys = extractZeroValueBreakpointKeys({
                breakpoints: theme.breakpoints.values,
                values: rowSpacingValues,
            });
        }
        styles2 = handleBreakpoints(
            {
                theme,
            },
            rowSpacingValues,
            (propValue, breakpoint) => {
                var _zeroValueBreakpointK;
                const themeSpacing = theme.spacing(propValue);
                if (themeSpacing !== "0px") {
                    return {
                        marginTop: `-${getOffset(themeSpacing)}`,
                        [`& > .${gridClasses.item}`]: {
                            paddingTop: getOffset(themeSpacing),
                        },
                    };
                }
                if ((_zeroValueBreakpointK = zeroValueBreakpointKeys) != null && _zeroValueBreakpointK.includes(breakpoint)) {
                    return {};
                }
                return {
                    marginTop: 0,
                    [`& > .${gridClasses.item}`]: {
                        paddingTop: 0,
                    },
                };
            }
        );
    }
    return styles2;
}
function generateColumnGap({ theme, ownerState }) {
    const { container: container2, columnSpacing } = ownerState;
    let styles2 = {};
    if (container2 && columnSpacing !== 0) {
        const columnSpacingValues = resolveBreakpointValues({
            values: columnSpacing,
            breakpoints: theme.breakpoints.values,
        });
        let zeroValueBreakpointKeys;
        if (typeof columnSpacingValues === "object") {
            zeroValueBreakpointKeys = extractZeroValueBreakpointKeys({
                breakpoints: theme.breakpoints.values,
                values: columnSpacingValues,
            });
        }
        styles2 = handleBreakpoints(
            {
                theme,
            },
            columnSpacingValues,
            (propValue, breakpoint) => {
                var _zeroValueBreakpointK2;
                const themeSpacing = theme.spacing(propValue);
                if (themeSpacing !== "0px") {
                    return {
                        width: `calc(100% + ${getOffset(themeSpacing)})`,
                        marginLeft: `-${getOffset(themeSpacing)}`,
                        [`& > .${gridClasses.item}`]: {
                            paddingLeft: getOffset(themeSpacing),
                        },
                    };
                }
                if ((_zeroValueBreakpointK2 = zeroValueBreakpointKeys) != null && _zeroValueBreakpointK2.includes(breakpoint)) {
                    return {};
                }
                return {
                    width: "100%",
                    marginLeft: 0,
                    [`& > .${gridClasses.item}`]: {
                        paddingLeft: 0,
                    },
                };
            }
        );
    }
    return styles2;
}
function resolveSpacingStyles(spacing, breakpoints, styles2 = {}) {
    if (!spacing || spacing <= 0) {
        return [];
    }
    if ((typeof spacing === "string" && !Number.isNaN(Number(spacing))) || typeof spacing === "number") {
        return [styles2[`spacing-xs-${String(spacing)}`]];
    }
    const spacingStyles = [];
    breakpoints.forEach((breakpoint) => {
        const value = spacing[breakpoint];
        if (Number(value) > 0) {
            spacingStyles.push(styles2[`spacing-${breakpoint}-${String(value)}`]);
        }
    });
    return spacingStyles;
}
const GridRoot = styled$1("div", {
    name: "MuiGrid",
    slot: "Root",
    overridesResolver: (props, styles2) => {
        const { ownerState } = props;
        const { container: container2, direction, item, spacing, wrap, zeroMinWidth, breakpoints } = ownerState;
        let spacingStyles = [];
        if (container2) {
            spacingStyles = resolveSpacingStyles(spacing, breakpoints, styles2);
        }
        const breakpointsStyles = [];
        breakpoints.forEach((breakpoint) => {
            const value = ownerState[breakpoint];
            if (value) {
                breakpointsStyles.push(styles2[`grid-${breakpoint}-${String(value)}`]);
            }
        });
        return [
            styles2.root,
            container2 && styles2.container,
            item && styles2.item,
            zeroMinWidth && styles2.zeroMinWidth,
            ...spacingStyles,
            direction !== "row" && styles2[`direction-xs-${String(direction)}`],
            wrap !== "wrap" && styles2[`wrap-xs-${String(wrap)}`],
            ...breakpointsStyles,
        ];
    },
})(
    ({ ownerState }) =>
        _extends(
            {
                boxSizing: "border-box",
            },
            ownerState.container && {
                display: "flex",
                flexWrap: "wrap",
                width: "100%",
            },
            ownerState.item && {
                margin: 0,
                // For instance, it's useful when used with a `figure` element.
            },
            ownerState.zeroMinWidth && {
                minWidth: 0,
            },
            ownerState.wrap !== "wrap" && {
                flexWrap: ownerState.wrap,
            }
        ),
    generateDirection,
    generateRowGap,
    generateColumnGap,
    generateGrid
);
function resolveSpacingClasses(spacing, breakpoints) {
    if (!spacing || spacing <= 0) {
        return [];
    }
    if ((typeof spacing === "string" && !Number.isNaN(Number(spacing))) || typeof spacing === "number") {
        return [`spacing-xs-${String(spacing)}`];
    }
    const classes = [];
    breakpoints.forEach((breakpoint) => {
        const value = spacing[breakpoint];
        if (Number(value) > 0) {
            const className = `spacing-${breakpoint}-${String(value)}`;
            classes.push(className);
        }
    });
    return classes;
}
const useUtilityClasses$p = (ownerState) => {
    const { classes, container: container2, direction, item, spacing, wrap, zeroMinWidth, breakpoints } = ownerState;
    let spacingClasses = [];
    if (container2) {
        spacingClasses = resolveSpacingClasses(spacing, breakpoints);
    }
    const breakpointsClasses = [];
    breakpoints.forEach((breakpoint) => {
        const value = ownerState[breakpoint];
        if (value) {
            breakpointsClasses.push(`grid-${breakpoint}-${String(value)}`);
        }
    });
    const slots = {
        root: [
            "root",
            container2 && "container",
            item && "item",
            zeroMinWidth && "zeroMinWidth",
            ...spacingClasses,
            direction !== "row" && `direction-xs-${String(direction)}`,
            wrap !== "wrap" && `wrap-xs-${String(wrap)}`,
            ...breakpointsClasses,
        ],
    };
    return composeClasses(slots, getGridUtilityClass, classes);
};
const Grid = /* @__PURE__ */ reactExports.forwardRef(function Grid2(inProps, ref) {
    const themeProps = useThemeProps({
        props: inProps,
        name: "MuiGrid",
    });
    const { breakpoints } = useTheme();
    const props = extendSxProp(themeProps);
    const {
            className,
            columns: columnsProp,
            columnSpacing: columnSpacingProp,
            component = "div",
            container: container2 = false,
            direction = "row",
            item = false,
            rowSpacing: rowSpacingProp,
            spacing = 0,
            wrap = "wrap",
            zeroMinWidth = false,
        } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded$v);
    const rowSpacing = rowSpacingProp || spacing;
    const columnSpacing = columnSpacingProp || spacing;
    const columnsContext = reactExports.useContext(GridContext$1);
    const columns = container2 ? columnsProp || 12 : columnsContext;
    const breakpointsValues = {};
    const otherFiltered = _extends({}, other);
    breakpoints.keys.forEach((breakpoint) => {
        if (other[breakpoint] != null) {
            breakpointsValues[breakpoint] = other[breakpoint];
            delete otherFiltered[breakpoint];
        }
    });
    const ownerState = _extends(
        {},
        props,
        {
            columns,
            container: container2,
            direction,
            item,
            rowSpacing,
            columnSpacing,
            wrap,
            zeroMinWidth,
            spacing,
        },
        breakpointsValues,
        {
            breakpoints: breakpoints.keys,
        }
    );
    const classes = useUtilityClasses$p(ownerState);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(GridContext$1.Provider, {
        value: columns,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            GridRoot,
            _extends(
                {
                    ownerState,
                    className: clsx$1(classes.root, className),
                    as: component,
                    ref,
                },
                otherFiltered
            )
        ),
    });
});
const Grid$1 = Grid;
const _excluded$u = ["addEndListener", "appear", "children", "easing", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "style", "timeout", "TransitionComponent"];
function getScale(value) {
    return `scale(${value}, ${value ** 2})`;
}
const styles$1 = {
    entering: {
        opacity: 1,
        transform: getScale(1),
    },
    entered: {
        opacity: 1,
        transform: "none",
    },
};
const isWebKit154 = typeof navigator !== "undefined" && /^((?!chrome|android).)*(safari|mobile)/i.test(navigator.userAgent) && /(os |version\/)15(.|_)4/i.test(navigator.userAgent);
const Grow = /* @__PURE__ */ reactExports.forwardRef(function Grow2(props, ref) {
    const {
            addEndListener,
            appear = true,
            children,
            easing: easing2,
            in: inProp,
            onEnter,
            onEntered,
            onEntering,
            onExit,
            onExited,
            onExiting,
            style: style2,
            timeout = "auto",
            // eslint-disable-next-line react/prop-types
            TransitionComponent = Transition,
        } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded$u);
    const timer = reactExports.useRef();
    const autoTimeout = reactExports.useRef();
    const theme = useTheme();
    const nodeRef = reactExports.useRef(null);
    const handleRef = useForkRef(nodeRef, children.ref, ref);
    const normalizedTransitionCallback = (callback) => (maybeIsAppearing) => {
        if (callback) {
            const node2 = nodeRef.current;
            if (maybeIsAppearing === void 0) {
                callback(node2);
            } else {
                callback(node2, maybeIsAppearing);
            }
        }
    };
    const handleEntering = normalizedTransitionCallback(onEntering);
    const handleEnter = normalizedTransitionCallback((node2, isAppearing) => {
        reflow(node2);
        const {
            duration: transitionDuration,
            delay,
            easing: transitionTimingFunction,
        } = getTransitionProps(
            {
                style: style2,
                timeout,
                easing: easing2,
            },
            {
                mode: "enter",
            }
        );
        let duration2;
        if (timeout === "auto") {
            duration2 = theme.transitions.getAutoHeightDuration(node2.clientHeight);
            autoTimeout.current = duration2;
        } else {
            duration2 = transitionDuration;
        }
        node2.style.transition = [
            theme.transitions.create("opacity", {
                duration: duration2,
                delay,
            }),
            theme.transitions.create("transform", {
                duration: isWebKit154 ? duration2 : duration2 * 0.666,
                delay,
                easing: transitionTimingFunction,
            }),
        ].join(",");
        if (onEnter) {
            onEnter(node2, isAppearing);
        }
    });
    const handleEntered = normalizedTransitionCallback(onEntered);
    const handleExiting = normalizedTransitionCallback(onExiting);
    const handleExit = normalizedTransitionCallback((node2) => {
        const {
            duration: transitionDuration,
            delay,
            easing: transitionTimingFunction,
        } = getTransitionProps(
            {
                style: style2,
                timeout,
                easing: easing2,
            },
            {
                mode: "exit",
            }
        );
        let duration2;
        if (timeout === "auto") {
            duration2 = theme.transitions.getAutoHeightDuration(node2.clientHeight);
            autoTimeout.current = duration2;
        } else {
            duration2 = transitionDuration;
        }
        node2.style.transition = [
            theme.transitions.create("opacity", {
                duration: duration2,
                delay,
            }),
            theme.transitions.create("transform", {
                duration: isWebKit154 ? duration2 : duration2 * 0.666,
                delay: isWebKit154 ? delay : delay || duration2 * 0.333,
                easing: transitionTimingFunction,
            }),
        ].join(",");
        node2.style.opacity = 0;
        node2.style.transform = getScale(0.75);
        if (onExit) {
            onExit(node2);
        }
    });
    const handleExited = normalizedTransitionCallback(onExited);
    const handleAddEndListener = (next2) => {
        if (timeout === "auto") {
            timer.current = setTimeout(next2, autoTimeout.current || 0);
        }
        if (addEndListener) {
            addEndListener(nodeRef.current, next2);
        }
    };
    reactExports.useEffect(() => {
        return () => {
            clearTimeout(timer.current);
        };
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
        TransitionComponent,
        _extends(
            {
                appear,
                in: inProp,
                nodeRef,
                onEnter: handleEnter,
                onEntered: handleEntered,
                onEntering: handleEntering,
                onExit: handleExit,
                onExited: handleExited,
                onExiting: handleExiting,
                addEndListener: handleAddEndListener,
                timeout: timeout === "auto" ? null : timeout,
            },
            other,
            {
                children: (state, childProps) => {
                    return /* @__PURE__ */ reactExports.cloneElement(
                        children,
                        _extends(
                            {
                                style: _extends(
                                    {
                                        opacity: 0,
                                        transform: getScale(0.75),
                                        visibility: state === "exited" && !inProp ? "hidden" : void 0,
                                    },
                                    styles$1[state],
                                    style2,
                                    children.props.style
                                ),
                                ref: handleRef,
                            },
                            childProps
                        )
                    );
                },
            }
        )
    );
});
Grow.muiSupportAuto = true;
const Grow$1 = Grow;
const _excluded$t = ["disableUnderline", "components", "componentsProps", "fullWidth", "inputComponent", "multiline", "slotProps", "slots", "type"];
const useUtilityClasses$o = (ownerState) => {
    const { classes, disableUnderline } = ownerState;
    const slots = {
        root: ["root", !disableUnderline && "underline"],
        input: ["input"],
    };
    const composedClasses = composeClasses(slots, getInputUtilityClass, classes);
    return _extends({}, classes, composedClasses);
};
const InputRoot = styled$1(InputBaseRoot, {
    shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
    name: "MuiInput",
    slot: "Root",
    overridesResolver: (props, styles2) => {
        const { ownerState } = props;
        return [...rootOverridesResolver(props, styles2), !ownerState.disableUnderline && styles2.underline];
    },
})(({ theme, ownerState }) => {
    const light2 = theme.palette.mode === "light";
    let bottomLineColor = light2 ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)";
    if (theme.vars) {
        bottomLineColor = `rgba(${theme.vars.palette.common.onBackgroundChannel} / ${theme.vars.opacity.inputUnderline})`;
    }
    return _extends(
        {
            position: "relative",
        },
        ownerState.formControl && {
            "label + &": {
                marginTop: 16,
            },
        },
        !ownerState.disableUnderline && {
            "&:after": {
                borderBottom: `2px solid ${(theme.vars || theme).palette[ownerState.color].main}`,
                left: 0,
                bottom: 0,
                // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
                content: '""',
                position: "absolute",
                right: 0,
                transform: "scaleX(0)",
                transition: theme.transitions.create("transform", {
                    duration: theme.transitions.duration.shorter,
                    easing: theme.transitions.easing.easeOut,
                }),
                pointerEvents: "none",
                // Transparent to the hover style.
            },
            [`&.${inputClasses$1.focused}:after`]: {
                // translateX(0) is a workaround for Safari transform scale bug
                // See https://github.com/mui/material-ui/issues/31766
                transform: "scaleX(1) translateX(0)",
            },
            [`&.${inputClasses$1.error}`]: {
                "&:before, &:after": {
                    borderBottomColor: (theme.vars || theme).palette.error.main,
                },
            },
            "&:before": {
                borderBottom: `1px solid ${bottomLineColor}`,
                left: 0,
                bottom: 0,
                // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
                content: '"\\00a0"',
                position: "absolute",
                right: 0,
                transition: theme.transitions.create("border-bottom-color", {
                    duration: theme.transitions.duration.shorter,
                }),
                pointerEvents: "none",
                // Transparent to the hover style.
            },
            [`&:hover:not(.${inputClasses$1.disabled}, .${inputClasses$1.error}):before`]: {
                borderBottom: `2px solid ${(theme.vars || theme).palette.text.primary}`,
                // Reset on touch devices, it doesn't add specificity
                "@media (hover: none)": {
                    borderBottom: `1px solid ${bottomLineColor}`,
                },
            },
            [`&.${inputClasses$1.disabled}:before`]: {
                borderBottomStyle: "dotted",
            },
        }
    );
});
const InputInput = styled$1(InputBaseComponent, {
    name: "MuiInput",
    slot: "Input",
    overridesResolver: inputOverridesResolver,
})({});
const Input = /* @__PURE__ */ reactExports.forwardRef(function Input2(inProps, ref) {
    var _ref, _slots$root, _ref2, _slots$input;
    const props = useThemeProps({
        props: inProps,
        name: "MuiInput",
    });
    const { disableUnderline, components = {}, componentsProps: componentsPropsProp, fullWidth = false, inputComponent = "input", multiline = false, slotProps, slots = {}, type = "text" } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded$t);
    const classes = useUtilityClasses$o(props);
    const ownerState = {
        disableUnderline,
    };
    const inputComponentsProps = {
        root: {
            ownerState,
        },
    };
    const componentsProps = (slotProps != null ? slotProps : componentsPropsProp) ? deepmerge(slotProps != null ? slotProps : componentsPropsProp, inputComponentsProps) : inputComponentsProps;
    const RootSlot = (_ref = (_slots$root = slots.root) != null ? _slots$root : components.Root) != null ? _ref : InputRoot;
    const InputSlot = (_ref2 = (_slots$input = slots.input) != null ? _slots$input : components.Input) != null ? _ref2 : InputInput;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
        InputBase$1,
        _extends(
            {
                slots: {
                    root: RootSlot,
                    input: InputSlot,
                },
                slotProps: componentsProps,
                fullWidth,
                inputComponent,
                multiline,
                ref,
                type,
            },
            other,
            {
                classes,
            }
        )
    );
});
Input.muiName = "Input";
const Input$1 = Input;
function getInputAdornmentUtilityClass(slot) {
    return generateUtilityClass("MuiInputAdornment", slot);
}
const inputAdornmentClasses = generateUtilityClasses("MuiInputAdornment", [
    "root",
    "filled",
    "standard",
    "outlined",
    "positionStart",
    "positionEnd",
    "disablePointerEvents",
    "hiddenLabel",
    "sizeSmall",
]);
const inputAdornmentClasses$1 = inputAdornmentClasses;
var _span$2;
const _excluded$s = ["children", "className", "component", "disablePointerEvents", "disableTypography", "position", "variant"];
const overridesResolver$1 = (props, styles2) => {
    const { ownerState } = props;
    return [styles2.root, styles2[`position${capitalize(ownerState.position)}`], ownerState.disablePointerEvents === true && styles2.disablePointerEvents, styles2[ownerState.variant]];
};
const useUtilityClasses$n = (ownerState) => {
    const { classes, disablePointerEvents, hiddenLabel, position: position2, size, variant } = ownerState;
    const slots = {
        root: ["root", disablePointerEvents && "disablePointerEvents", position2 && `position${capitalize(position2)}`, variant, hiddenLabel && "hiddenLabel", size && `size${capitalize(size)}`],
    };
    return composeClasses(slots, getInputAdornmentUtilityClass, classes);
};
const InputAdornmentRoot = styled$1("div", {
    name: "MuiInputAdornment",
    slot: "Root",
    overridesResolver: overridesResolver$1,
})(({ theme, ownerState }) =>
    _extends(
        {
            display: "flex",
            height: "0.01em",
            // Fix IE11 flexbox alignment. To remove at some point.
            maxHeight: "2em",
            alignItems: "center",
            whiteSpace: "nowrap",
            color: (theme.vars || theme).palette.action.active,
        },
        ownerState.variant === "filled" && {
            // Styles applied to the root element if `variant="filled"`.
            [`&.${inputAdornmentClasses$1.positionStart}&:not(.${inputAdornmentClasses$1.hiddenLabel})`]: {
                marginTop: 16,
            },
        },
        ownerState.position === "start" && {
            // Styles applied to the root element if `position="start"`.
            marginRight: 8,
        },
        ownerState.position === "end" && {
            // Styles applied to the root element if `position="end"`.
            marginLeft: 8,
        },
        ownerState.disablePointerEvents === true && {
            // Styles applied to the root element if `disablePointerEvents={true}`.
            pointerEvents: "none",
        }
    )
);
const InputAdornment = /* @__PURE__ */ reactExports.forwardRef(function InputAdornment2(inProps, ref) {
    const props = useThemeProps({
        props: inProps,
        name: "MuiInputAdornment",
    });
    const { children, className, component = "div", disablePointerEvents = false, disableTypography = false, position: position2, variant: variantProp } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded$s);
    const muiFormControl = useFormControl() || {};
    let variant = variantProp;
    if (variantProp && muiFormControl.variant);
    if (muiFormControl && !variant) {
        variant = muiFormControl.variant;
    }
    const ownerState = _extends({}, props, {
        hiddenLabel: muiFormControl.hiddenLabel,
        size: muiFormControl.size,
        disablePointerEvents,
        position: position2,
        variant,
    });
    const classes = useUtilityClasses$n(ownerState);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(FormControlContext$1.Provider, {
        value: null,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            InputAdornmentRoot,
            _extends(
                {
                    as: component,
                    ownerState,
                    className: clsx$1(classes.root, className),
                    ref,
                },
                other,
                {
                    children:
                        typeof children === "string" && !disableTypography
                            ? /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, {
                                  color: "text.secondary",
                                  children,
                              })
                            : /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
                                  children: [
                                      position2 === "start"
                                          ? /* notranslate needed while Google Translate will not fix zero-width space issue */
                                            _span$2 ||
                                            (_span$2 = /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
                                                className: "notranslate",
                                                children: "",
                                            }))
                                          : null,
                                      children,
                                  ],
                              }),
                }
            )
        ),
    });
});
const InputAdornment$1 = InputAdornment;
function getInputLabelUtilityClasses(slot) {
    return generateUtilityClass("MuiInputLabel", slot);
}
generateUtilityClasses("MuiInputLabel", ["root", "focused", "disabled", "error", "required", "asterisk", "formControl", "sizeSmall", "shrink", "animated", "standard", "filled", "outlined"]);
const _excluded$r = ["disableAnimation", "margin", "shrink", "variant", "className"];
const useUtilityClasses$m = (ownerState) => {
    const { classes, formControl, size, shrink, disableAnimation, variant, required } = ownerState;
    const slots = {
        root: ["root", formControl && "formControl", !disableAnimation && "animated", shrink && "shrink", size === "small" && "sizeSmall", variant],
        asterisk: [required && "asterisk"],
    };
    const composedClasses = composeClasses(slots, getInputLabelUtilityClasses, classes);
    return _extends({}, classes, composedClasses);
};
const InputLabelRoot = styled$1(FormLabel$1, {
    shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
    name: "MuiInputLabel",
    slot: "Root",
    overridesResolver: (props, styles2) => {
        const { ownerState } = props;
        return [
            {
                [`& .${formLabelClasses$1.asterisk}`]: styles2.asterisk,
            },
            styles2.root,
            ownerState.formControl && styles2.formControl,
            ownerState.size === "small" && styles2.sizeSmall,
            ownerState.shrink && styles2.shrink,
            !ownerState.disableAnimation && styles2.animated,
            styles2[ownerState.variant],
        ];
    },
})(({ theme, ownerState }) =>
    _extends(
        {
            display: "block",
            transformOrigin: "top left",
            whiteSpace: "nowrap",
            overflow: "hidden",
            textOverflow: "ellipsis",
            maxWidth: "100%",
        },
        ownerState.formControl && {
            position: "absolute",
            left: 0,
            top: 0,
            // slight alteration to spec spacing to match visual spec result
            transform: "translate(0, 20px) scale(1)",
        },
        ownerState.size === "small" && {
            // Compensation for the `Input.inputSizeSmall` style.
            transform: "translate(0, 17px) scale(1)",
        },
        ownerState.shrink && {
            transform: "translate(0, -1.5px) scale(0.75)",
            transformOrigin: "top left",
            maxWidth: "133%",
        },
        !ownerState.disableAnimation && {
            transition: theme.transitions.create(["color", "transform", "max-width"], {
                duration: theme.transitions.duration.shorter,
                easing: theme.transitions.easing.easeOut,
            }),
        },
        ownerState.variant === "filled" &&
            _extends(
                {
                    // Chrome's autofill feature gives the input field a yellow background.
                    // Since the input field is behind the label in the HTML tree,
                    // the input field is drawn last and hides the label with an opaque background color.
                    // zIndex: 1 will raise the label above opaque background-colors of input.
                    zIndex: 1,
                    pointerEvents: "none",
                    transform: "translate(12px, 16px) scale(1)",
                    maxWidth: "calc(100% - 24px)",
                },
                ownerState.size === "small" && {
                    transform: "translate(12px, 13px) scale(1)",
                },
                ownerState.shrink &&
                    _extends(
                        {
                            userSelect: "none",
                            pointerEvents: "auto",
                            transform: "translate(12px, 7px) scale(0.75)",
                            maxWidth: "calc(133% - 24px)",
                        },
                        ownerState.size === "small" && {
                            transform: "translate(12px, 4px) scale(0.75)",
                        }
                    )
            ),
        ownerState.variant === "outlined" &&
            _extends(
                {
                    // see comment above on filled.zIndex
                    zIndex: 1,
                    pointerEvents: "none",
                    transform: "translate(14px, 16px) scale(1)",
                    maxWidth: "calc(100% - 24px)",
                },
                ownerState.size === "small" && {
                    transform: "translate(14px, 9px) scale(1)",
                },
                ownerState.shrink && {
                    userSelect: "none",
                    pointerEvents: "auto",
                    // Theoretically, we should have (8+5)*2/0.75 = 34px
                    // but it feels a better when it bleeds a bit on the left, so 32px.
                    maxWidth: "calc(133% - 32px)",
                    transform: "translate(14px, -9px) scale(0.75)",
                }
            )
    )
);
const InputLabel = /* @__PURE__ */ reactExports.forwardRef(function InputLabel2(inProps, ref) {
    const props = useThemeProps({
        name: "MuiInputLabel",
        props: inProps,
    });
    const { disableAnimation = false, shrink: shrinkProp, className } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded$r);
    const muiFormControl = useFormControl();
    let shrink = shrinkProp;
    if (typeof shrink === "undefined" && muiFormControl) {
        shrink = muiFormControl.filled || muiFormControl.focused || muiFormControl.adornedStart;
    }
    const fcs = formControlState({
        props,
        muiFormControl,
        states: ["size", "variant", "required"],
    });
    const ownerState = _extends({}, props, {
        disableAnimation,
        formControl: muiFormControl,
        shrink,
        size: fcs.size,
        variant: fcs.variant,
        required: fcs.required,
    });
    const classes = useUtilityClasses$m(ownerState);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
        InputLabelRoot,
        _extends(
            {
                "data-shrink": shrink,
                ownerState,
                ref,
                className: clsx$1(classes.root, className),
            },
            other,
            {
                classes,
            }
        )
    );
});
const InputLabel$1 = InputLabel;
const ListContext = /* @__PURE__ */ reactExports.createContext({});
const ListContext$1 = ListContext;
function getListUtilityClass(slot) {
    return generateUtilityClass("MuiList", slot);
}
generateUtilityClasses("MuiList", ["root", "padding", "dense", "subheader"]);
const _excluded$q = ["children", "className", "component", "dense", "disablePadding", "subheader"];
const useUtilityClasses$l = (ownerState) => {
    const { classes, disablePadding, dense, subheader } = ownerState;
    const slots = {
        root: ["root", !disablePadding && "padding", dense && "dense", subheader && "subheader"],
    };
    return composeClasses(slots, getListUtilityClass, classes);
};
const ListRoot = styled$1("ul", {
    name: "MuiList",
    slot: "Root",
    overridesResolver: (props, styles2) => {
        const { ownerState } = props;
        return [styles2.root, !ownerState.disablePadding && styles2.padding, ownerState.dense && styles2.dense, ownerState.subheader && styles2.subheader];
    },
})(({ ownerState }) =>
    _extends(
        {
            listStyle: "none",
            margin: 0,
            padding: 0,
            position: "relative",
        },
        !ownerState.disablePadding && {
            paddingTop: 8,
            paddingBottom: 8,
        },
        ownerState.subheader && {
            paddingTop: 0,
        }
    )
);
const List = /* @__PURE__ */ reactExports.forwardRef(function List2(inProps, ref) {
    const props = useThemeProps({
        props: inProps,
        name: "MuiList",
    });
    const { children, className, component = "ul", dense = false, disablePadding = false, subheader } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded$q);
    const context = reactExports.useMemo(
        () => ({
            dense,
        }),
        [dense]
    );
    const ownerState = _extends({}, props, {
        component,
        dense,
        disablePadding,
    });
    const classes = useUtilityClasses$l(ownerState);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ListContext$1.Provider, {
        value: context,
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
            ListRoot,
            _extends(
                {
                    as: component,
                    className: clsx$1(classes.root, className),
                    ref,
                    ownerState,
                },
                other,
                {
                    children: [subheader, children],
                }
            )
        ),
    });
});
const List$1 = List;
const listItemIconClasses = generateUtilityClasses("MuiListItemIcon", ["root", "alignItemsFlexStart"]);
const listItemIconClasses$1 = listItemIconClasses;
const listItemTextClasses = generateUtilityClasses("MuiListItemText", ["root", "multiline", "dense", "inset", "primary", "secondary"]);
const listItemTextClasses$1 = listItemTextClasses;
const _excluded$p = ["actions", "autoFocus", "autoFocusItem", "children", "className", "disabledItemsFocusable", "disableListWrap", "onKeyDown", "variant"];
function nextItem$1(list, item, disableListWrap) {
    if (list === item) {
        return list.firstChild;
    }
    if (item && item.nextElementSibling) {
        return item.nextElementSibling;
    }
    return disableListWrap ? null : list.firstChild;
}
function previousItem$1(list, item, disableListWrap) {
    if (list === item) {
        return disableListWrap ? list.firstChild : list.lastChild;
    }
    if (item && item.previousElementSibling) {
        return item.previousElementSibling;
    }
    return disableListWrap ? null : list.lastChild;
}
function textCriteriaMatches(nextFocus, textCriteria) {
    if (textCriteria === void 0) {
        return true;
    }
    let text = nextFocus.innerText;
    if (text === void 0) {
        text = nextFocus.textContent;
    }
    text = text.trim().toLowerCase();
    if (text.length === 0) {
        return false;
    }
    if (textCriteria.repeating) {
        return text[0] === textCriteria.keys[0];
    }
    return text.indexOf(textCriteria.keys.join("")) === 0;
}
function moveFocus$1(list, currentFocus, disableListWrap, disabledItemsFocusable, traversalFunction, textCriteria) {
    let wrappedOnce = false;
    let nextFocus = traversalFunction(list, currentFocus, currentFocus ? disableListWrap : false);
    while (nextFocus) {
        if (nextFocus === list.firstChild) {
            if (wrappedOnce) {
                return false;
            }
            wrappedOnce = true;
        }
        const nextFocusDisabled = disabledItemsFocusable ? false : nextFocus.disabled || nextFocus.getAttribute("aria-disabled") === "true";
        if (!nextFocus.hasAttribute("tabindex") || !textCriteriaMatches(nextFocus, textCriteria) || nextFocusDisabled) {
            nextFocus = traversalFunction(list, nextFocus, disableListWrap);
        } else {
            nextFocus.focus();
            return true;
        }
    }
    return false;
}
const MenuList = /* @__PURE__ */ reactExports.forwardRef(function MenuList2(props, ref) {
    const {
            // private
            // eslint-disable-next-line react/prop-types
            actions,
            autoFocus = false,
            autoFocusItem = false,
            children,
            className,
            disabledItemsFocusable = false,
            disableListWrap = false,
            onKeyDown,
            variant = "selectedMenu",
        } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded$p);
    const listRef = reactExports.useRef(null);
    const textCriteriaRef = reactExports.useRef({
        keys: [],
        repeating: true,
        previousKeyMatched: true,
        lastTime: null,
    });
    useEnhancedEffect$1(() => {
        if (autoFocus) {
            listRef.current.focus();
        }
    }, [autoFocus]);
    reactExports.useImperativeHandle(
        actions,
        () => ({
            adjustStyleForScrollbar: (containerElement, theme) => {
                const noExplicitWidth = !listRef.current.style.width;
                if (containerElement.clientHeight < listRef.current.clientHeight && noExplicitWidth) {
                    const scrollbarSize = `${getScrollbarSize(ownerDocument(containerElement))}px`;
                    listRef.current.style[theme.direction === "rtl" ? "paddingLeft" : "paddingRight"] = scrollbarSize;
                    listRef.current.style.width = `calc(100% + ${scrollbarSize})`;
                }
                return listRef.current;
            },
        }),
        []
    );
    const handleKeyDown2 = (event) => {
        const list = listRef.current;
        const key = event.key;
        const currentFocus = ownerDocument(list).activeElement;
        if (key === "ArrowDown") {
            event.preventDefault();
            moveFocus$1(list, currentFocus, disableListWrap, disabledItemsFocusable, nextItem$1);
        } else if (key === "ArrowUp") {
            event.preventDefault();
            moveFocus$1(list, currentFocus, disableListWrap, disabledItemsFocusable, previousItem$1);
        } else if (key === "Home") {
            event.preventDefault();
            moveFocus$1(list, null, disableListWrap, disabledItemsFocusable, nextItem$1);
        } else if (key === "End") {
            event.preventDefault();
            moveFocus$1(list, null, disableListWrap, disabledItemsFocusable, previousItem$1);
        } else if (key.length === 1) {
            const criteria = textCriteriaRef.current;
            const lowerKey = key.toLowerCase();
            const currTime = performance.now();
            if (criteria.keys.length > 0) {
                if (currTime - criteria.lastTime > 500) {
                    criteria.keys = [];
                    criteria.repeating = true;
                    criteria.previousKeyMatched = true;
                } else if (criteria.repeating && lowerKey !== criteria.keys[0]) {
                    criteria.repeating = false;
                }
            }
            criteria.lastTime = currTime;
            criteria.keys.push(lowerKey);
            const keepFocusOnCurrent = currentFocus && !criteria.repeating && textCriteriaMatches(currentFocus, criteria);
            if (criteria.previousKeyMatched && (keepFocusOnCurrent || moveFocus$1(list, currentFocus, false, disabledItemsFocusable, nextItem$1, criteria))) {
                event.preventDefault();
            } else {
                criteria.previousKeyMatched = false;
            }
        }
        if (onKeyDown) {
            onKeyDown(event);
        }
    };
    const handleRef = useForkRef(listRef, ref);
    let activeItemIndex = -1;
    reactExports.Children.forEach(children, (child, index) => {
        if (!(/* @__PURE__ */ reactExports.isValidElement(child))) {
            return;
        }
        if (!child.props.disabled) {
            if (variant === "selectedMenu" && child.props.selected) {
                activeItemIndex = index;
            } else if (activeItemIndex === -1) {
                activeItemIndex = index;
            }
        }
        if (activeItemIndex === index && (child.props.disabled || child.props.muiSkipListHighlight || child.type.muiSkipListHighlight)) {
            activeItemIndex += 1;
            if (activeItemIndex >= children.length) {
                activeItemIndex = -1;
            }
        }
    });
    const items = reactExports.Children.map(children, (child, index) => {
        if (index === activeItemIndex) {
            const newChildProps = {};
            if (autoFocusItem) {
                newChildProps.autoFocus = true;
            }
            if (child.props.tabIndex === void 0 && variant === "selectedMenu") {
                newChildProps.tabIndex = 0;
            }
            return /* @__PURE__ */ reactExports.cloneElement(child, newChildProps);
        }
        return child;
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
        List$1,
        _extends(
            {
                role: "menu",
                ref: handleRef,
                className,
                onKeyDown: handleKeyDown2,
                tabIndex: autoFocus ? 0 : -1,
            },
            other,
            {
                children: items,
            }
        )
    );
});
const MenuList$1 = MenuList;
function getPopoverUtilityClass(slot) {
    return generateUtilityClass("MuiPopover", slot);
}
generateUtilityClasses("MuiPopover", ["root", "paper"]);
const _excluded$o = ["onEntering"],
    _excluded2$1 = [
        "action",
        "anchorEl",
        "anchorOrigin",
        "anchorPosition",
        "anchorReference",
        "children",
        "className",
        "container",
        "elevation",
        "marginThreshold",
        "open",
        "PaperProps",
        "transformOrigin",
        "TransitionComponent",
        "transitionDuration",
        "TransitionProps",
    ];
function getOffsetTop(rect, vertical) {
    let offset2 = 0;
    if (typeof vertical === "number") {
        offset2 = vertical;
    } else if (vertical === "center") {
        offset2 = rect.height / 2;
    } else if (vertical === "bottom") {
        offset2 = rect.height;
    }
    return offset2;
}
function getOffsetLeft(rect, horizontal) {
    let offset2 = 0;
    if (typeof horizontal === "number") {
        offset2 = horizontal;
    } else if (horizontal === "center") {
        offset2 = rect.width / 2;
    } else if (horizontal === "right") {
        offset2 = rect.width;
    }
    return offset2;
}
function getTransformOriginValue(transformOrigin) {
    return [transformOrigin.horizontal, transformOrigin.vertical].map((n2) => (typeof n2 === "number" ? `${n2}px` : n2)).join(" ");
}
function resolveAnchorEl(anchorEl) {
    return typeof anchorEl === "function" ? anchorEl() : anchorEl;
}
const useUtilityClasses$k = (ownerState) => {
    const { classes } = ownerState;
    const slots = {
        root: ["root"],
        paper: ["paper"],
    };
    return composeClasses(slots, getPopoverUtilityClass, classes);
};
const PopoverRoot = styled$1(Modal$1, {
    name: "MuiPopover",
    slot: "Root",
    overridesResolver: (props, styles2) => styles2.root,
})({});
const PopoverPaper = styled$1(Paper$1, {
    name: "MuiPopover",
    slot: "Paper",
    overridesResolver: (props, styles2) => styles2.paper,
})({
    position: "absolute",
    overflowY: "auto",
    overflowX: "hidden",
    // So we see the popover when it's empty.
    // It's most likely on issue on userland.
    minWidth: 16,
    minHeight: 16,
    maxWidth: "calc(100% - 32px)",
    maxHeight: "calc(100% - 32px)",
    // We disable the focus ring for mouse, touch and keyboard users.
    outline: 0,
});
const Popover = /* @__PURE__ */ reactExports.forwardRef(function Popover2(inProps, ref) {
    const props = useThemeProps({
        props: inProps,
        name: "MuiPopover",
    });
    const {
            action,
            anchorEl,
            anchorOrigin = {
                vertical: "top",
                horizontal: "left",
            },
            anchorPosition,
            anchorReference = "anchorEl",
            children,
            className,
            container: containerProp,
            elevation = 8,
            marginThreshold = 16,
            open: open2,
            PaperProps = {},
            transformOrigin = {
                vertical: "top",
                horizontal: "left",
            },
            TransitionComponent = Grow$1,
            transitionDuration: transitionDurationProp = "auto",
            TransitionProps: { onEntering } = {},
        } = props,
        TransitionProps = _objectWithoutPropertiesLoose(props.TransitionProps, _excluded$o),
        other = _objectWithoutPropertiesLoose(props, _excluded2$1);
    const paperRef = reactExports.useRef();
    const handlePaperRef = useForkRef(paperRef, PaperProps.ref);
    const ownerState = _extends({}, props, {
        anchorOrigin,
        anchorReference,
        elevation,
        marginThreshold,
        PaperProps,
        transformOrigin,
        TransitionComponent,
        transitionDuration: transitionDurationProp,
        TransitionProps,
    });
    const classes = useUtilityClasses$k(ownerState);
    const getAnchorOffset = reactExports.useCallback(() => {
        if (anchorReference === "anchorPosition") {
            return anchorPosition;
        }
        const resolvedAnchorEl = resolveAnchorEl(anchorEl);
        const anchorElement = resolvedAnchorEl && resolvedAnchorEl.nodeType === 1 ? resolvedAnchorEl : ownerDocument(paperRef.current).body;
        const anchorRect = anchorElement.getBoundingClientRect();
        return {
            top: anchorRect.top + getOffsetTop(anchorRect, anchorOrigin.vertical),
            left: anchorRect.left + getOffsetLeft(anchorRect, anchorOrigin.horizontal),
        };
    }, [anchorEl, anchorOrigin.horizontal, anchorOrigin.vertical, anchorPosition, anchorReference]);
    const getTransformOrigin = reactExports.useCallback(
        (elemRect) => {
            return {
                vertical: getOffsetTop(elemRect, transformOrigin.vertical),
                horizontal: getOffsetLeft(elemRect, transformOrigin.horizontal),
            };
        },
        [transformOrigin.horizontal, transformOrigin.vertical]
    );
    const getPositioningStyle = reactExports.useCallback(
        (element) => {
            const elemRect = {
                width: element.offsetWidth,
                height: element.offsetHeight,
            };
            const elemTransformOrigin = getTransformOrigin(elemRect);
            if (anchorReference === "none") {
                return {
                    top: null,
                    left: null,
                    transformOrigin: getTransformOriginValue(elemTransformOrigin),
                };
            }
            const anchorOffset = getAnchorOffset();
            let top2 = anchorOffset.top - elemTransformOrigin.vertical;
            let left2 = anchorOffset.left - elemTransformOrigin.horizontal;
            const bottom2 = top2 + elemRect.height;
            const right2 = left2 + elemRect.width;
            const containerWindow = ownerWindow(resolveAnchorEl(anchorEl));
            const heightThreshold = containerWindow.innerHeight - marginThreshold;
            const widthThreshold = containerWindow.innerWidth - marginThreshold;
            if (top2 < marginThreshold) {
                const diff = top2 - marginThreshold;
                top2 -= diff;
                elemTransformOrigin.vertical += diff;
            } else if (bottom2 > heightThreshold) {
                const diff = bottom2 - heightThreshold;
                top2 -= diff;
                elemTransformOrigin.vertical += diff;
            }
            if (left2 < marginThreshold) {
                const diff = left2 - marginThreshold;
                left2 -= diff;
                elemTransformOrigin.horizontal += diff;
            } else if (right2 > widthThreshold) {
                const diff = right2 - widthThreshold;
                left2 -= diff;
                elemTransformOrigin.horizontal += diff;
            }
            return {
                top: `${Math.round(top2)}px`,
                left: `${Math.round(left2)}px`,
                transformOrigin: getTransformOriginValue(elemTransformOrigin),
            };
        },
        [anchorEl, anchorReference, getAnchorOffset, getTransformOrigin, marginThreshold]
    );
    const [isPositioned, setIsPositioned] = reactExports.useState(open2);
    const setPositioningStyles = reactExports.useCallback(() => {
        const element = paperRef.current;
        if (!element) {
            return;
        }
        const positioning = getPositioningStyle(element);
        if (positioning.top !== null) {
            element.style.top = positioning.top;
        }
        if (positioning.left !== null) {
            element.style.left = positioning.left;
        }
        element.style.transformOrigin = positioning.transformOrigin;
        setIsPositioned(true);
    }, [getPositioningStyle]);
    const handleEntering = (element, isAppearing) => {
        if (onEntering) {
            onEntering(element, isAppearing);
        }
        setPositioningStyles();
    };
    const handleExited = () => {
        setIsPositioned(false);
    };
    reactExports.useEffect(() => {
        if (open2) {
            setPositioningStyles();
        }
    });
    reactExports.useImperativeHandle(
        action,
        () =>
            open2
                ? {
                      updatePosition: () => {
                          setPositioningStyles();
                      },
                  }
                : null,
        [open2, setPositioningStyles]
    );
    reactExports.useEffect(() => {
        if (!open2) {
            return void 0;
        }
        const handleResize = debounce$1(() => {
            setPositioningStyles();
        });
        const containerWindow = ownerWindow(anchorEl);
        containerWindow.addEventListener("resize", handleResize);
        return () => {
            handleResize.clear();
            containerWindow.removeEventListener("resize", handleResize);
        };
    }, [anchorEl, open2, setPositioningStyles]);
    let transitionDuration = transitionDurationProp;
    if (transitionDurationProp === "auto" && !TransitionComponent.muiSupportAuto) {
        transitionDuration = void 0;
    }
    const container2 = containerProp || (anchorEl ? ownerDocument(resolveAnchorEl(anchorEl)).body : void 0);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
        PopoverRoot,
        _extends(
            {
                BackdropProps: {
                    invisible: true,
                },
                className: clsx$1(classes.root, className),
                container: container2,
                open: open2,
                ref,
                ownerState,
            },
            other,
            {
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    TransitionComponent,
                    _extends(
                        {
                            appear: true,
                            in: open2,
                            onEntering: handleEntering,
                            onExited: handleExited,
                            timeout: transitionDuration,
                        },
                        TransitionProps,
                        {
                            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                                PopoverPaper,
                                _extends(
                                    {
                                        elevation,
                                    },
                                    PaperProps,
                                    {
                                        ref: handlePaperRef,
                                        className: clsx$1(classes.paper, PaperProps.className),
                                    },
                                    isPositioned
                                        ? void 0
                                        : {
                                              style: _extends({}, PaperProps.style, {
                                                  opacity: 0,
                                              }),
                                          },
                                    {
                                        ownerState,
                                        children,
                                    }
                                )
                            ),
                        }
                    )
                ),
            }
        )
    );
});
const Popover$1 = Popover;
function getMenuUtilityClass(slot) {
    return generateUtilityClass("MuiMenu", slot);
}
generateUtilityClasses("MuiMenu", ["root", "paper", "list"]);
const _excluded$n = ["onEntering"],
    _excluded2 = ["autoFocus", "children", "disableAutoFocusItem", "MenuListProps", "onClose", "open", "PaperProps", "PopoverClasses", "transitionDuration", "TransitionProps", "variant"];
const RTL_ORIGIN = {
    vertical: "top",
    horizontal: "right",
};
const LTR_ORIGIN = {
    vertical: "top",
    horizontal: "left",
};
const useUtilityClasses$j = (ownerState) => {
    const { classes } = ownerState;
    const slots = {
        root: ["root"],
        paper: ["paper"],
        list: ["list"],
    };
    return composeClasses(slots, getMenuUtilityClass, classes);
};
const MenuRoot = styled$1(Popover$1, {
    shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
    name: "MuiMenu",
    slot: "Root",
    overridesResolver: (props, styles2) => styles2.root,
})({});
const MenuPaper = styled$1(Paper$1, {
    name: "MuiMenu",
    slot: "Paper",
    overridesResolver: (props, styles2) => styles2.paper,
})({
    // specZ: The maximum height of a simple menu should be one or more rows less than the view
    // height. This ensures a tappable area outside of the simple menu with which to dismiss
    // the menu.
    maxHeight: "calc(100% - 96px)",
    // Add iOS momentum scrolling for iOS < 13.0
    WebkitOverflowScrolling: "touch",
});
const MenuMenuList = styled$1(MenuList$1, {
    name: "MuiMenu",
    slot: "List",
    overridesResolver: (props, styles2) => styles2.list,
})({
    // We disable the focus ring for mouse, touch and keyboard users.
    outline: 0,
});
const Menu = /* @__PURE__ */ reactExports.forwardRef(function Menu2(inProps, ref) {
    const props = useThemeProps({
        props: inProps,
        name: "MuiMenu",
    });
    const {
            autoFocus = true,
            children,
            disableAutoFocusItem = false,
            MenuListProps = {},
            onClose,
            open: open2,
            PaperProps = {},
            PopoverClasses,
            transitionDuration = "auto",
            TransitionProps: { onEntering } = {},
            variant = "selectedMenu",
        } = props,
        TransitionProps = _objectWithoutPropertiesLoose(props.TransitionProps, _excluded$n),
        other = _objectWithoutPropertiesLoose(props, _excluded2);
    const theme = useTheme();
    const isRtl = theme.direction === "rtl";
    const ownerState = _extends({}, props, {
        autoFocus,
        disableAutoFocusItem,
        MenuListProps,
        onEntering,
        PaperProps,
        transitionDuration,
        TransitionProps,
        variant,
    });
    const classes = useUtilityClasses$j(ownerState);
    const autoFocusItem = autoFocus && !disableAutoFocusItem && open2;
    const menuListActionsRef = reactExports.useRef(null);
    const handleEntering = (element, isAppearing) => {
        if (menuListActionsRef.current) {
            menuListActionsRef.current.adjustStyleForScrollbar(element, theme);
        }
        if (onEntering) {
            onEntering(element, isAppearing);
        }
    };
    const handleListKeyDown = (event) => {
        if (event.key === "Tab") {
            event.preventDefault();
            if (onClose) {
                onClose(event, "tabKeyDown");
            }
        }
    };
    let activeItemIndex = -1;
    reactExports.Children.map(children, (child, index) => {
        if (!(/* @__PURE__ */ reactExports.isValidElement(child))) {
            return;
        }
        if (!child.props.disabled) {
            if (variant === "selectedMenu" && child.props.selected) {
                activeItemIndex = index;
            } else if (activeItemIndex === -1) {
                activeItemIndex = index;
            }
        }
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
        MenuRoot,
        _extends(
            {
                onClose,
                anchorOrigin: {
                    vertical: "bottom",
                    horizontal: isRtl ? "right" : "left",
                },
                transformOrigin: isRtl ? RTL_ORIGIN : LTR_ORIGIN,
                PaperProps: _extends(
                    {
                        as: MenuPaper,
                    },
                    PaperProps,
                    {
                        classes: _extends({}, PaperProps.classes, {
                            root: classes.paper,
                        }),
                    }
                ),
                className: classes.root,
                open: open2,
                ref,
                transitionDuration,
                TransitionProps: _extends(
                    {
                        onEntering: handleEntering,
                    },
                    TransitionProps
                ),
                ownerState,
            },
            other,
            {
                classes: PopoverClasses,
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    MenuMenuList,
                    _extends(
                        {
                            onKeyDown: handleListKeyDown,
                            actions: menuListActionsRef,
                            autoFocus: autoFocus && (activeItemIndex === -1 || disableAutoFocusItem),
                            autoFocusItem,
                            variant,
                        },
                        MenuListProps,
                        {
                            className: clsx$1(classes.list, MenuListProps.className),
                            children,
                        }
                    )
                ),
            }
        )
    );
});
const Menu$1 = Menu;
function getMenuItemUtilityClass(slot) {
    return generateUtilityClass("MuiMenuItem", slot);
}
const menuItemClasses = generateUtilityClasses("MuiMenuItem", ["root", "focusVisible", "dense", "disabled", "divider", "gutters", "selected"]);
const menuItemClasses$1 = menuItemClasses;
const _excluded$m = ["autoFocus", "component", "dense", "divider", "disableGutters", "focusVisibleClassName", "role", "tabIndex", "className"];
const overridesResolver = (props, styles2) => {
    const { ownerState } = props;
    return [styles2.root, ownerState.dense && styles2.dense, ownerState.divider && styles2.divider, !ownerState.disableGutters && styles2.gutters];
};
const useUtilityClasses$i = (ownerState) => {
    const { disabled, dense, divider, disableGutters, selected, classes } = ownerState;
    const slots = {
        root: ["root", dense && "dense", disabled && "disabled", !disableGutters && "gutters", divider && "divider", selected && "selected"],
    };
    const composedClasses = composeClasses(slots, getMenuItemUtilityClass, classes);
    return _extends({}, classes, composedClasses);
};
const MenuItemRoot = styled$1(ButtonBase$1, {
    shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
    name: "MuiMenuItem",
    slot: "Root",
    overridesResolver,
})(({ theme, ownerState }) =>
    _extends(
        {},
        theme.typography.body1,
        {
            display: "flex",
            justifyContent: "flex-start",
            alignItems: "center",
            position: "relative",
            textDecoration: "none",
            minHeight: 48,
            paddingTop: 6,
            paddingBottom: 6,
            boxSizing: "border-box",
            whiteSpace: "nowrap",
        },
        !ownerState.disableGutters && {
            paddingLeft: 16,
            paddingRight: 16,
        },
        ownerState.divider && {
            borderBottom: `1px solid ${(theme.vars || theme).palette.divider}`,
            backgroundClip: "padding-box",
        },
        {
            "&:hover": {
                textDecoration: "none",
                backgroundColor: (theme.vars || theme).palette.action.hover,
                // Reset on touch devices, it doesn't add specificity
                "@media (hover: none)": {
                    backgroundColor: "transparent",
                },
            },
            [`&.${menuItemClasses$1.selected}`]: {
                backgroundColor: theme.vars
                    ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.selectedOpacity})`
                    : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity),
                [`&.${menuItemClasses$1.focusVisible}`]: {
                    backgroundColor: theme.vars
                        ? `rgba(${theme.vars.palette.primary.mainChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.focusOpacity}))`
                        : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity + theme.palette.action.focusOpacity),
                },
            },
            [`&.${menuItemClasses$1.selected}:hover`]: {
                backgroundColor: theme.vars
                    ? `rgba(${theme.vars.palette.primary.mainChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.hoverOpacity}))`
                    : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity + theme.palette.action.hoverOpacity),
                // Reset on touch devices, it doesn't add specificity
                "@media (hover: none)": {
                    backgroundColor: theme.vars
                        ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.selectedOpacity})`
                        : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity),
                },
            },
            [`&.${menuItemClasses$1.focusVisible}`]: {
                backgroundColor: (theme.vars || theme).palette.action.focus,
            },
            [`&.${menuItemClasses$1.disabled}`]: {
                opacity: (theme.vars || theme).palette.action.disabledOpacity,
            },
            [`& + .${dividerClasses$1.root}`]: {
                marginTop: theme.spacing(1),
                marginBottom: theme.spacing(1),
            },
            [`& + .${dividerClasses$1.inset}`]: {
                marginLeft: 52,
            },
            [`& .${listItemTextClasses$1.root}`]: {
                marginTop: 0,
                marginBottom: 0,
            },
            [`& .${listItemTextClasses$1.inset}`]: {
                paddingLeft: 36,
            },
            [`& .${listItemIconClasses$1.root}`]: {
                minWidth: 36,
            },
        },
        !ownerState.dense && {
            [theme.breakpoints.up("sm")]: {
                minHeight: "auto",
            },
        },
        ownerState.dense &&
            _extends(
                {
                    minHeight: 32,
                    // https://m2.material.io/components/menus#specs > Dense
                    paddingTop: 4,
                    paddingBottom: 4,
                },
                theme.typography.body2,
                {
                    [`& .${listItemIconClasses$1.root} svg`]: {
                        fontSize: "1.25rem",
                    },
                }
            )
    )
);
const MenuItem = /* @__PURE__ */ reactExports.forwardRef(function MenuItem2(inProps, ref) {
    const props = useThemeProps({
        props: inProps,
        name: "MuiMenuItem",
    });
    const { autoFocus = false, component = "li", dense = false, divider = false, disableGutters = false, focusVisibleClassName, role = "menuitem", tabIndex: tabIndexProp, className } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded$m);
    const context = reactExports.useContext(ListContext$1);
    const childContext = reactExports.useMemo(
        () => ({
            dense: dense || context.dense || false,
            disableGutters,
        }),
        [context.dense, dense, disableGutters]
    );
    const menuItemRef = reactExports.useRef(null);
    useEnhancedEffect$1(() => {
        if (autoFocus) {
            if (menuItemRef.current) {
                menuItemRef.current.focus();
            }
        }
    }, [autoFocus]);
    const ownerState = _extends({}, props, {
        dense: childContext.dense,
        divider,
        disableGutters,
    });
    const classes = useUtilityClasses$i(props);
    const handleRef = useForkRef(menuItemRef, ref);
    let tabIndex;
    if (!props.disabled) {
        tabIndex = tabIndexProp !== void 0 ? tabIndexProp : -1;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ListContext$1.Provider, {
        value: childContext,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            MenuItemRoot,
            _extends(
                {
                    ref: handleRef,
                    role,
                    tabIndex,
                    component,
                    focusVisibleClassName: clsx$1(classes.focusVisible, focusVisibleClassName),
                    className: clsx$1(classes.root, className),
                },
                other,
                {
                    ownerState,
                    classes,
                }
            )
        ),
    });
});
const MenuItem$1 = MenuItem;
function getNativeSelectUtilityClasses(slot) {
    return generateUtilityClass("MuiNativeSelect", slot);
}
const nativeSelectClasses = generateUtilityClasses("MuiNativeSelect", [
    "root",
    "select",
    "multiple",
    "filled",
    "outlined",
    "standard",
    "disabled",
    "icon",
    "iconOpen",
    "iconFilled",
    "iconOutlined",
    "iconStandard",
    "nativeInput",
    "error",
]);
const nativeSelectClasses$1 = nativeSelectClasses;
const _excluded$l = ["className", "disabled", "error", "IconComponent", "inputRef", "variant"];
const useUtilityClasses$h = (ownerState) => {
    const { classes, variant, disabled, multiple, open: open2, error } = ownerState;
    const slots = {
        select: ["select", variant, disabled && "disabled", multiple && "multiple", error && "error"],
        icon: ["icon", `icon${capitalize(variant)}`, open2 && "iconOpen", disabled && "disabled"],
    };
    return composeClasses(slots, getNativeSelectUtilityClasses, classes);
};
const nativeSelectSelectStyles = ({ ownerState, theme }) =>
    _extends(
        {
            MozAppearance: "none",
            // Reset
            WebkitAppearance: "none",
            // Reset
            // When interacting quickly, the text can end up selected.
            // Native select can't be selected either.
            userSelect: "none",
            borderRadius: 0,
            // Reset
            cursor: "pointer",
            "&:focus": _extends(
                {},
                theme.vars
                    ? {
                          backgroundColor: `rgba(${theme.vars.palette.common.onBackgroundChannel} / 0.05)`,
                      }
                    : {
                          backgroundColor: theme.palette.mode === "light" ? "rgba(0, 0, 0, 0.05)" : "rgba(255, 255, 255, 0.05)",
                      },
                {
                    borderRadius: 0,
                    // Reset Chrome style
                }
            ),
            // Remove IE11 arrow
            "&::-ms-expand": {
                display: "none",
            },
            [`&.${nativeSelectClasses$1.disabled}`]: {
                cursor: "default",
            },
            "&[multiple]": {
                height: "auto",
            },
            "&:not([multiple]) option, &:not([multiple]) optgroup": {
                backgroundColor: (theme.vars || theme).palette.background.paper,
            },
            // Bump specificity to allow extending custom inputs
            "&&&": {
                paddingRight: 24,
                minWidth: 16,
                // So it doesn't collapse.
            },
        },
        ownerState.variant === "filled" && {
            "&&&": {
                paddingRight: 32,
            },
        },
        ownerState.variant === "outlined" && {
            borderRadius: (theme.vars || theme).shape.borderRadius,
            "&:focus": {
                borderRadius: (theme.vars || theme).shape.borderRadius,
                // Reset the reset for Chrome style
            },
            "&&&": {
                paddingRight: 32,
            },
        }
    );
const NativeSelectSelect = styled$1("select", {
    name: "MuiNativeSelect",
    slot: "Select",
    shouldForwardProp: rootShouldForwardProp,
    overridesResolver: (props, styles2) => {
        const { ownerState } = props;
        return [
            styles2.select,
            styles2[ownerState.variant],
            ownerState.error && styles2.error,
            {
                [`&.${nativeSelectClasses$1.multiple}`]: styles2.multiple,
            },
        ];
    },
})(nativeSelectSelectStyles);
const nativeSelectIconStyles = ({ ownerState, theme }) =>
    _extends(
        {
            // We use a position absolute over a flexbox in order to forward the pointer events
            // to the input and to support wrapping tags..
            position: "absolute",
            right: 0,
            top: "calc(50% - .5em)",
            // Center vertically, height is 1em
            pointerEvents: "none",
            // Don't block pointer events on the select under the icon.
            color: (theme.vars || theme).palette.action.active,
            [`&.${nativeSelectClasses$1.disabled}`]: {
                color: (theme.vars || theme).palette.action.disabled,
            },
        },
        ownerState.open && {
            transform: "rotate(180deg)",
        },
        ownerState.variant === "filled" && {
            right: 7,
        },
        ownerState.variant === "outlined" && {
            right: 7,
        }
    );
const NativeSelectIcon = styled$1("svg", {
    name: "MuiNativeSelect",
    slot: "Icon",
    overridesResolver: (props, styles2) => {
        const { ownerState } = props;
        return [styles2.icon, ownerState.variant && styles2[`icon${capitalize(ownerState.variant)}`], ownerState.open && styles2.iconOpen];
    },
})(nativeSelectIconStyles);
const NativeSelectInput = /* @__PURE__ */ reactExports.forwardRef(function NativeSelectInput2(props, ref) {
    const { className, disabled, error, IconComponent, inputRef, variant = "standard" } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded$l);
    const ownerState = _extends({}, props, {
        disabled,
        variant,
        error,
    });
    const classes = useUtilityClasses$h(ownerState);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
        children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
                NativeSelectSelect,
                _extends(
                    {
                        ownerState,
                        className: clsx$1(classes.select, className),
                        disabled,
                        ref: inputRef || ref,
                    },
                    other
                )
            ),
            props.multiple
                ? null
                : /* @__PURE__ */ jsxRuntimeExports.jsx(NativeSelectIcon, {
                      as: IconComponent,
                      ownerState,
                      className: classes.icon,
                  }),
        ],
    });
});
const NativeSelectInput$1 = NativeSelectInput;
var _span$1;
const _excluded$k = ["children", "classes", "className", "label", "notched"];
const NotchedOutlineRoot$1 = styled$1("fieldset")({
    textAlign: "left",
    position: "absolute",
    bottom: 0,
    right: 0,
    top: -5,
    left: 0,
    margin: 0,
    padding: "0 8px",
    pointerEvents: "none",
    borderRadius: "inherit",
    borderStyle: "solid",
    borderWidth: 1,
    overflow: "hidden",
    minWidth: "0%",
});
const NotchedOutlineLegend = styled$1("legend")(({ ownerState, theme }) =>
    _extends(
        {
            float: "unset",
            // Fix conflict with bootstrap
            width: "auto",
            // Fix conflict with bootstrap
            overflow: "hidden",
        },
        !ownerState.withLabel && {
            padding: 0,
            lineHeight: "11px",
            // sync with `height` in `legend` styles
            transition: theme.transitions.create("width", {
                duration: 150,
                easing: theme.transitions.easing.easeOut,
            }),
        },
        ownerState.withLabel &&
            _extends(
                {
                    display: "block",
                    // Fix conflict with normalize.css and sanitize.css
                    padding: 0,
                    height: 11,
                    // sync with `lineHeight` in `legend` styles
                    fontSize: "0.75em",
                    visibility: "hidden",
                    maxWidth: 0.01,
                    transition: theme.transitions.create("max-width", {
                        duration: 50,
                        easing: theme.transitions.easing.easeOut,
                    }),
                    whiteSpace: "nowrap",
                    "& > span": {
                        paddingLeft: 5,
                        paddingRight: 5,
                        display: "inline-block",
                        opacity: 0,
                        visibility: "visible",
                    },
                },
                ownerState.notched && {
                    maxWidth: "100%",
                    transition: theme.transitions.create("max-width", {
                        duration: 100,
                        easing: theme.transitions.easing.easeOut,
                        delay: 50,
                    }),
                }
            )
    )
);
function NotchedOutline(props) {
    const { className, label, notched } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded$k);
    const withLabel = label != null && label !== "";
    const ownerState = _extends({}, props, {
        notched,
        withLabel,
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
        NotchedOutlineRoot$1,
        _extends(
            {
                "aria-hidden": true,
                className,
                ownerState,
            },
            other,
            {
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(NotchedOutlineLegend, {
                    ownerState,
                    children: withLabel
                        ? /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
                              children: label,
                          })
                        : // notranslate needed while Google Translate will not fix zero-width space issue
                          _span$1 ||
                          (_span$1 = /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
                              className: "notranslate",
                              children: "",
                          })),
                }),
            }
        )
    );
}
const _excluded$j = ["components", "fullWidth", "inputComponent", "label", "multiline", "notched", "slots", "type"];
const useUtilityClasses$g = (ownerState) => {
    const { classes } = ownerState;
    const slots = {
        root: ["root"],
        notchedOutline: ["notchedOutline"],
        input: ["input"],
    };
    const composedClasses = composeClasses(slots, getOutlinedInputUtilityClass, classes);
    return _extends({}, classes, composedClasses);
};
const OutlinedInputRoot = styled$1(InputBaseRoot, {
    shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
    name: "MuiOutlinedInput",
    slot: "Root",
    overridesResolver: rootOverridesResolver,
})(({ theme, ownerState }) => {
    const borderColor2 = theme.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
    return _extends(
        {
            position: "relative",
            borderRadius: (theme.vars || theme).shape.borderRadius,
            [`&:hover .${outlinedInputClasses$1.notchedOutline}`]: {
                borderColor: (theme.vars || theme).palette.text.primary,
            },
            // Reset on touch devices, it doesn't add specificity
            "@media (hover: none)": {
                [`&:hover .${outlinedInputClasses$1.notchedOutline}`]: {
                    borderColor: theme.vars ? `rgba(${theme.vars.palette.common.onBackgroundChannel} / 0.23)` : borderColor2,
                },
            },
            [`&.${outlinedInputClasses$1.focused} .${outlinedInputClasses$1.notchedOutline}`]: {
                borderColor: (theme.vars || theme).palette[ownerState.color].main,
                borderWidth: 2,
            },
            [`&.${outlinedInputClasses$1.error} .${outlinedInputClasses$1.notchedOutline}`]: {
                borderColor: (theme.vars || theme).palette.error.main,
            },
            [`&.${outlinedInputClasses$1.disabled} .${outlinedInputClasses$1.notchedOutline}`]: {
                borderColor: (theme.vars || theme).palette.action.disabled,
            },
        },
        ownerState.startAdornment && {
            paddingLeft: 14,
        },
        ownerState.endAdornment && {
            paddingRight: 14,
        },
        ownerState.multiline &&
            _extends(
                {
                    padding: "16.5px 14px",
                },
                ownerState.size === "small" && {
                    padding: "8.5px 14px",
                }
            )
    );
});
const NotchedOutlineRoot = styled$1(NotchedOutline, {
    name: "MuiOutlinedInput",
    slot: "NotchedOutline",
    overridesResolver: (props, styles2) => styles2.notchedOutline,
})(({ theme }) => {
    const borderColor2 = theme.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
    return {
        borderColor: theme.vars ? `rgba(${theme.vars.palette.common.onBackgroundChannel} / 0.23)` : borderColor2,
    };
});
const OutlinedInputInput = styled$1(InputBaseComponent, {
    name: "MuiOutlinedInput",
    slot: "Input",
    overridesResolver: inputOverridesResolver,
})(({ theme, ownerState }) =>
    _extends(
        {
            padding: "16.5px 14px",
        },
        !theme.vars && {
            "&:-webkit-autofill": {
                WebkitBoxShadow: theme.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
                WebkitTextFillColor: theme.palette.mode === "light" ? null : "#fff",
                caretColor: theme.palette.mode === "light" ? null : "#fff",
                borderRadius: "inherit",
            },
        },
        theme.vars && {
            "&:-webkit-autofill": {
                borderRadius: "inherit",
            },
            [theme.getColorSchemeSelector("dark")]: {
                "&:-webkit-autofill": {
                    WebkitBoxShadow: "0 0 0 100px #266798 inset",
                    WebkitTextFillColor: "#fff",
                    caretColor: "#fff",
                },
            },
        },
        ownerState.size === "small" && {
            padding: "8.5px 14px",
        },
        ownerState.multiline && {
            padding: 0,
        },
        ownerState.startAdornment && {
            paddingLeft: 0,
        },
        ownerState.endAdornment && {
            paddingRight: 0,
        }
    )
);
const OutlinedInput = /* @__PURE__ */ reactExports.forwardRef(function OutlinedInput2(inProps, ref) {
    var _ref, _slots$root, _ref2, _slots$input, _React$Fragment;
    const props = useThemeProps({
        props: inProps,
        name: "MuiOutlinedInput",
    });
    const { components = {}, fullWidth = false, inputComponent = "input", label, multiline = false, notched, slots = {}, type = "text" } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded$j);
    const classes = useUtilityClasses$g(props);
    const muiFormControl = useFormControl();
    const fcs = formControlState({
        props,
        muiFormControl,
        states: ["required"],
    });
    const ownerState = _extends({}, props, {
        color: fcs.color || "primary",
        disabled: fcs.disabled,
        error: fcs.error,
        focused: fcs.focused,
        formControl: muiFormControl,
        fullWidth,
        hiddenLabel: fcs.hiddenLabel,
        multiline,
        size: fcs.size,
        type,
    });
    const RootSlot = (_ref = (_slots$root = slots.root) != null ? _slots$root : components.Root) != null ? _ref : OutlinedInputRoot;
    const InputSlot = (_ref2 = (_slots$input = slots.input) != null ? _slots$input : components.Input) != null ? _ref2 : OutlinedInputInput;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
        InputBase$1,
        _extends(
            {
                slots: {
                    root: RootSlot,
                    input: InputSlot,
                },
                renderSuffix: (state) =>
                    /* @__PURE__ */ jsxRuntimeExports.jsx(NotchedOutlineRoot, {
                        ownerState,
                        className: classes.notchedOutline,
                        label:
                            label != null && label !== "" && fcs.required
                                ? _React$Fragment ||
                                  (_React$Fragment = /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
                                      children: [label, "", "*"],
                                  }))
                                : label,
                        notched: typeof notched !== "undefined" ? notched : Boolean(state.startAdornment || state.filled || state.focused),
                    }),
                fullWidth,
                inputComponent,
                multiline,
                ref,
                type,
            },
            other,
            {
                classes: _extends({}, classes, {
                    notchedOutline: null,
                }),
            }
        )
    );
});
OutlinedInput.muiName = "Input";
const OutlinedInput$1 = OutlinedInput;
function getSelectUtilityClasses(slot) {
    return generateUtilityClass("MuiSelect", slot);
}
const selectClasses = generateUtilityClasses("MuiSelect", [
    "select",
    "multiple",
    "filled",
    "outlined",
    "standard",
    "disabled",
    "focused",
    "icon",
    "iconOpen",
    "iconFilled",
    "iconOutlined",
    "iconStandard",
    "nativeInput",
    "error",
]);
const selectClasses$1 = selectClasses;
var _span;
const _excluded$i = [
    "aria-describedby",
    "aria-label",
    "autoFocus",
    "autoWidth",
    "children",
    "className",
    "defaultOpen",
    "defaultValue",
    "disabled",
    "displayEmpty",
    "error",
    "IconComponent",
    "inputRef",
    "labelId",
    "MenuProps",
    "multiple",
    "name",
    "onBlur",
    "onChange",
    "onClose",
    "onFocus",
    "onOpen",
    "open",
    "readOnly",
    "renderValue",
    "SelectDisplayProps",
    "tabIndex",
    "type",
    "value",
    "variant",
];
const SelectSelect = styled$1("div", {
    name: "MuiSelect",
    slot: "Select",
    overridesResolver: (props, styles2) => {
        const { ownerState } = props;
        return [
            // Win specificity over the input base
            {
                [`&.${selectClasses$1.select}`]: styles2.select,
            },
            {
                [`&.${selectClasses$1.select}`]: styles2[ownerState.variant],
            },
            {
                [`&.${selectClasses$1.error}`]: styles2.error,
            },
            {
                [`&.${selectClasses$1.multiple}`]: styles2.multiple,
            },
        ];
    },
})(nativeSelectSelectStyles, {
    // Win specificity over the input base
    [`&.${selectClasses$1.select}`]: {
        height: "auto",
        // Resets for multiple select with chips
        minHeight: "1.4375em",
        // Required for select\text-field height consistency
        textOverflow: "ellipsis",
        whiteSpace: "nowrap",
        overflow: "hidden",
    },
});
const SelectIcon = styled$1("svg", {
    name: "MuiSelect",
    slot: "Icon",
    overridesResolver: (props, styles2) => {
        const { ownerState } = props;
        return [styles2.icon, ownerState.variant && styles2[`icon${capitalize(ownerState.variant)}`], ownerState.open && styles2.iconOpen];
    },
})(nativeSelectIconStyles);
const SelectNativeInput = styled$1("input", {
    shouldForwardProp: (prop) => slotShouldForwardProp(prop) && prop !== "classes",
    name: "MuiSelect",
    slot: "NativeInput",
    overridesResolver: (props, styles2) => styles2.nativeInput,
})({
    bottom: 0,
    left: 0,
    position: "absolute",
    opacity: 0,
    pointerEvents: "none",
    width: "100%",
    boxSizing: "border-box",
});
function areEqualValues(a, b2) {
    if (typeof b2 === "object" && b2 !== null) {
        return a === b2;
    }
    return String(a) === String(b2);
}
function isEmpty(display) {
    return display == null || (typeof display === "string" && !display.trim());
}
const useUtilityClasses$f = (ownerState) => {
    const { classes, variant, disabled, multiple, open: open2, error } = ownerState;
    const slots = {
        select: ["select", variant, disabled && "disabled", multiple && "multiple", error && "error"],
        icon: ["icon", `icon${capitalize(variant)}`, open2 && "iconOpen", disabled && "disabled"],
        nativeInput: ["nativeInput"],
    };
    return composeClasses(slots, getSelectUtilityClasses, classes);
};
const SelectInput = /* @__PURE__ */ reactExports.forwardRef(function SelectInput2(props, ref) {
    const {
            "aria-describedby": ariaDescribedby,
            "aria-label": ariaLabel,
            autoFocus,
            autoWidth,
            children,
            className,
            defaultOpen,
            defaultValue,
            disabled,
            displayEmpty,
            error = false,
            IconComponent,
            inputRef: inputRefProp,
            labelId,
            MenuProps = {},
            multiple,
            name,
            onBlur,
            onChange,
            onClose,
            onFocus,
            onOpen,
            open: openProp,
            readOnly,
            renderValue,
            SelectDisplayProps = {},
            tabIndex: tabIndexProp,
            value: valueProp,
            variant = "standard",
        } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded$i);
    const [value, setValueState] = useControlled({
        controlled: valueProp,
        default: defaultValue,
        name: "Select",
    });
    const [openState, setOpenState] = useControlled({
        controlled: openProp,
        default: defaultOpen,
        name: "Select",
    });
    const inputRef = reactExports.useRef(null);
    const displayRef = reactExports.useRef(null);
    const [displayNode, setDisplayNode] = reactExports.useState(null);
    const { current: isOpenControlled } = reactExports.useRef(openProp != null);
    const [menuMinWidthState, setMenuMinWidthState] = reactExports.useState();
    const handleRef = useForkRef(ref, inputRefProp);
    const handleDisplayRef = reactExports.useCallback((node2) => {
        displayRef.current = node2;
        if (node2) {
            setDisplayNode(node2);
        }
    }, []);
    const anchorElement = displayNode == null ? void 0 : displayNode.parentNode;
    reactExports.useImperativeHandle(
        handleRef,
        () => ({
            focus: () => {
                displayRef.current.focus();
            },
            node: inputRef.current,
            value,
        }),
        [value]
    );
    reactExports.useEffect(() => {
        if (defaultOpen && openState && displayNode && !isOpenControlled) {
            setMenuMinWidthState(autoWidth ? null : anchorElement.clientWidth);
            displayRef.current.focus();
        }
    }, [displayNode, autoWidth]);
    reactExports.useEffect(() => {
        if (autoFocus) {
            displayRef.current.focus();
        }
    }, [autoFocus]);
    reactExports.useEffect(() => {
        if (!labelId) {
            return void 0;
        }
        const label = ownerDocument(displayRef.current).getElementById(labelId);
        if (label) {
            const handler = () => {
                if (getSelection().isCollapsed) {
                    displayRef.current.focus();
                }
            };
            label.addEventListener("click", handler);
            return () => {
                label.removeEventListener("click", handler);
            };
        }
        return void 0;
    }, [labelId]);
    const update2 = (open3, event) => {
        if (open3) {
            if (onOpen) {
                onOpen(event);
            }
        } else if (onClose) {
            onClose(event);
        }
        if (!isOpenControlled) {
            setMenuMinWidthState(autoWidth ? null : anchorElement.clientWidth);
            setOpenState(open3);
        }
    };
    const handleMouseDown = (event) => {
        if (event.button !== 0) {
            return;
        }
        event.preventDefault();
        displayRef.current.focus();
        update2(true, event);
    };
    const handleClose = (event) => {
        update2(false, event);
    };
    const childrenArray = reactExports.Children.toArray(children);
    const handleChange = (event) => {
        const index = childrenArray.map((child2) => child2.props.value).indexOf(event.target.value);
        if (index === -1) {
            return;
        }
        const child = childrenArray[index];
        setValueState(child.props.value);
        if (onChange) {
            onChange(event, child);
        }
    };
    const handleItemClick = (child) => (event) => {
        let newValue;
        if (!event.currentTarget.hasAttribute("tabindex")) {
            return;
        }
        if (multiple) {
            newValue = Array.isArray(value) ? value.slice() : [];
            const itemIndex = value.indexOf(child.props.value);
            if (itemIndex === -1) {
                newValue.push(child.props.value);
            } else {
                newValue.splice(itemIndex, 1);
            }
        } else {
            newValue = child.props.value;
        }
        if (child.props.onClick) {
            child.props.onClick(event);
        }
        if (value !== newValue) {
            setValueState(newValue);
            if (onChange) {
                const nativeEvent = event.nativeEvent || event;
                const clonedEvent = new nativeEvent.constructor(nativeEvent.type, nativeEvent);
                Object.defineProperty(clonedEvent, "target", {
                    writable: true,
                    value: {
                        value: newValue,
                        name,
                    },
                });
                onChange(clonedEvent, child);
            }
        }
        if (!multiple) {
            update2(false, event);
        }
    };
    const handleKeyDown2 = (event) => {
        if (!readOnly) {
            const validKeys = [
                " ",
                "ArrowUp",
                "ArrowDown",
                // The native select doesn't respond to enter on macOS, but it's recommended by
                // https://www.w3.org/WAI/ARIA/apg/patterns/combobox/examples/combobox-select-only/
                "Enter",
            ];
            if (validKeys.indexOf(event.key) !== -1) {
                event.preventDefault();
                update2(true, event);
            }
        }
    };
    const open2 = displayNode !== null && openState;
    const handleBlur = (event) => {
        if (!open2 && onBlur) {
            Object.defineProperty(event, "target", {
                writable: true,
                value: {
                    value,
                    name,
                },
            });
            onBlur(event);
        }
    };
    delete other["aria-invalid"];
    let display;
    let displaySingle;
    const displayMultiple = [];
    let computeDisplay = false;
    if (
        isFilled({
            value,
        }) ||
        displayEmpty
    ) {
        if (renderValue) {
            display = renderValue(value);
        } else {
            computeDisplay = true;
        }
    }
    const items = childrenArray.map((child) => {
        if (!(/* @__PURE__ */ reactExports.isValidElement(child))) {
            return null;
        }
        let selected;
        if (multiple) {
            if (!Array.isArray(value)) {
                throw new Error(formatMuiErrorMessage(2));
            }
            selected = value.some((v2) => areEqualValues(v2, child.props.value));
            if (selected && computeDisplay) {
                displayMultiple.push(child.props.children);
            }
        } else {
            selected = areEqualValues(value, child.props.value);
            if (selected && computeDisplay) {
                displaySingle = child.props.children;
            }
        }
        return /* @__PURE__ */ reactExports.cloneElement(child, {
            "aria-selected": selected ? "true" : "false",
            onClick: handleItemClick(child),
            onKeyUp: (event) => {
                if (event.key === " ") {
                    event.preventDefault();
                }
                if (child.props.onKeyUp) {
                    child.props.onKeyUp(event);
                }
            },
            role: "option",
            selected,
            value: void 0,
            // The value is most likely not a valid HTML attribute.
            "data-value": child.props.value,
            // Instead, we provide it as a data attribute.
        });
    });
    if (computeDisplay) {
        if (multiple) {
            if (displayMultiple.length === 0) {
                display = null;
            } else {
                display = displayMultiple.reduce((output, child, index) => {
                    output.push(child);
                    if (index < displayMultiple.length - 1) {
                        output.push(", ");
                    }
                    return output;
                }, []);
            }
        } else {
            display = displaySingle;
        }
    }
    let menuMinWidth = menuMinWidthState;
    if (!autoWidth && isOpenControlled && displayNode) {
        menuMinWidth = anchorElement.clientWidth;
    }
    let tabIndex;
    if (typeof tabIndexProp !== "undefined") {
        tabIndex = tabIndexProp;
    } else {
        tabIndex = disabled ? null : 0;
    }
    const buttonId = SelectDisplayProps.id || (name ? `mui-component-select-${name}` : void 0);
    const ownerState = _extends({}, props, {
        variant,
        value,
        open: open2,
        error,
    });
    const classes = useUtilityClasses$f(ownerState);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
        children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
                SelectSelect,
                _extends(
                    {
                        ref: handleDisplayRef,
                        tabIndex,
                        role: "button",
                        "aria-disabled": disabled ? "true" : void 0,
                        "aria-expanded": open2 ? "true" : "false",
                        "aria-haspopup": "listbox",
                        "aria-label": ariaLabel,
                        "aria-labelledby": [labelId, buttonId].filter(Boolean).join(" ") || void 0,
                        "aria-describedby": ariaDescribedby,
                        onKeyDown: handleKeyDown2,
                        onMouseDown: disabled || readOnly ? null : handleMouseDown,
                        onBlur: handleBlur,
                        onFocus,
                    },
                    SelectDisplayProps,
                    {
                        ownerState,
                        className: clsx$1(SelectDisplayProps.className, classes.select, className),
                        id: buttonId,
                        children: isEmpty(display)
                            ? // notranslate needed while Google Translate will not fix zero-width space issue
                              _span ||
                              (_span = /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
                                  className: "notranslate",
                                  children: "",
                              }))
                            : display,
                    }
                )
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
                SelectNativeInput,
                _extends(
                    {
                        "aria-invalid": error,
                        value: Array.isArray(value) ? value.join(",") : value,
                        name,
                        ref: inputRef,
                        "aria-hidden": true,
                        onChange: handleChange,
                        tabIndex: -1,
                        disabled,
                        className: classes.nativeInput,
                        autoFocus,
                        ownerState,
                    },
                    other
                )
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(SelectIcon, {
                as: IconComponent,
                className: classes.icon,
                ownerState,
            }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
                Menu$1,
                _extends(
                    {
                        id: `menu-${name || ""}`,
                        anchorEl: anchorElement,
                        open: open2,
                        onClose: handleClose,
                        anchorOrigin: {
                            vertical: "bottom",
                            horizontal: "center",
                        },
                        transformOrigin: {
                            vertical: "top",
                            horizontal: "center",
                        },
                    },
                    MenuProps,
                    {
                        MenuListProps: _extends(
                            {
                                "aria-labelledby": labelId,
                                role: "listbox",
                                disableListWrap: true,
                            },
                            MenuProps.MenuListProps
                        ),
                        PaperProps: _extends({}, MenuProps.PaperProps, {
                            style: _extends(
                                {
                                    minWidth: menuMinWidth,
                                },
                                MenuProps.PaperProps != null ? MenuProps.PaperProps.style : null
                            ),
                        }),
                        children: items,
                    }
                )
            ),
        ],
    });
});
const SelectInput$1 = SelectInput;
const _excluded$h = [
    "autoWidth",
    "children",
    "classes",
    "className",
    "defaultOpen",
    "displayEmpty",
    "IconComponent",
    "id",
    "input",
    "inputProps",
    "label",
    "labelId",
    "MenuProps",
    "multiple",
    "native",
    "onClose",
    "onOpen",
    "open",
    "renderValue",
    "SelectDisplayProps",
    "variant",
];
const useUtilityClasses$e = (ownerState) => {
    const { classes } = ownerState;
    return classes;
};
const styledRootConfig = {
    name: "MuiSelect",
    overridesResolver: (props, styles2) => styles2.root,
    shouldForwardProp: (prop) => rootShouldForwardProp(prop) && prop !== "variant",
    slot: "Root",
};
const StyledInput = styled$1(Input$1, styledRootConfig)("");
const StyledOutlinedInput = styled$1(OutlinedInput$1, styledRootConfig)("");
const StyledFilledInput = styled$1(FilledInput$1, styledRootConfig)("");
const Select = /* @__PURE__ */ reactExports.forwardRef(function Select2(inProps, ref) {
    const props = useThemeProps({
        name: "MuiSelect",
        props: inProps,
    });
    const {
            autoWidth = false,
            children,
            classes: classesProp = {},
            className,
            defaultOpen = false,
            displayEmpty = false,
            IconComponent = ArrowDropDownIcon,
            id,
            input,
            inputProps,
            label,
            labelId,
            MenuProps,
            multiple = false,
            native = false,
            onClose,
            onOpen,
            open: open2,
            renderValue,
            SelectDisplayProps,
            variant: variantProp = "outlined",
        } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded$h);
    const inputComponent = native ? NativeSelectInput$1 : SelectInput$1;
    const muiFormControl = useFormControl();
    const fcs = formControlState({
        props,
        muiFormControl,
        states: ["variant", "error"],
    });
    const variant = fcs.variant || variantProp;
    const ownerState = _extends({}, props, {
        variant,
        classes: classesProp,
    });
    const classes = useUtilityClasses$e(ownerState);
    const InputComponent =
        input ||
        {
            standard: /* @__PURE__ */ jsxRuntimeExports.jsx(StyledInput, {
                ownerState,
            }),
            outlined: /* @__PURE__ */ jsxRuntimeExports.jsx(StyledOutlinedInput, {
                label,
                ownerState,
            }),
            filled: /* @__PURE__ */ jsxRuntimeExports.jsx(StyledFilledInput, {
                ownerState,
            }),
        }[variant];
    const inputComponentRef = useForkRef(ref, InputComponent.ref);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Fragment, {
        children: /* @__PURE__ */ reactExports.cloneElement(
            InputComponent,
            _extends(
                {
                    // Most of the logic is implemented in `SelectInput`.
                    // The `Select` component is a simple API wrapper to expose something better to play with.
                    inputComponent,
                    inputProps: _extends(
                        {
                            children,
                            error: fcs.error,
                            IconComponent,
                            variant,
                            type: void 0,
                            // We render a select. We can ignore the type provided by the `Input`.
                            multiple,
                        },
                        native
                            ? {
                                  id,
                              }
                            : {
                                  autoWidth,
                                  defaultOpen,
                                  displayEmpty,
                                  labelId,
                                  MenuProps,
                                  onClose,
                                  onOpen,
                                  open: open2,
                                  renderValue,
                                  SelectDisplayProps: _extends(
                                      {
                                          id,
                                      },
                                      SelectDisplayProps
                                  ),
                              },
                        inputProps,
                        {
                            classes: inputProps ? deepmerge(classes, inputProps.classes) : classes,
                        },
                        input ? input.props.inputProps : {}
                    ),
                },
                multiple && native && variant === "outlined"
                    ? {
                          notched: true,
                      }
                    : {},
                {
                    ref: inputComponentRef,
                    className: clsx$1(InputComponent.props.className, className),
                },
                !input && {
                    variant,
                },
                other
            )
        ),
    });
});
Select.muiName = "Select";
const Select$1 = Select;
function getTooltipUtilityClass(slot) {
    return generateUtilityClass("MuiTooltip", slot);
}
const tooltipClasses = generateUtilityClasses("MuiTooltip", [
    "popper",
    "popperInteractive",
    "popperArrow",
    "popperClose",
    "tooltip",
    "tooltipArrow",
    "touch",
    "tooltipPlacementLeft",
    "tooltipPlacementRight",
    "tooltipPlacementTop",
    "tooltipPlacementBottom",
    "arrow",
]);
const tooltipClasses$1 = tooltipClasses;
const _excluded$g = [
    "arrow",
    "children",
    "classes",
    "components",
    "componentsProps",
    "describeChild",
    "disableFocusListener",
    "disableHoverListener",
    "disableInteractive",
    "disableTouchListener",
    "enterDelay",
    "enterNextDelay",
    "enterTouchDelay",
    "followCursor",
    "id",
    "leaveDelay",
    "leaveTouchDelay",
    "onClose",
    "onOpen",
    "open",
    "placement",
    "PopperComponent",
    "PopperProps",
    "slotProps",
    "slots",
    "title",
    "TransitionComponent",
    "TransitionProps",
];
function round(value) {
    return Math.round(value * 1e5) / 1e5;
}
const useUtilityClasses$d = (ownerState) => {
    const { classes, disableInteractive, arrow: arrow2, touch, placement } = ownerState;
    const slots = {
        popper: ["popper", !disableInteractive && "popperInteractive", arrow2 && "popperArrow"],
        tooltip: ["tooltip", arrow2 && "tooltipArrow", touch && "touch", `tooltipPlacement${capitalize(placement.split("-")[0])}`],
        arrow: ["arrow"],
    };
    return composeClasses(slots, getTooltipUtilityClass, classes);
};
const TooltipPopper = styled$1(Popper$1, {
    name: "MuiTooltip",
    slot: "Popper",
    overridesResolver: (props, styles2) => {
        const { ownerState } = props;
        return [styles2.popper, !ownerState.disableInteractive && styles2.popperInteractive, ownerState.arrow && styles2.popperArrow, !ownerState.open && styles2.popperClose];
    },
})(({ theme, ownerState, open: open2 }) =>
    _extends(
        {
            zIndex: (theme.vars || theme).zIndex.tooltip,
            pointerEvents: "none",
        },
        !ownerState.disableInteractive && {
            pointerEvents: "auto",
        },
        !open2 && {
            pointerEvents: "none",
        },
        ownerState.arrow && {
            [`&[data-popper-placement*="bottom"] .${tooltipClasses$1.arrow}`]: {
                top: 0,
                marginTop: "-0.71em",
                "&::before": {
                    transformOrigin: "0 100%",
                },
            },
            [`&[data-popper-placement*="top"] .${tooltipClasses$1.arrow}`]: {
                bottom: 0,
                marginBottom: "-0.71em",
                "&::before": {
                    transformOrigin: "100% 0",
                },
            },
            [`&[data-popper-placement*="right"] .${tooltipClasses$1.arrow}`]: _extends(
                {},
                !ownerState.isRtl
                    ? {
                          left: 0,
                          marginLeft: "-0.71em",
                      }
                    : {
                          right: 0,
                          marginRight: "-0.71em",
                      },
                {
                    height: "1em",
                    width: "0.71em",
                    "&::before": {
                        transformOrigin: "100% 100%",
                    },
                }
            ),
            [`&[data-popper-placement*="left"] .${tooltipClasses$1.arrow}`]: _extends(
                {},
                !ownerState.isRtl
                    ? {
                          right: 0,
                          marginRight: "-0.71em",
                      }
                    : {
                          left: 0,
                          marginLeft: "-0.71em",
                      },
                {
                    height: "1em",
                    width: "0.71em",
                    "&::before": {
                        transformOrigin: "0 0",
                    },
                }
            ),
        }
    )
);
const TooltipTooltip = styled$1("div", {
    name: "MuiTooltip",
    slot: "Tooltip",
    overridesResolver: (props, styles2) => {
        const { ownerState } = props;
        return [styles2.tooltip, ownerState.touch && styles2.touch, ownerState.arrow && styles2.tooltipArrow, styles2[`tooltipPlacement${capitalize(ownerState.placement.split("-")[0])}`]];
    },
})(({ theme, ownerState }) =>
    _extends(
        {
            backgroundColor: theme.vars ? theme.vars.palette.Tooltip.bg : alpha(theme.palette.grey[700], 0.92),
            borderRadius: (theme.vars || theme).shape.borderRadius,
            color: (theme.vars || theme).palette.common.white,
            fontFamily: theme.typography.fontFamily,
            padding: "4px 8px",
            fontSize: theme.typography.pxToRem(11),
            maxWidth: 300,
            margin: 2,
            wordWrap: "break-word",
            fontWeight: theme.typography.fontWeightMedium,
        },
        ownerState.arrow && {
            position: "relative",
            margin: 0,
        },
        ownerState.touch && {
            padding: "8px 16px",
            fontSize: theme.typography.pxToRem(14),
            lineHeight: `${round(16 / 14)}em`,
            fontWeight: theme.typography.fontWeightRegular,
        },
        {
            [`.${tooltipClasses$1.popper}[data-popper-placement*="left"] &`]: _extends(
                {
                    transformOrigin: "right center",
                },
                !ownerState.isRtl
                    ? _extends(
                          {
                              marginRight: "14px",
                          },
                          ownerState.touch && {
                              marginRight: "24px",
                          }
                      )
                    : _extends(
                          {
                              marginLeft: "14px",
                          },
                          ownerState.touch && {
                              marginLeft: "24px",
                          }
                      )
            ),
            [`.${tooltipClasses$1.popper}[data-popper-placement*="right"] &`]: _extends(
                {
                    transformOrigin: "left center",
                },
                !ownerState.isRtl
                    ? _extends(
                          {
                              marginLeft: "14px",
                          },
                          ownerState.touch && {
                              marginLeft: "24px",
                          }
                      )
                    : _extends(
                          {
                              marginRight: "14px",
                          },
                          ownerState.touch && {
                              marginRight: "24px",
                          }
                      )
            ),
            [`.${tooltipClasses$1.popper}[data-popper-placement*="top"] &`]: _extends(
                {
                    transformOrigin: "center bottom",
                    marginBottom: "14px",
                },
                ownerState.touch && {
                    marginBottom: "24px",
                }
            ),
            [`.${tooltipClasses$1.popper}[data-popper-placement*="bottom"] &`]: _extends(
                {
                    transformOrigin: "center top",
                    marginTop: "14px",
                },
                ownerState.touch && {
                    marginTop: "24px",
                }
            ),
        }
    )
);
const TooltipArrow = styled$1("span", {
    name: "MuiTooltip",
    slot: "Arrow",
    overridesResolver: (props, styles2) => styles2.arrow,
})(({ theme }) => ({
    overflow: "hidden",
    position: "absolute",
    width: "1em",
    height: "0.71em",
    boxSizing: "border-box",
    color: theme.vars ? theme.vars.palette.Tooltip.bg : alpha(theme.palette.grey[700], 0.9),
    "&::before": {
        content: '""',
        margin: "auto",
        display: "block",
        width: "100%",
        height: "100%",
        backgroundColor: "currentColor",
        transform: "rotate(45deg)",
    },
}));
let hystersisOpen = false;
let hystersisTimer = null;
let cursorPosition = {
    x: 0,
    y: 0,
};
function composeEventHandler(handler, eventHandler) {
    return (event) => {
        if (eventHandler) {
            eventHandler(event);
        }
        handler(event);
    };
}
const Tooltip = /* @__PURE__ */ reactExports.forwardRef(function Tooltip2(inProps, ref) {
    var _ref,
        _slots$popper,
        _ref2,
        _ref3,
        _slots$transition,
        _ref4,
        _slots$tooltip,
        _ref5,
        _slots$arrow,
        _slotProps$popper,
        _ref6,
        _slotProps$popper2,
        _slotProps$transition,
        _slotProps$tooltip,
        _ref7,
        _slotProps$tooltip2,
        _slotProps$arrow,
        _ref8,
        _slotProps$arrow2;
    const props = useThemeProps({
        props: inProps,
        name: "MuiTooltip",
    });
    const {
            arrow: arrow2 = false,
            children,
            components = {},
            componentsProps = {},
            describeChild = false,
            disableFocusListener = false,
            disableHoverListener = false,
            disableInteractive: disableInteractiveProp = false,
            disableTouchListener = false,
            enterDelay = 100,
            enterNextDelay = 0,
            enterTouchDelay = 700,
            followCursor = false,
            id: idProp,
            leaveDelay = 0,
            leaveTouchDelay = 1500,
            onClose,
            onOpen,
            open: openProp,
            placement = "bottom",
            PopperComponent: PopperComponentProp,
            PopperProps = {},
            slotProps = {},
            slots = {},
            title,
            TransitionComponent: TransitionComponentProp = Grow$1,
            TransitionProps,
        } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded$g);
    const theme = useTheme();
    const isRtl = theme.direction === "rtl";
    const [childNode, setChildNode] = reactExports.useState();
    const [arrowRef, setArrowRef] = reactExports.useState(null);
    const ignoreNonTouchEvents = reactExports.useRef(false);
    const disableInteractive = disableInteractiveProp || followCursor;
    const closeTimer = reactExports.useRef();
    const enterTimer = reactExports.useRef();
    const leaveTimer = reactExports.useRef();
    const touchTimer = reactExports.useRef();
    const [openState, setOpenState] = useControlled({
        controlled: openProp,
        default: false,
        name: "Tooltip",
        state: "open",
    });
    let open2 = openState;
    const id = useId(idProp);
    const prevUserSelect = reactExports.useRef();
    const stopTouchInteraction = reactExports.useCallback(() => {
        if (prevUserSelect.current !== void 0) {
            document.body.style.WebkitUserSelect = prevUserSelect.current;
            prevUserSelect.current = void 0;
        }
        clearTimeout(touchTimer.current);
    }, []);
    reactExports.useEffect(() => {
        return () => {
            clearTimeout(closeTimer.current);
            clearTimeout(enterTimer.current);
            clearTimeout(leaveTimer.current);
            stopTouchInteraction();
        };
    }, [stopTouchInteraction]);
    const handleOpen = (event) => {
        clearTimeout(hystersisTimer);
        hystersisOpen = true;
        setOpenState(true);
        if (onOpen && !open2) {
            onOpen(event);
        }
    };
    const handleClose = useEventCallback(
        /**
         * @param {React.SyntheticEvent | Event} event
         */
        (event) => {
            clearTimeout(hystersisTimer);
            hystersisTimer = setTimeout(() => {
                hystersisOpen = false;
            }, 800 + leaveDelay);
            setOpenState(false);
            if (onClose && open2) {
                onClose(event);
            }
            clearTimeout(closeTimer.current);
            closeTimer.current = setTimeout(() => {
                ignoreNonTouchEvents.current = false;
            }, theme.transitions.duration.shortest);
        }
    );
    const handleEnter = (event) => {
        if (ignoreNonTouchEvents.current && event.type !== "touchstart") {
            return;
        }
        if (childNode) {
            childNode.removeAttribute("title");
        }
        clearTimeout(enterTimer.current);
        clearTimeout(leaveTimer.current);
        if (enterDelay || (hystersisOpen && enterNextDelay)) {
            enterTimer.current = setTimeout(
                () => {
                    handleOpen(event);
                },
                hystersisOpen ? enterNextDelay : enterDelay
            );
        } else {
            handleOpen(event);
        }
    };
    const handleLeave = (event) => {
        clearTimeout(enterTimer.current);
        clearTimeout(leaveTimer.current);
        leaveTimer.current = setTimeout(() => {
            handleClose(event);
        }, leaveDelay);
    };
    const { isFocusVisibleRef, onBlur: handleBlurVisible, onFocus: handleFocusVisible, ref: focusVisibleRef } = useIsFocusVisible();
    const [, setChildIsFocusVisible] = reactExports.useState(false);
    const handleBlur = (event) => {
        handleBlurVisible(event);
        if (isFocusVisibleRef.current === false) {
            setChildIsFocusVisible(false);
            handleLeave(event);
        }
    };
    const handleFocus = (event) => {
        if (!childNode) {
            setChildNode(event.currentTarget);
        }
        handleFocusVisible(event);
        if (isFocusVisibleRef.current === true) {
            setChildIsFocusVisible(true);
            handleEnter(event);
        }
    };
    const detectTouchStart = (event) => {
        ignoreNonTouchEvents.current = true;
        const childrenProps2 = children.props;
        if (childrenProps2.onTouchStart) {
            childrenProps2.onTouchStart(event);
        }
    };
    const handleMouseOver = handleEnter;
    const handleMouseLeave = handleLeave;
    const handleTouchStart = (event) => {
        detectTouchStart(event);
        clearTimeout(leaveTimer.current);
        clearTimeout(closeTimer.current);
        stopTouchInteraction();
        prevUserSelect.current = document.body.style.WebkitUserSelect;
        document.body.style.WebkitUserSelect = "none";
        touchTimer.current = setTimeout(() => {
            document.body.style.WebkitUserSelect = prevUserSelect.current;
            handleEnter(event);
        }, enterTouchDelay);
    };
    const handleTouchEnd = (event) => {
        if (children.props.onTouchEnd) {
            children.props.onTouchEnd(event);
        }
        stopTouchInteraction();
        clearTimeout(leaveTimer.current);
        leaveTimer.current = setTimeout(() => {
            handleClose(event);
        }, leaveTouchDelay);
    };
    reactExports.useEffect(() => {
        if (!open2) {
            return void 0;
        }
        function handleKeyDown2(nativeEvent) {
            if (nativeEvent.key === "Escape" || nativeEvent.key === "Esc") {
                handleClose(nativeEvent);
            }
        }
        document.addEventListener("keydown", handleKeyDown2);
        return () => {
            document.removeEventListener("keydown", handleKeyDown2);
        };
    }, [handleClose, open2]);
    const handleRef = useForkRef(children.ref, focusVisibleRef, setChildNode, ref);
    if (!title && title !== 0) {
        open2 = false;
    }
    const popperRef = reactExports.useRef();
    const handleMouseMove = (event) => {
        const childrenProps2 = children.props;
        if (childrenProps2.onMouseMove) {
            childrenProps2.onMouseMove(event);
        }
        cursorPosition = {
            x: event.clientX,
            y: event.clientY,
        };
        if (popperRef.current) {
            popperRef.current.update();
        }
    };
    const nameOrDescProps = {};
    const titleIsString = typeof title === "string";
    if (describeChild) {
        nameOrDescProps.title = !open2 && titleIsString && !disableHoverListener ? title : null;
        nameOrDescProps["aria-describedby"] = open2 ? id : null;
    } else {
        nameOrDescProps["aria-label"] = titleIsString ? title : null;
        nameOrDescProps["aria-labelledby"] = open2 && !titleIsString ? id : null;
    }
    const childrenProps = _extends(
        {},
        nameOrDescProps,
        other,
        children.props,
        {
            className: clsx$1(other.className, children.props.className),
            onTouchStart: detectTouchStart,
            ref: handleRef,
        },
        followCursor
            ? {
                  onMouseMove: handleMouseMove,
              }
            : {}
    );
    const interactiveWrapperListeners = {};
    if (!disableTouchListener) {
        childrenProps.onTouchStart = handleTouchStart;
        childrenProps.onTouchEnd = handleTouchEnd;
    }
    if (!disableHoverListener) {
        childrenProps.onMouseOver = composeEventHandler(handleMouseOver, childrenProps.onMouseOver);
        childrenProps.onMouseLeave = composeEventHandler(handleMouseLeave, childrenProps.onMouseLeave);
        if (!disableInteractive) {
            interactiveWrapperListeners.onMouseOver = handleMouseOver;
            interactiveWrapperListeners.onMouseLeave = handleMouseLeave;
        }
    }
    if (!disableFocusListener) {
        childrenProps.onFocus = composeEventHandler(handleFocus, childrenProps.onFocus);
        childrenProps.onBlur = composeEventHandler(handleBlur, childrenProps.onBlur);
        if (!disableInteractive) {
            interactiveWrapperListeners.onFocus = handleFocus;
            interactiveWrapperListeners.onBlur = handleBlur;
        }
    }
    const popperOptions = reactExports.useMemo(() => {
        var _PopperProps$popperOp;
        let tooltipModifiers = [
            {
                name: "arrow",
                enabled: Boolean(arrowRef),
                options: {
                    element: arrowRef,
                    padding: 4,
                },
            },
        ];
        if ((_PopperProps$popperOp = PopperProps.popperOptions) != null && _PopperProps$popperOp.modifiers) {
            tooltipModifiers = tooltipModifiers.concat(PopperProps.popperOptions.modifiers);
        }
        return _extends({}, PopperProps.popperOptions, {
            modifiers: tooltipModifiers,
        });
    }, [arrowRef, PopperProps]);
    const ownerState = _extends({}, props, {
        isRtl,
        arrow: arrow2,
        disableInteractive,
        placement,
        PopperComponentProp,
        touch: ignoreNonTouchEvents.current,
    });
    const classes = useUtilityClasses$d(ownerState);
    const PopperComponent = (_ref = (_slots$popper = slots.popper) != null ? _slots$popper : components.Popper) != null ? _ref : TooltipPopper;
    const TransitionComponent =
        (_ref2 = (_ref3 = (_slots$transition = slots.transition) != null ? _slots$transition : components.Transition) != null ? _ref3 : TransitionComponentProp) != null ? _ref2 : Grow$1;
    const TooltipComponent = (_ref4 = (_slots$tooltip = slots.tooltip) != null ? _slots$tooltip : components.Tooltip) != null ? _ref4 : TooltipTooltip;
    const ArrowComponent = (_ref5 = (_slots$arrow = slots.arrow) != null ? _slots$arrow : components.Arrow) != null ? _ref5 : TooltipArrow;
    const popperProps = appendOwnerState(
        PopperComponent,
        _extends({}, PopperProps, (_slotProps$popper = slotProps.popper) != null ? _slotProps$popper : componentsProps.popper, {
            className: clsx$1(
                classes.popper,
                PopperProps == null ? void 0 : PopperProps.className,
                (_ref6 = (_slotProps$popper2 = slotProps.popper) != null ? _slotProps$popper2 : componentsProps.popper) == null ? void 0 : _ref6.className
            ),
        }),
        ownerState
    );
    const transitionProps = appendOwnerState(
        TransitionComponent,
        _extends({}, TransitionProps, (_slotProps$transition = slotProps.transition) != null ? _slotProps$transition : componentsProps.transition),
        ownerState
    );
    const tooltipProps = appendOwnerState(
        TooltipComponent,
        _extends({}, (_slotProps$tooltip = slotProps.tooltip) != null ? _slotProps$tooltip : componentsProps.tooltip, {
            className: clsx$1(classes.tooltip, (_ref7 = (_slotProps$tooltip2 = slotProps.tooltip) != null ? _slotProps$tooltip2 : componentsProps.tooltip) == null ? void 0 : _ref7.className),
        }),
        ownerState
    );
    const tooltipArrowProps = appendOwnerState(
        ArrowComponent,
        _extends({}, (_slotProps$arrow = slotProps.arrow) != null ? _slotProps$arrow : componentsProps.arrow, {
            className: clsx$1(classes.arrow, (_ref8 = (_slotProps$arrow2 = slotProps.arrow) != null ? _slotProps$arrow2 : componentsProps.arrow) == null ? void 0 : _ref8.className),
        }),
        ownerState
    );
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
        children: [
            /* @__PURE__ */ reactExports.cloneElement(children, childrenProps),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
                PopperComponent,
                _extends(
                    {
                        as: PopperComponentProp != null ? PopperComponentProp : Popper$1,
                        placement,
                        anchorEl: followCursor
                            ? {
                                  getBoundingClientRect: () => ({
                                      top: cursorPosition.y,
                                      left: cursorPosition.x,
                                      right: cursorPosition.x,
                                      bottom: cursorPosition.y,
                                      width: 0,
                                      height: 0,
                                  }),
                              }
                            : childNode,
                        popperRef,
                        open: childNode ? open2 : false,
                        id,
                        transition: true,
                    },
                    interactiveWrapperListeners,
                    popperProps,
                    {
                        popperOptions,
                        children: ({ TransitionProps: TransitionPropsInner }) =>
                            /* @__PURE__ */ jsxRuntimeExports.jsx(
                                TransitionComponent,
                                _extends(
                                    {
                                        timeout: theme.transitions.duration.shorter,
                                    },
                                    TransitionPropsInner,
                                    transitionProps,
                                    {
                                        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
                                            TooltipComponent,
                                            _extends({}, tooltipProps, {
                                                children: [
                                                    title,
                                                    arrow2
                                                        ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                                                              ArrowComponent,
                                                              _extends({}, tooltipArrowProps, {
                                                                  ref: setArrowRef,
                                                              })
                                                          )
                                                        : null,
                                                ],
                                            })
                                        ),
                                    }
                                )
                            ),
                    }
                )
            ),
        ],
    });
});
const Tooltip$1 = Tooltip;
const Stack = createStack({
    createStyledComponent: styled$1("div", {
        name: "MuiStack",
        slot: "Root",
        overridesResolver: (props, styles2) => styles2.root,
    }),
    useThemeProps: (inProps) =>
        useThemeProps({
            props: inProps,
            name: "MuiStack",
        }),
});
const Stack$1 = Stack;
function getTabUtilityClass(slot) {
    return generateUtilityClass("MuiTab", slot);
}
const tabClasses = generateUtilityClasses("MuiTab", ["root", "labelIcon", "textColorInherit", "textColorPrimary", "textColorSecondary", "selected", "disabled", "fullWidth", "wrapped", "iconWrapper"]);
const tabClasses$1 = tabClasses;
const _excluded$f = [
    "className",
    "disabled",
    "disableFocusRipple",
    "fullWidth",
    "icon",
    "iconPosition",
    "indicator",
    "label",
    "onChange",
    "onClick",
    "onFocus",
    "selected",
    "selectionFollowsFocus",
    "textColor",
    "value",
    "wrapped",
];
const useUtilityClasses$c = (ownerState) => {
    const { classes, textColor, fullWidth, wrapped, icon, label, selected, disabled } = ownerState;
    const slots = {
        root: ["root", icon && label && "labelIcon", `textColor${capitalize(textColor)}`, fullWidth && "fullWidth", wrapped && "wrapped", selected && "selected", disabled && "disabled"],
        iconWrapper: ["iconWrapper"],
    };
    return composeClasses(slots, getTabUtilityClass, classes);
};
const TabRoot = styled$1(ButtonBase$1, {
    name: "MuiTab",
    slot: "Root",
    overridesResolver: (props, styles2) => {
        const { ownerState } = props;
        return [
            styles2.root,
            ownerState.label && ownerState.icon && styles2.labelIcon,
            styles2[`textColor${capitalize(ownerState.textColor)}`],
            ownerState.fullWidth && styles2.fullWidth,
            ownerState.wrapped && styles2.wrapped,
        ];
    },
})(({ theme, ownerState }) =>
    _extends(
        {},
        theme.typography.button,
        {
            maxWidth: 360,
            minWidth: 90,
            position: "relative",
            minHeight: 48,
            flexShrink: 0,
            padding: "12px 16px",
            overflow: "hidden",
            whiteSpace: "normal",
            textAlign: "center",
        },
        ownerState.label && {
            flexDirection: ownerState.iconPosition === "top" || ownerState.iconPosition === "bottom" ? "column" : "row",
        },
        {
            lineHeight: 1.25,
        },
        ownerState.icon &&
            ownerState.label && {
                minHeight: 72,
                paddingTop: 9,
                paddingBottom: 9,
                [`& > .${tabClasses$1.iconWrapper}`]: _extends(
                    {},
                    ownerState.iconPosition === "top" && {
                        marginBottom: 6,
                    },
                    ownerState.iconPosition === "bottom" && {
                        marginTop: 6,
                    },
                    ownerState.iconPosition === "start" && {
                        marginRight: theme.spacing(1),
                    },
                    ownerState.iconPosition === "end" && {
                        marginLeft: theme.spacing(1),
                    }
                ),
            },
        ownerState.textColor === "inherit" && {
            color: "inherit",
            opacity: 0.6,
            // same opacity as theme.palette.text.secondary
            [`&.${tabClasses$1.selected}`]: {
                opacity: 1,
            },
            [`&.${tabClasses$1.disabled}`]: {
                opacity: (theme.vars || theme).palette.action.disabledOpacity,
            },
        },
        ownerState.textColor === "primary" && {
            color: (theme.vars || theme).palette.text.secondary,
            [`&.${tabClasses$1.selected}`]: {
                color: (theme.vars || theme).palette.primary.main,
            },
            [`&.${tabClasses$1.disabled}`]: {
                color: (theme.vars || theme).palette.text.disabled,
            },
        },
        ownerState.textColor === "secondary" && {
            color: (theme.vars || theme).palette.text.secondary,
            [`&.${tabClasses$1.selected}`]: {
                color: (theme.vars || theme).palette.secondary.main,
            },
            [`&.${tabClasses$1.disabled}`]: {
                color: (theme.vars || theme).palette.text.disabled,
            },
        },
        ownerState.fullWidth && {
            flexShrink: 1,
            flexGrow: 1,
            flexBasis: 0,
            maxWidth: "none",
        },
        ownerState.wrapped && {
            fontSize: theme.typography.pxToRem(12),
        }
    )
);
const Tab = /* @__PURE__ */ reactExports.forwardRef(function Tab2(inProps, ref) {
    const props = useThemeProps({
        props: inProps,
        name: "MuiTab",
    });
    const {
            className,
            disabled = false,
            disableFocusRipple = false,
            // eslint-disable-next-line react/prop-types
            fullWidth,
            icon: iconProp,
            iconPosition = "top",
            // eslint-disable-next-line react/prop-types
            indicator,
            label,
            onChange,
            onClick,
            onFocus,
            // eslint-disable-next-line react/prop-types
            selected,
            // eslint-disable-next-line react/prop-types
            selectionFollowsFocus,
            // eslint-disable-next-line react/prop-types
            textColor = "inherit",
            value,
            wrapped = false,
        } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded$f);
    const ownerState = _extends({}, props, {
        disabled,
        disableFocusRipple,
        selected,
        icon: !!iconProp,
        iconPosition,
        label: !!label,
        fullWidth,
        textColor,
        wrapped,
    });
    const classes = useUtilityClasses$c(ownerState);
    const icon =
        iconProp && label && /* @__PURE__ */ reactExports.isValidElement(iconProp)
            ? /* @__PURE__ */ reactExports.cloneElement(iconProp, {
                  className: clsx$1(classes.iconWrapper, iconProp.props.className),
              })
            : iconProp;
    const handleClick = (event) => {
        if (!selected && onChange) {
            onChange(event, value);
        }
        if (onClick) {
            onClick(event);
        }
    };
    const handleFocus = (event) => {
        if (selectionFollowsFocus && !selected && onChange) {
            onChange(event, value);
        }
        if (onFocus) {
            onFocus(event);
        }
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        TabRoot,
        _extends(
            {
                focusRipple: !disableFocusRipple,
                className: clsx$1(classes.root, className),
                ref,
                role: "tab",
                "aria-selected": selected,
                disabled,
                onClick: handleClick,
                onFocus: handleFocus,
                ownerState,
                tabIndex: selected ? 0 : -1,
            },
            other,
            {
                children: [
                    iconPosition === "top" || iconPosition === "start"
                        ? /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
                              children: [icon, label],
                          })
                        : /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
                              children: [label, icon],
                          }),
                    indicator,
                ],
            }
        )
    );
});
const Tab$1 = Tab;
const TableContext = /* @__PURE__ */ reactExports.createContext();
const TableContext$1 = TableContext;
function getTableUtilityClass(slot) {
    return generateUtilityClass("MuiTable", slot);
}
generateUtilityClasses("MuiTable", ["root", "stickyHeader"]);
const _excluded$e = ["className", "component", "padding", "size", "stickyHeader"];
const useUtilityClasses$b = (ownerState) => {
    const { classes, stickyHeader } = ownerState;
    const slots = {
        root: ["root", stickyHeader && "stickyHeader"],
    };
    return composeClasses(slots, getTableUtilityClass, classes);
};
const TableRoot = styled$1("table", {
    name: "MuiTable",
    slot: "Root",
    overridesResolver: (props, styles2) => {
        const { ownerState } = props;
        return [styles2.root, ownerState.stickyHeader && styles2.stickyHeader];
    },
})(({ theme, ownerState }) =>
    _extends(
        {
            display: "table",
            width: "100%",
            borderCollapse: "collapse",
            borderSpacing: 0,
            "& caption": _extends({}, theme.typography.body2, {
                padding: theme.spacing(2),
                color: (theme.vars || theme).palette.text.secondary,
                textAlign: "left",
                captionSide: "bottom",
            }),
        },
        ownerState.stickyHeader && {
            borderCollapse: "separate",
        }
    )
);
const defaultComponent$3 = "table";
const Table = /* @__PURE__ */ reactExports.forwardRef(function Table2(inProps, ref) {
    const props = useThemeProps({
        props: inProps,
        name: "MuiTable",
    });
    const { className, component = defaultComponent$3, padding: padding2 = "normal", size = "medium", stickyHeader = false } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded$e);
    const ownerState = _extends({}, props, {
        component,
        padding: padding2,
        size,
        stickyHeader,
    });
    const classes = useUtilityClasses$b(ownerState);
    const table = reactExports.useMemo(
        () => ({
            padding: padding2,
            size,
            stickyHeader,
        }),
        [padding2, size, stickyHeader]
    );
    return /* @__PURE__ */ jsxRuntimeExports.jsx(TableContext$1.Provider, {
        value: table,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            TableRoot,
            _extends(
                {
                    as: component,
                    role: component === defaultComponent$3 ? null : "table",
                    ref,
                    className: clsx$1(classes.root, className),
                    ownerState,
                },
                other
            )
        ),
    });
});
const Table$1 = Table;
const Tablelvl2Context = /* @__PURE__ */ reactExports.createContext();
const Tablelvl2Context$1 = Tablelvl2Context;
function getTableBodyUtilityClass(slot) {
    return generateUtilityClass("MuiTableBody", slot);
}
generateUtilityClasses("MuiTableBody", ["root"]);
const _excluded$d = ["className", "component"];
const useUtilityClasses$a = (ownerState) => {
    const { classes } = ownerState;
    const slots = {
        root: ["root"],
    };
    return composeClasses(slots, getTableBodyUtilityClass, classes);
};
const TableBodyRoot = styled$1("tbody", {
    name: "MuiTableBody",
    slot: "Root",
    overridesResolver: (props, styles2) => styles2.root,
})({
    display: "table-row-group",
});
const tablelvl2$1 = {
    variant: "body",
};
const defaultComponent$2 = "tbody";
const TableBody = /* @__PURE__ */ reactExports.forwardRef(function TableBody2(inProps, ref) {
    const props = useThemeProps({
        props: inProps,
        name: "MuiTableBody",
    });
    const { className, component = defaultComponent$2 } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded$d);
    const ownerState = _extends({}, props, {
        component,
    });
    const classes = useUtilityClasses$a(ownerState);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Tablelvl2Context$1.Provider, {
        value: tablelvl2$1,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            TableBodyRoot,
            _extends(
                {
                    className: clsx$1(classes.root, className),
                    as: component,
                    ref,
                    role: component === defaultComponent$2 ? null : "rowgroup",
                    ownerState,
                },
                other
            )
        ),
    });
});
const TableBody$1 = TableBody;
function getTableCellUtilityClass(slot) {
    return generateUtilityClass("MuiTableCell", slot);
}
const tableCellClasses = generateUtilityClasses("MuiTableCell", [
    "root",
    "head",
    "body",
    "footer",
    "sizeSmall",
    "sizeMedium",
    "paddingCheckbox",
    "paddingNone",
    "alignLeft",
    "alignCenter",
    "alignRight",
    "alignJustify",
    "stickyHeader",
]);
const tableCellClasses$1 = tableCellClasses;
const _excluded$c = ["align", "className", "component", "padding", "scope", "size", "sortDirection", "variant"];
const useUtilityClasses$9 = (ownerState) => {
    const { classes, variant, align, padding: padding2, size, stickyHeader } = ownerState;
    const slots = {
        root: [
            "root",
            variant,
            stickyHeader && "stickyHeader",
            align !== "inherit" && `align${capitalize(align)}`,
            padding2 !== "normal" && `padding${capitalize(padding2)}`,
            `size${capitalize(size)}`,
        ],
    };
    return composeClasses(slots, getTableCellUtilityClass, classes);
};
const TableCellRoot = styled$1("td", {
    name: "MuiTableCell",
    slot: "Root",
    overridesResolver: (props, styles2) => {
        const { ownerState } = props;
        return [
            styles2.root,
            styles2[ownerState.variant],
            styles2[`size${capitalize(ownerState.size)}`],
            ownerState.padding !== "normal" && styles2[`padding${capitalize(ownerState.padding)}`],
            ownerState.align !== "inherit" && styles2[`align${capitalize(ownerState.align)}`],
            ownerState.stickyHeader && styles2.stickyHeader,
        ];
    },
})(({ theme, ownerState }) =>
    _extends(
        {},
        theme.typography.body2,
        {
            display: "table-cell",
            verticalAlign: "inherit",
            // Workaround for a rendering bug with spanned columns in Chrome 62.0.
            // Removes the alpha (sets it to 1), and lightens or darkens the theme color.
            borderBottom: theme.vars
                ? `1px solid ${theme.vars.palette.TableCell.border}`
                : `1px solid
    ${theme.palette.mode === "light" ? lighten(alpha(theme.palette.divider, 1), 0.88) : darken(alpha(theme.palette.divider, 1), 0.68)}`,
            textAlign: "left",
            padding: 16,
        },
        ownerState.variant === "head" && {
            color: (theme.vars || theme).palette.text.primary,
            lineHeight: theme.typography.pxToRem(24),
            fontWeight: theme.typography.fontWeightMedium,
        },
        ownerState.variant === "body" && {
            color: (theme.vars || theme).palette.text.primary,
        },
        ownerState.variant === "footer" && {
            color: (theme.vars || theme).palette.text.secondary,
            lineHeight: theme.typography.pxToRem(21),
            fontSize: theme.typography.pxToRem(12),
        },
        ownerState.size === "small" && {
            padding: "6px 16px",
            [`&.${tableCellClasses$1.paddingCheckbox}`]: {
                width: 24,
                // prevent the checkbox column from growing
                padding: "0 12px 0 16px",
                "& > *": {
                    padding: 0,
                },
            },
        },
        ownerState.padding === "checkbox" && {
            width: 48,
            // prevent the checkbox column from growing
            padding: "0 0 0 4px",
        },
        ownerState.padding === "none" && {
            padding: 0,
        },
        ownerState.align === "left" && {
            textAlign: "left",
        },
        ownerState.align === "center" && {
            textAlign: "center",
        },
        ownerState.align === "right" && {
            textAlign: "right",
            flexDirection: "row-reverse",
        },
        ownerState.align === "justify" && {
            textAlign: "justify",
        },
        ownerState.stickyHeader && {
            position: "sticky",
            top: 0,
            zIndex: 2,
            backgroundColor: (theme.vars || theme).palette.background.default,
        }
    )
);
const TableCell = /* @__PURE__ */ reactExports.forwardRef(function TableCell2(inProps, ref) {
    const props = useThemeProps({
        props: inProps,
        name: "MuiTableCell",
    });
    const { align = "inherit", className, component: componentProp, padding: paddingProp, scope: scopeProp, size: sizeProp, sortDirection, variant: variantProp } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded$c);
    const table = reactExports.useContext(TableContext$1);
    const tablelvl22 = reactExports.useContext(Tablelvl2Context$1);
    const isHeadCell = tablelvl22 && tablelvl22.variant === "head";
    let component;
    if (componentProp) {
        component = componentProp;
    } else {
        component = isHeadCell ? "th" : "td";
    }
    let scope = scopeProp;
    if (component === "td") {
        scope = void 0;
    } else if (!scope && isHeadCell) {
        scope = "col";
    }
    const variant = variantProp || (tablelvl22 && tablelvl22.variant);
    const ownerState = _extends({}, props, {
        align,
        component,
        padding: paddingProp || (table && table.padding ? table.padding : "normal"),
        size: sizeProp || (table && table.size ? table.size : "medium"),
        sortDirection,
        stickyHeader: variant === "head" && table && table.stickyHeader,
        variant,
    });
    const classes = useUtilityClasses$9(ownerState);
    let ariaSort = null;
    if (sortDirection) {
        ariaSort = sortDirection === "asc" ? "ascending" : "descending";
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
        TableCellRoot,
        _extends(
            {
                as: component,
                ref,
                className: clsx$1(classes.root, className),
                "aria-sort": ariaSort,
                scope,
                ownerState,
            },
            other
        )
    );
});
const TableCell$1 = TableCell;
function getTableContainerUtilityClass(slot) {
    return generateUtilityClass("MuiTableContainer", slot);
}
generateUtilityClasses("MuiTableContainer", ["root"]);
const _excluded$b = ["className", "component"];
const useUtilityClasses$8 = (ownerState) => {
    const { classes } = ownerState;
    const slots = {
        root: ["root"],
    };
    return composeClasses(slots, getTableContainerUtilityClass, classes);
};
const TableContainerRoot = styled$1("div", {
    name: "MuiTableContainer",
    slot: "Root",
    overridesResolver: (props, styles2) => styles2.root,
})({
    width: "100%",
    overflowX: "auto",
});
const TableContainer = /* @__PURE__ */ reactExports.forwardRef(function TableContainer2(inProps, ref) {
    const props = useThemeProps({
        props: inProps,
        name: "MuiTableContainer",
    });
    const { className, component = "div" } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded$b);
    const ownerState = _extends({}, props, {
        component,
    });
    const classes = useUtilityClasses$8(ownerState);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
        TableContainerRoot,
        _extends(
            {
                ref,
                as: component,
                className: clsx$1(classes.root, className),
                ownerState,
            },
            other
        )
    );
});
const TableContainer$1 = TableContainer;
function getTableHeadUtilityClass(slot) {
    return generateUtilityClass("MuiTableHead", slot);
}
generateUtilityClasses("MuiTableHead", ["root"]);
const _excluded$a = ["className", "component"];
const useUtilityClasses$7 = (ownerState) => {
    const { classes } = ownerState;
    const slots = {
        root: ["root"],
    };
    return composeClasses(slots, getTableHeadUtilityClass, classes);
};
const TableHeadRoot = styled$1("thead", {
    name: "MuiTableHead",
    slot: "Root",
    overridesResolver: (props, styles2) => styles2.root,
})({
    display: "table-header-group",
});
const tablelvl2 = {
    variant: "head",
};
const defaultComponent$1 = "thead";
const TableHead = /* @__PURE__ */ reactExports.forwardRef(function TableHead2(inProps, ref) {
    const props = useThemeProps({
        props: inProps,
        name: "MuiTableHead",
    });
    const { className, component = defaultComponent$1 } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded$a);
    const ownerState = _extends({}, props, {
        component,
    });
    const classes = useUtilityClasses$7(ownerState);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Tablelvl2Context$1.Provider, {
        value: tablelvl2,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            TableHeadRoot,
            _extends(
                {
                    as: component,
                    className: clsx$1(classes.root, className),
                    ref,
                    role: component === defaultComponent$1 ? null : "rowgroup",
                    ownerState,
                },
                other
            )
        ),
    });
});
const TableHead$1 = TableHead;
const KeyboardArrowLeft = createSvgIcon$1(
    /* @__PURE__ */ jsxRuntimeExports.jsx("path", {
        d: "M15.41 16.09l-4.58-4.59 4.58-4.59L14 5.5l-6 6 6 6z",
    }),
    "KeyboardArrowLeft"
);
const KeyboardArrowRight = createSvgIcon$1(
    /* @__PURE__ */ jsxRuntimeExports.jsx("path", {
        d: "M8.59 16.34l4.58-4.59-4.58-4.59L10 5.75l6 6-6 6z",
    }),
    "KeyboardArrowRight"
);
function getTableRowUtilityClass(slot) {
    return generateUtilityClass("MuiTableRow", slot);
}
const tableRowClasses = generateUtilityClasses("MuiTableRow", ["root", "selected", "hover", "head", "footer"]);
const tableRowClasses$1 = tableRowClasses;
const _excluded$9 = ["className", "component", "hover", "selected"];
const useUtilityClasses$6 = (ownerState) => {
    const { classes, selected, hover, head, footer } = ownerState;
    const slots = {
        root: ["root", selected && "selected", hover && "hover", head && "head", footer && "footer"],
    };
    return composeClasses(slots, getTableRowUtilityClass, classes);
};
const TableRowRoot = styled$1("tr", {
    name: "MuiTableRow",
    slot: "Root",
    overridesResolver: (props, styles2) => {
        const { ownerState } = props;
        return [styles2.root, ownerState.head && styles2.head, ownerState.footer && styles2.footer];
    },
})(({ theme }) => ({
    color: "inherit",
    display: "table-row",
    verticalAlign: "middle",
    // We disable the focus ring for mouse, touch and keyboard users.
    outline: 0,
    [`&.${tableRowClasses$1.hover}:hover`]: {
        backgroundColor: (theme.vars || theme).palette.action.hover,
    },
    [`&.${tableRowClasses$1.selected}`]: {
        backgroundColor: theme.vars
            ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.selectedOpacity})`
            : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity),
        "&:hover": {
            backgroundColor: theme.vars
                ? `rgba(${theme.vars.palette.primary.mainChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.hoverOpacity}))`
                : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity + theme.palette.action.hoverOpacity),
        },
    },
}));
const defaultComponent = "tr";
const TableRow = /* @__PURE__ */ reactExports.forwardRef(function TableRow2(inProps, ref) {
    const props = useThemeProps({
        props: inProps,
        name: "MuiTableRow",
    });
    const { className, component = defaultComponent, hover = false, selected = false } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded$9);
    const tablelvl22 = reactExports.useContext(Tablelvl2Context$1);
    const ownerState = _extends({}, props, {
        component,
        hover,
        selected,
        head: tablelvl22 && tablelvl22.variant === "head",
        footer: tablelvl22 && tablelvl22.variant === "footer",
    });
    const classes = useUtilityClasses$6(ownerState);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
        TableRowRoot,
        _extends(
            {
                as: component,
                ref,
                className: clsx$1(classes.root, className),
                role: component === defaultComponent ? null : "row",
                ownerState,
            },
            other
        )
    );
});
const TableRow$1 = TableRow;
const ArrowDownwardIcon = createSvgIcon$1(
    /* @__PURE__ */ jsxRuntimeExports.jsx("path", {
        d: "M20 12l-1.41-1.41L13 16.17V4h-2v12.17l-5.58-5.59L4 12l8 8 8-8z",
    }),
    "ArrowDownward"
);
function getTableSortLabelUtilityClass(slot) {
    return generateUtilityClass("MuiTableSortLabel", slot);
}
const tableSortLabelClasses = generateUtilityClasses("MuiTableSortLabel", ["root", "active", "icon", "iconDirectionDesc", "iconDirectionAsc"]);
const tableSortLabelClasses$1 = tableSortLabelClasses;
const _excluded$8 = ["active", "children", "className", "direction", "hideSortIcon", "IconComponent"];
const useUtilityClasses$5 = (ownerState) => {
    const { classes, direction, active } = ownerState;
    const slots = {
        root: ["root", active && "active"],
        icon: ["icon", `iconDirection${capitalize(direction)}`],
    };
    return composeClasses(slots, getTableSortLabelUtilityClass, classes);
};
const TableSortLabelRoot = styled$1(ButtonBase$1, {
    name: "MuiTableSortLabel",
    slot: "Root",
    overridesResolver: (props, styles2) => {
        const { ownerState } = props;
        return [styles2.root, ownerState.active && styles2.active];
    },
})(({ theme }) => ({
    cursor: "pointer",
    display: "inline-flex",
    justifyContent: "flex-start",
    flexDirection: "inherit",
    alignItems: "center",
    "&:focus": {
        color: (theme.vars || theme).palette.text.secondary,
    },
    "&:hover": {
        color: (theme.vars || theme).palette.text.secondary,
        [`& .${tableSortLabelClasses$1.icon}`]: {
            opacity: 0.5,
        },
    },
    [`&.${tableSortLabelClasses$1.active}`]: {
        color: (theme.vars || theme).palette.text.primary,
        [`& .${tableSortLabelClasses$1.icon}`]: {
            opacity: 1,
            color: (theme.vars || theme).palette.text.secondary,
        },
    },
}));
const TableSortLabelIcon = styled$1("span", {
    name: "MuiTableSortLabel",
    slot: "Icon",
    overridesResolver: (props, styles2) => {
        const { ownerState } = props;
        return [styles2.icon, styles2[`iconDirection${capitalize(ownerState.direction)}`]];
    },
})(({ theme, ownerState }) =>
    _extends(
        {
            fontSize: 18,
            marginRight: 4,
            marginLeft: 4,
            opacity: 0,
            transition: theme.transitions.create(["opacity", "transform"], {
                duration: theme.transitions.duration.shorter,
            }),
            userSelect: "none",
        },
        ownerState.direction === "desc" && {
            transform: "rotate(0deg)",
        },
        ownerState.direction === "asc" && {
            transform: "rotate(180deg)",
        }
    )
);
const TableSortLabel = /* @__PURE__ */ reactExports.forwardRef(function TableSortLabel2(inProps, ref) {
    const props = useThemeProps({
        props: inProps,
        name: "MuiTableSortLabel",
    });
    const { active = false, children, className, direction = "asc", hideSortIcon = false, IconComponent = ArrowDownwardIcon } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded$8);
    const ownerState = _extends({}, props, {
        active,
        direction,
        hideSortIcon,
        IconComponent,
    });
    const classes = useUtilityClasses$5(ownerState);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        TableSortLabelRoot,
        _extends(
            {
                className: clsx$1(classes.root, className),
                component: "span",
                disableRipple: true,
                ownerState,
                ref,
            },
            other,
            {
                children: [
                    children,
                    hideSortIcon && !active
                        ? null
                        : /* @__PURE__ */ jsxRuntimeExports.jsx(TableSortLabelIcon, {
                              as: IconComponent,
                              className: clsx$1(classes.icon),
                              ownerState,
                          }),
                ],
            }
        )
    );
});
const TableSortLabel$1 = TableSortLabel;
function easeInOutSin(time) {
    return (1 + Math.sin(Math.PI * time - Math.PI / 2)) / 2;
}
function animate(property, element, to, options = {}, cb = () => {}) {
    const {
        ease = easeInOutSin,
        duration: duration2 = 300,
        // standard
    } = options;
    let start2 = null;
    const from2 = element[property];
    let cancelled = false;
    const cancel = () => {
        cancelled = true;
    };
    const step = (timestamp) => {
        if (cancelled) {
            cb(new Error("Animation cancelled"));
            return;
        }
        if (start2 === null) {
            start2 = timestamp;
        }
        const time = Math.min(1, (timestamp - start2) / duration2);
        element[property] = ease(time) * (to - from2) + from2;
        if (time >= 1) {
            requestAnimationFrame(() => {
                cb(null);
            });
            return;
        }
        requestAnimationFrame(step);
    };
    if (from2 === to) {
        cb(new Error("Element already at target position"));
        return cancel;
    }
    requestAnimationFrame(step);
    return cancel;
}
const _excluded$7 = ["onChange"];
const styles = {
    width: 99,
    height: 99,
    position: "absolute",
    top: -9999,
    overflow: "scroll",
};
function ScrollbarSize(props) {
    const { onChange } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded$7);
    const scrollbarHeight = reactExports.useRef();
    const nodeRef = reactExports.useRef(null);
    const setMeasurements = () => {
        scrollbarHeight.current = nodeRef.current.offsetHeight - nodeRef.current.clientHeight;
    };
    useEnhancedEffect$1(() => {
        const handleResize = debounce$1(() => {
            const prevHeight = scrollbarHeight.current;
            setMeasurements();
            if (prevHeight !== scrollbarHeight.current) {
                onChange(scrollbarHeight.current);
            }
        });
        const containerWindow = ownerWindow(nodeRef.current);
        containerWindow.addEventListener("resize", handleResize);
        return () => {
            handleResize.clear();
            containerWindow.removeEventListener("resize", handleResize);
        };
    }, [onChange]);
    reactExports.useEffect(() => {
        setMeasurements();
        onChange(scrollbarHeight.current);
    }, [onChange]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        _extends(
            {
                style: styles,
                ref: nodeRef,
            },
            other
        )
    );
}
function getTabScrollButtonUtilityClass(slot) {
    return generateUtilityClass("MuiTabScrollButton", slot);
}
const tabScrollButtonClasses = generateUtilityClasses("MuiTabScrollButton", ["root", "vertical", "horizontal", "disabled"]);
const tabScrollButtonClasses$1 = tabScrollButtonClasses;
const _excluded$6 = ["className", "slots", "slotProps", "direction", "orientation", "disabled"];
const useUtilityClasses$4 = (ownerState) => {
    const { classes, orientation, disabled } = ownerState;
    const slots = {
        root: ["root", orientation, disabled && "disabled"],
    };
    return composeClasses(slots, getTabScrollButtonUtilityClass, classes);
};
const TabScrollButtonRoot = styled$1(ButtonBase$1, {
    name: "MuiTabScrollButton",
    slot: "Root",
    overridesResolver: (props, styles2) => {
        const { ownerState } = props;
        return [styles2.root, ownerState.orientation && styles2[ownerState.orientation]];
    },
})(({ ownerState }) =>
    _extends(
        {
            width: 40,
            flexShrink: 0,
            opacity: 0.8,
            [`&.${tabScrollButtonClasses$1.disabled}`]: {
                opacity: 0,
            },
        },
        ownerState.orientation === "vertical" && {
            width: "100%",
            height: 40,
            "& svg": {
                transform: `rotate(${ownerState.isRtl ? -90 : 90}deg)`,
            },
        }
    )
);
const TabScrollButton = /* @__PURE__ */ reactExports.forwardRef(function TabScrollButton2(inProps, ref) {
    var _slots$StartScrollBut, _slots$EndScrollButto;
    const props = useThemeProps({
        props: inProps,
        name: "MuiTabScrollButton",
    });
    const { className, slots = {}, slotProps = {}, direction } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded$6);
    const theme = useTheme();
    const isRtl = theme.direction === "rtl";
    const ownerState = _extends(
        {
            isRtl,
        },
        props
    );
    const classes = useUtilityClasses$4(ownerState);
    const StartButtonIcon = (_slots$StartScrollBut = slots.StartScrollButtonIcon) != null ? _slots$StartScrollBut : KeyboardArrowLeft;
    const EndButtonIcon = (_slots$EndScrollButto = slots.EndScrollButtonIcon) != null ? _slots$EndScrollButto : KeyboardArrowRight;
    const startButtonIconProps = useSlotProps({
        elementType: StartButtonIcon,
        externalSlotProps: slotProps.startScrollButtonIcon,
        additionalProps: {
            fontSize: "small",
        },
        ownerState,
    });
    const endButtonIconProps = useSlotProps({
        elementType: EndButtonIcon,
        externalSlotProps: slotProps.endScrollButtonIcon,
        additionalProps: {
            fontSize: "small",
        },
        ownerState,
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
        TabScrollButtonRoot,
        _extends(
            {
                component: "div",
                className: clsx$1(classes.root, className),
                ref,
                role: null,
                ownerState,
                tabIndex: null,
            },
            other,
            {
                children:
                    direction === "left"
                        ? /* @__PURE__ */ jsxRuntimeExports.jsx(StartButtonIcon, _extends({}, startButtonIconProps))
                        : /* @__PURE__ */ jsxRuntimeExports.jsx(EndButtonIcon, _extends({}, endButtonIconProps)),
            }
        )
    );
});
const TabScrollButton$1 = TabScrollButton;
function getTabsUtilityClass(slot) {
    return generateUtilityClass("MuiTabs", slot);
}
const tabsClasses = generateUtilityClasses("MuiTabs", [
    "root",
    "vertical",
    "flexContainer",
    "flexContainerVertical",
    "centered",
    "scroller",
    "fixed",
    "scrollableX",
    "scrollableY",
    "hideScrollbar",
    "scrollButtons",
    "scrollButtonsHideMobile",
    "indicator",
]);
const tabsClasses$1 = tabsClasses;
const _excluded$5 = [
    "aria-label",
    "aria-labelledby",
    "action",
    "centered",
    "children",
    "className",
    "component",
    "allowScrollButtonsMobile",
    "indicatorColor",
    "onChange",
    "orientation",
    "ScrollButtonComponent",
    "scrollButtons",
    "selectionFollowsFocus",
    "slots",
    "slotProps",
    "TabIndicatorProps",
    "TabScrollButtonProps",
    "textColor",
    "value",
    "variant",
    "visibleScrollbar",
];
const nextItem = (list, item) => {
    if (list === item) {
        return list.firstChild;
    }
    if (item && item.nextElementSibling) {
        return item.nextElementSibling;
    }
    return list.firstChild;
};
const previousItem = (list, item) => {
    if (list === item) {
        return list.lastChild;
    }
    if (item && item.previousElementSibling) {
        return item.previousElementSibling;
    }
    return list.lastChild;
};
const moveFocus = (list, currentFocus, traversalFunction) => {
    let wrappedOnce = false;
    let nextFocus = traversalFunction(list, currentFocus);
    while (nextFocus) {
        if (nextFocus === list.firstChild) {
            if (wrappedOnce) {
                return;
            }
            wrappedOnce = true;
        }
        const nextFocusDisabled = nextFocus.disabled || nextFocus.getAttribute("aria-disabled") === "true";
        if (!nextFocus.hasAttribute("tabindex") || nextFocusDisabled) {
            nextFocus = traversalFunction(list, nextFocus);
        } else {
            nextFocus.focus();
            return;
        }
    }
};
const useUtilityClasses$3 = (ownerState) => {
    const { vertical, fixed, hideScrollbar, scrollableX, scrollableY, centered, scrollButtonsHideMobile, classes } = ownerState;
    const slots = {
        root: ["root", vertical && "vertical"],
        scroller: ["scroller", fixed && "fixed", hideScrollbar && "hideScrollbar", scrollableX && "scrollableX", scrollableY && "scrollableY"],
        flexContainer: ["flexContainer", vertical && "flexContainerVertical", centered && "centered"],
        indicator: ["indicator"],
        scrollButtons: ["scrollButtons", scrollButtonsHideMobile && "scrollButtonsHideMobile"],
        scrollableX: [scrollableX && "scrollableX"],
        hideScrollbar: [hideScrollbar && "hideScrollbar"],
    };
    return composeClasses(slots, getTabsUtilityClass, classes);
};
const TabsRoot = styled$1("div", {
    name: "MuiTabs",
    slot: "Root",
    overridesResolver: (props, styles2) => {
        const { ownerState } = props;
        return [
            {
                [`& .${tabsClasses$1.scrollButtons}`]: styles2.scrollButtons,
            },
            {
                [`& .${tabsClasses$1.scrollButtons}`]: ownerState.scrollButtonsHideMobile && styles2.scrollButtonsHideMobile,
            },
            styles2.root,
            ownerState.vertical && styles2.vertical,
        ];
    },
})(({ ownerState, theme }) =>
    _extends(
        {
            overflow: "hidden",
            minHeight: 48,
            // Add iOS momentum scrolling for iOS < 13.0
            WebkitOverflowScrolling: "touch",
            display: "flex",
        },
        ownerState.vertical && {
            flexDirection: "column",
        },
        ownerState.scrollButtonsHideMobile && {
            [`& .${tabsClasses$1.scrollButtons}`]: {
                [theme.breakpoints.down("sm")]: {
                    display: "none",
                },
            },
        }
    )
);
const TabsScroller = styled$1("div", {
    name: "MuiTabs",
    slot: "Scroller",
    overridesResolver: (props, styles2) => {
        const { ownerState } = props;
        return [
            styles2.scroller,
            ownerState.fixed && styles2.fixed,
            ownerState.hideScrollbar && styles2.hideScrollbar,
            ownerState.scrollableX && styles2.scrollableX,
            ownerState.scrollableY && styles2.scrollableY,
        ];
    },
})(({ ownerState }) =>
    _extends(
        {
            position: "relative",
            display: "inline-block",
            flex: "1 1 auto",
            whiteSpace: "nowrap",
        },
        ownerState.fixed && {
            overflowX: "hidden",
            width: "100%",
        },
        ownerState.hideScrollbar && {
            // Hide dimensionless scrollbar on macOS
            scrollbarWidth: "none",
            // Firefox
            "&::-webkit-scrollbar": {
                display: "none",
                // Safari + Chrome
            },
        },
        ownerState.scrollableX && {
            overflowX: "auto",
            overflowY: "hidden",
        },
        ownerState.scrollableY && {
            overflowY: "auto",
            overflowX: "hidden",
        }
    )
);
const FlexContainer = styled$1("div", {
    name: "MuiTabs",
    slot: "FlexContainer",
    overridesResolver: (props, styles2) => {
        const { ownerState } = props;
        return [styles2.flexContainer, ownerState.vertical && styles2.flexContainerVertical, ownerState.centered && styles2.centered];
    },
})(({ ownerState }) =>
    _extends(
        {
            display: "flex",
        },
        ownerState.vertical && {
            flexDirection: "column",
        },
        ownerState.centered && {
            justifyContent: "center",
        }
    )
);
const TabsIndicator = styled$1("span", {
    name: "MuiTabs",
    slot: "Indicator",
    overridesResolver: (props, styles2) => styles2.indicator,
})(({ ownerState, theme }) =>
    _extends(
        {
            position: "absolute",
            height: 2,
            bottom: 0,
            width: "100%",
            transition: theme.transitions.create(),
        },
        ownerState.indicatorColor === "primary" && {
            backgroundColor: (theme.vars || theme).palette.primary.main,
        },
        ownerState.indicatorColor === "secondary" && {
            backgroundColor: (theme.vars || theme).palette.secondary.main,
        },
        ownerState.vertical && {
            height: "100%",
            width: 2,
            right: 0,
        }
    )
);
const TabsScrollbarSize = styled$1(ScrollbarSize, {
    name: "MuiTabs",
    slot: "ScrollbarSize",
})({
    overflowX: "auto",
    overflowY: "hidden",
    // Hide dimensionless scrollbar on macOS
    scrollbarWidth: "none",
    // Firefox
    "&::-webkit-scrollbar": {
        display: "none",
        // Safari + Chrome
    },
});
const defaultIndicatorStyle = {};
const Tabs = /* @__PURE__ */ reactExports.forwardRef(function Tabs2(inProps, ref) {
    const props = useThemeProps({
        props: inProps,
        name: "MuiTabs",
    });
    const theme = useTheme();
    const isRtl = theme.direction === "rtl";
    const {
            "aria-label": ariaLabel,
            "aria-labelledby": ariaLabelledBy,
            action,
            centered = false,
            children: childrenProp,
            className,
            component = "div",
            allowScrollButtonsMobile = false,
            indicatorColor = "primary",
            onChange,
            orientation = "horizontal",
            ScrollButtonComponent = TabScrollButton$1,
            scrollButtons = "auto",
            selectionFollowsFocus,
            slots = {},
            slotProps = {},
            TabIndicatorProps = {},
            TabScrollButtonProps = {},
            textColor = "primary",
            value,
            variant = "standard",
            visibleScrollbar = false,
        } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded$5);
    const scrollable = variant === "scrollable";
    const vertical = orientation === "vertical";
    const scrollStart = vertical ? "scrollTop" : "scrollLeft";
    const start2 = vertical ? "top" : "left";
    const end2 = vertical ? "bottom" : "right";
    const clientSize = vertical ? "clientHeight" : "clientWidth";
    const size = vertical ? "height" : "width";
    const ownerState = _extends({}, props, {
        component,
        allowScrollButtonsMobile,
        indicatorColor,
        orientation,
        vertical,
        scrollButtons,
        textColor,
        variant,
        visibleScrollbar,
        fixed: !scrollable,
        hideScrollbar: scrollable && !visibleScrollbar,
        scrollableX: scrollable && !vertical,
        scrollableY: scrollable && vertical,
        centered: centered && !scrollable,
        scrollButtonsHideMobile: !allowScrollButtonsMobile,
    });
    const classes = useUtilityClasses$3(ownerState);
    const startScrollButtonIconProps = useSlotProps({
        elementType: slots.StartScrollButtonIcon,
        externalSlotProps: slotProps.startScrollButtonIcon,
        ownerState,
    });
    const endScrollButtonIconProps = useSlotProps({
        elementType: slots.EndScrollButtonIcon,
        externalSlotProps: slotProps.endScrollButtonIcon,
        ownerState,
    });
    const [mounted, setMounted] = reactExports.useState(false);
    const [indicatorStyle, setIndicatorStyle] = reactExports.useState(defaultIndicatorStyle);
    const [displayScroll, setDisplayScroll] = reactExports.useState({
        start: false,
        end: false,
    });
    const [scrollerStyle, setScrollerStyle] = reactExports.useState({
        overflow: "hidden",
        scrollbarWidth: 0,
    });
    const valueToIndex = /* @__PURE__ */ new Map();
    const tabsRef = reactExports.useRef(null);
    const tabListRef = reactExports.useRef(null);
    const getTabsMeta = () => {
        const tabsNode = tabsRef.current;
        let tabsMeta;
        if (tabsNode) {
            const rect = tabsNode.getBoundingClientRect();
            tabsMeta = {
                clientWidth: tabsNode.clientWidth,
                scrollLeft: tabsNode.scrollLeft,
                scrollTop: tabsNode.scrollTop,
                scrollLeftNormalized: getNormalizedScrollLeft(tabsNode, theme.direction),
                scrollWidth: tabsNode.scrollWidth,
                top: rect.top,
                bottom: rect.bottom,
                left: rect.left,
                right: rect.right,
            };
        }
        let tabMeta;
        if (tabsNode && value !== false) {
            const children2 = tabListRef.current.children;
            if (children2.length > 0) {
                const tab = children2[valueToIndex.get(value)];
                tabMeta = tab ? tab.getBoundingClientRect() : null;
            }
        }
        return {
            tabsMeta,
            tabMeta,
        };
    };
    const updateIndicatorState = useEventCallback(() => {
        const { tabsMeta, tabMeta } = getTabsMeta();
        let startValue = 0;
        let startIndicator;
        if (vertical) {
            startIndicator = "top";
            if (tabMeta && tabsMeta) {
                startValue = tabMeta.top - tabsMeta.top + tabsMeta.scrollTop;
            }
        } else {
            startIndicator = isRtl ? "right" : "left";
            if (tabMeta && tabsMeta) {
                const correction = isRtl ? tabsMeta.scrollLeftNormalized + tabsMeta.clientWidth - tabsMeta.scrollWidth : tabsMeta.scrollLeft;
                startValue = (isRtl ? -1 : 1) * (tabMeta[startIndicator] - tabsMeta[startIndicator] + correction);
            }
        }
        const newIndicatorStyle = {
            [startIndicator]: startValue,
            // May be wrong until the font is loaded.
            [size]: tabMeta ? tabMeta[size] : 0,
        };
        if (isNaN(indicatorStyle[startIndicator]) || isNaN(indicatorStyle[size])) {
            setIndicatorStyle(newIndicatorStyle);
        } else {
            const dStart = Math.abs(indicatorStyle[startIndicator] - newIndicatorStyle[startIndicator]);
            const dSize = Math.abs(indicatorStyle[size] - newIndicatorStyle[size]);
            if (dStart >= 1 || dSize >= 1) {
                setIndicatorStyle(newIndicatorStyle);
            }
        }
    });
    const scroll = (scrollValue, { animation = true } = {}) => {
        if (animation) {
            animate(scrollStart, tabsRef.current, scrollValue, {
                duration: theme.transitions.duration.standard,
            });
        } else {
            tabsRef.current[scrollStart] = scrollValue;
        }
    };
    const moveTabsScroll = (delta) => {
        let scrollValue = tabsRef.current[scrollStart];
        if (vertical) {
            scrollValue += delta;
        } else {
            scrollValue += delta * (isRtl ? -1 : 1);
            scrollValue *= isRtl && detectScrollType() === "reverse" ? -1 : 1;
        }
        scroll(scrollValue);
    };
    const getScrollSize = () => {
        const containerSize = tabsRef.current[clientSize];
        let totalSize = 0;
        const children2 = Array.from(tabListRef.current.children);
        for (let i = 0; i < children2.length; i += 1) {
            const tab = children2[i];
            if (totalSize + tab[clientSize] > containerSize) {
                if (i === 0) {
                    totalSize = containerSize;
                }
                break;
            }
            totalSize += tab[clientSize];
        }
        return totalSize;
    };
    const handleStartScrollClick = () => {
        moveTabsScroll(-1 * getScrollSize());
    };
    const handleEndScrollClick = () => {
        moveTabsScroll(getScrollSize());
    };
    const handleScrollbarSizeChange = reactExports.useCallback((scrollbarWidth) => {
        setScrollerStyle({
            overflow: null,
            scrollbarWidth,
        });
    }, []);
    const getConditionalElements = () => {
        const conditionalElements2 = {};
        conditionalElements2.scrollbarSizeListener = scrollable
            ? /* @__PURE__ */ jsxRuntimeExports.jsx(TabsScrollbarSize, {
                  onChange: handleScrollbarSizeChange,
                  className: clsx$1(classes.scrollableX, classes.hideScrollbar),
              })
            : null;
        const scrollButtonsActive = displayScroll.start || displayScroll.end;
        const showScrollButtons = scrollable && ((scrollButtons === "auto" && scrollButtonsActive) || scrollButtons === true);
        conditionalElements2.scrollButtonStart = showScrollButtons
            ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                  ScrollButtonComponent,
                  _extends(
                      {
                          slots: {
                              StartScrollButtonIcon: slots.StartScrollButtonIcon,
                          },
                          slotProps: {
                              startScrollButtonIcon: startScrollButtonIconProps,
                          },
                          orientation,
                          direction: isRtl ? "right" : "left",
                          onClick: handleStartScrollClick,
                          disabled: !displayScroll.start,
                      },
                      TabScrollButtonProps,
                      {
                          className: clsx$1(classes.scrollButtons, TabScrollButtonProps.className),
                      }
                  )
              )
            : null;
        conditionalElements2.scrollButtonEnd = showScrollButtons
            ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                  ScrollButtonComponent,
                  _extends(
                      {
                          slots: {
                              EndScrollButtonIcon: slots.EndScrollButtonIcon,
                          },
                          slotProps: {
                              endScrollButtonIcon: endScrollButtonIconProps,
                          },
                          orientation,
                          direction: isRtl ? "left" : "right",
                          onClick: handleEndScrollClick,
                          disabled: !displayScroll.end,
                      },
                      TabScrollButtonProps,
                      {
                          className: clsx$1(classes.scrollButtons, TabScrollButtonProps.className),
                      }
                  )
              )
            : null;
        return conditionalElements2;
    };
    const scrollSelectedIntoView = useEventCallback((animation) => {
        const { tabsMeta, tabMeta } = getTabsMeta();
        if (!tabMeta || !tabsMeta) {
            return;
        }
        if (tabMeta[start2] < tabsMeta[start2]) {
            const nextScrollStart = tabsMeta[scrollStart] + (tabMeta[start2] - tabsMeta[start2]);
            scroll(nextScrollStart, {
                animation,
            });
        } else if (tabMeta[end2] > tabsMeta[end2]) {
            const nextScrollStart = tabsMeta[scrollStart] + (tabMeta[end2] - tabsMeta[end2]);
            scroll(nextScrollStart, {
                animation,
            });
        }
    });
    const updateScrollButtonState = useEventCallback(() => {
        if (scrollable && scrollButtons !== false) {
            const { scrollTop, scrollHeight, clientHeight, scrollWidth, clientWidth } = tabsRef.current;
            let showStartScroll;
            let showEndScroll;
            if (vertical) {
                showStartScroll = scrollTop > 1;
                showEndScroll = scrollTop < scrollHeight - clientHeight - 1;
            } else {
                const scrollLeft = getNormalizedScrollLeft(tabsRef.current, theme.direction);
                showStartScroll = isRtl ? scrollLeft < scrollWidth - clientWidth - 1 : scrollLeft > 1;
                showEndScroll = !isRtl ? scrollLeft < scrollWidth - clientWidth - 1 : scrollLeft > 1;
            }
            if (showStartScroll !== displayScroll.start || showEndScroll !== displayScroll.end) {
                setDisplayScroll({
                    start: showStartScroll,
                    end: showEndScroll,
                });
            }
        }
    });
    reactExports.useEffect(() => {
        const handleResize = debounce$1(() => {
            if (tabsRef.current) {
                updateIndicatorState();
                updateScrollButtonState();
            }
        });
        const win = ownerWindow(tabsRef.current);
        win.addEventListener("resize", handleResize);
        let resizeObserver;
        if (typeof ResizeObserver !== "undefined") {
            resizeObserver = new ResizeObserver(handleResize);
            Array.from(tabListRef.current.children).forEach((child) => {
                resizeObserver.observe(child);
            });
        }
        return () => {
            handleResize.clear();
            win.removeEventListener("resize", handleResize);
            if (resizeObserver) {
                resizeObserver.disconnect();
            }
        };
    }, [updateIndicatorState, updateScrollButtonState]);
    const handleTabsScroll = reactExports.useMemo(
        () =>
            debounce$1(() => {
                updateScrollButtonState();
            }),
        [updateScrollButtonState]
    );
    reactExports.useEffect(() => {
        return () => {
            handleTabsScroll.clear();
        };
    }, [handleTabsScroll]);
    reactExports.useEffect(() => {
        setMounted(true);
    }, []);
    reactExports.useEffect(() => {
        updateIndicatorState();
        updateScrollButtonState();
    });
    reactExports.useEffect(() => {
        scrollSelectedIntoView(defaultIndicatorStyle !== indicatorStyle);
    }, [scrollSelectedIntoView, indicatorStyle]);
    reactExports.useImperativeHandle(
        action,
        () => ({
            updateIndicator: updateIndicatorState,
            updateScrollButtons: updateScrollButtonState,
        }),
        [updateIndicatorState, updateScrollButtonState]
    );
    const indicator = /* @__PURE__ */ jsxRuntimeExports.jsx(
        TabsIndicator,
        _extends({}, TabIndicatorProps, {
            className: clsx$1(classes.indicator, TabIndicatorProps.className),
            ownerState,
            style: _extends({}, indicatorStyle, TabIndicatorProps.style),
        })
    );
    let childIndex = 0;
    const children = reactExports.Children.map(childrenProp, (child) => {
        if (!(/* @__PURE__ */ reactExports.isValidElement(child))) {
            return null;
        }
        const childValue = child.props.value === void 0 ? childIndex : child.props.value;
        valueToIndex.set(childValue, childIndex);
        const selected = childValue === value;
        childIndex += 1;
        return /* @__PURE__ */ reactExports.cloneElement(
            child,
            _extends(
                {
                    fullWidth: variant === "fullWidth",
                    indicator: selected && !mounted && indicator,
                    selected,
                    selectionFollowsFocus,
                    onChange,
                    textColor,
                    value: childValue,
                },
                childIndex === 1 && value === false && !child.props.tabIndex
                    ? {
                          tabIndex: 0,
                      }
                    : {}
            )
        );
    });
    const handleKeyDown2 = (event) => {
        const list = tabListRef.current;
        const currentFocus = ownerDocument(list).activeElement;
        const role = currentFocus.getAttribute("role");
        if (role !== "tab") {
            return;
        }
        let previousItemKey = orientation === "horizontal" ? "ArrowLeft" : "ArrowUp";
        let nextItemKey = orientation === "horizontal" ? "ArrowRight" : "ArrowDown";
        if (orientation === "horizontal" && isRtl) {
            previousItemKey = "ArrowRight";
            nextItemKey = "ArrowLeft";
        }
        switch (event.key) {
            case previousItemKey:
                event.preventDefault();
                moveFocus(list, currentFocus, previousItem);
                break;
            case nextItemKey:
                event.preventDefault();
                moveFocus(list, currentFocus, nextItem);
                break;
            case "Home":
                event.preventDefault();
                moveFocus(list, null, nextItem);
                break;
            case "End":
                event.preventDefault();
                moveFocus(list, null, previousItem);
                break;
        }
    };
    const conditionalElements = getConditionalElements();
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        TabsRoot,
        _extends(
            {
                className: clsx$1(classes.root, className),
                ownerState,
                ref,
                as: component,
            },
            other,
            {
                children: [
                    conditionalElements.scrollButtonStart,
                    conditionalElements.scrollbarSizeListener,
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(TabsScroller, {
                        className: classes.scroller,
                        ownerState,
                        style: {
                            overflow: scrollerStyle.overflow,
                            [vertical ? `margin${isRtl ? "Left" : "Right"}` : "marginBottom"]: visibleScrollbar ? void 0 : -scrollerStyle.scrollbarWidth,
                        },
                        ref: tabsRef,
                        onScroll: handleTabsScroll,
                        children: [
                            /* @__PURE__ */ jsxRuntimeExports.jsx(FlexContainer, {
                                "aria-label": ariaLabel,
                                "aria-labelledby": ariaLabelledBy,
                                "aria-orientation": orientation === "vertical" ? "vertical" : null,
                                className: classes.flexContainer,
                                ownerState,
                                onKeyDown: handleKeyDown2,
                                ref: tabListRef,
                                role: "tablist",
                                children,
                            }),
                            mounted && indicator,
                        ],
                    }),
                    conditionalElements.scrollButtonEnd,
                ],
            }
        )
    );
});
const Tabs$1 = Tabs;
function getTextFieldUtilityClass(slot) {
    return generateUtilityClass("MuiTextField", slot);
}
generateUtilityClasses("MuiTextField", ["root"]);
const _excluded$4 = [
    "autoComplete",
    "autoFocus",
    "children",
    "className",
    "color",
    "defaultValue",
    "disabled",
    "error",
    "FormHelperTextProps",
    "fullWidth",
    "helperText",
    "id",
    "InputLabelProps",
    "inputProps",
    "InputProps",
    "inputRef",
    "label",
    "maxRows",
    "minRows",
    "multiline",
    "name",
    "onBlur",
    "onChange",
    "onFocus",
    "placeholder",
    "required",
    "rows",
    "select",
    "SelectProps",
    "type",
    "value",
    "variant",
];
const variantComponent = {
    standard: Input$1,
    filled: FilledInput$1,
    outlined: OutlinedInput$1,
};
const useUtilityClasses$2 = (ownerState) => {
    const { classes } = ownerState;
    const slots = {
        root: ["root"],
    };
    return composeClasses(slots, getTextFieldUtilityClass, classes);
};
const TextFieldRoot = styled$1(FormControl$1, {
    name: "MuiTextField",
    slot: "Root",
    overridesResolver: (props, styles2) => styles2.root,
})({});
const TextField = /* @__PURE__ */ reactExports.forwardRef(function TextField2(inProps, ref) {
    const props = useThemeProps({
        props: inProps,
        name: "MuiTextField",
    });
    const {
            autoComplete,
            autoFocus = false,
            children,
            className,
            color: color2 = "primary",
            defaultValue,
            disabled = false,
            error = false,
            FormHelperTextProps,
            fullWidth = false,
            helperText,
            id: idOverride,
            InputLabelProps,
            inputProps,
            InputProps,
            inputRef,
            label,
            maxRows,
            minRows,
            multiline = false,
            name,
            onBlur,
            onChange,
            onFocus,
            placeholder,
            required = false,
            rows,
            select = false,
            SelectProps,
            type,
            value,
            variant = "outlined",
        } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded$4);
    const ownerState = _extends({}, props, {
        autoFocus,
        color: color2,
        disabled,
        error,
        fullWidth,
        multiline,
        required,
        select,
        variant,
    });
    const classes = useUtilityClasses$2(ownerState);
    const InputMore = {};
    if (variant === "outlined") {
        if (InputLabelProps && typeof InputLabelProps.shrink !== "undefined") {
            InputMore.notched = InputLabelProps.shrink;
        }
        InputMore.label = label;
    }
    if (select) {
        if (!SelectProps || !SelectProps.native) {
            InputMore.id = void 0;
        }
        InputMore["aria-describedby"] = void 0;
    }
    const id = useId(idOverride);
    const helperTextId = helperText && id ? `${id}-helper-text` : void 0;
    const inputLabelId = label && id ? `${id}-label` : void 0;
    const InputComponent = variantComponent[variant];
    const InputElement = /* @__PURE__ */ jsxRuntimeExports.jsx(
        InputComponent,
        _extends(
            {
                "aria-describedby": helperTextId,
                autoComplete,
                autoFocus,
                defaultValue,
                fullWidth,
                multiline,
                name,
                rows,
                maxRows,
                minRows,
                type,
                value,
                id,
                inputRef,
                onBlur,
                onChange,
                onFocus,
                placeholder,
                inputProps,
            },
            InputMore,
            InputProps
        )
    );
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        TextFieldRoot,
        _extends(
            {
                className: clsx$1(classes.root, className),
                disabled,
                error,
                fullWidth,
                ref,
                required,
                color: color2,
                variant,
                ownerState,
            },
            other,
            {
                children: [
                    label != null &&
                        label !== "" &&
                        /* @__PURE__ */ jsxRuntimeExports.jsx(
                            InputLabel$1,
                            _extends(
                                {
                                    htmlFor: id,
                                    id: inputLabelId,
                                },
                                InputLabelProps,
                                {
                                    children: label,
                                }
                            )
                        ),
                    select
                        ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                              Select$1,
                              _extends(
                                  {
                                      "aria-describedby": helperTextId,
                                      id,
                                      labelId: inputLabelId,
                                      value,
                                      input: InputElement,
                                  },
                                  SelectProps,
                                  {
                                      children,
                                  }
                              )
                          )
                        : InputElement,
                    helperText &&
                        /* @__PURE__ */ jsxRuntimeExports.jsx(
                            FormHelperText$1,
                            _extends(
                                {
                                    id: helperTextId,
                                },
                                FormHelperTextProps,
                                {
                                    children: helperText,
                                }
                            )
                        ),
                ],
            }
        )
    );
});
const TextField$1 = TextField;
var URI = "RemoteData";
var loading = function () {
    return { tag: "Loading" };
};
var failure = function (error) {
    return { tag: "Failure", error };
};
var success = function (data) {
    return { tag: "Success", data };
};
var isNotAsked = function (rd) {
    return rd.tag === "NotAsked";
};
var isLoading = function (rd) {
    return rd.tag === "Loading";
};
var isFailure = function (rd) {
    return rd.tag === "Failure";
};
var isSuccess = function (rd) {
    return rd.tag === "Success";
};
var SRD = {
    URI,
    map: function (f2, fa) {
        return isSuccess(fa) ? success(f2(fa.data)) : fa;
    },
    map2: function (f2, fa, fb) {
        return isSuccess(fa) ? (isSuccess(fb) ? success(f2(fa.data, fb.data)) : fb) : fa;
    },
    map3: function (f2, fa, fb, fc) {
        return isSuccess(fa) ? (isSuccess(fb) ? (isSuccess(fc) ? success(f2(fa.data, fb.data, fc.data)) : fc) : fb) : fa;
    },
    mapFailure: function (f2, fa) {
        return isFailure(fa) ? failure(f2(fa.error)) : fa;
    },
    chain: function (f2, fa) {
        return isSuccess(fa) ? f2(fa.data) : fa;
    },
    bimap: function (failureFn, successFn, rd) {
        return isSuccess(rd) ? success(successFn(rd.data)) : isFailure(rd) ? failure(failureFn(rd.error)) : rd;
    },
    ap: function (rdFn, rd) {
        return isSuccess(rd) ? (isSuccess(rdFn) ? success(rdFn.data(rd.data)) : rdFn) : rd;
    },
    alt: function (def, rd) {
        return isSuccess(rd) ? rd : def;
    },
    of: success,
    equals: function (a, b2) {
        return a.tag === b2.tag;
    },
    unwrap: function (def, f2, fa) {
        return isSuccess(fa) ? f2(fa.data) : def;
    },
    unpack: function (def, f2, fa) {
        return isSuccess(fa) ? f2(fa.data) : def();
    },
    withDefault: function (def, fa) {
        return isSuccess(fa) ? fa.data : def;
    },
    match: function (mapper, fa) {
        return isSuccess(fa) ? mapper.success(fa.data) : isFailure(fa) ? mapper.failure(fa.error) : isLoading(fa) ? mapper.loading() : mapper.notAsked();
    },
    isSuccess,
    isFailure,
    isLoading,
    isNotAsked,
};
function createError(message) {
    var err = new Error(message);
    err.source = "ulid";
    return err;
}
var ENCODING = "0123456789ABCDEFGHJKMNPQRSTVWXYZ";
var ENCODING_LEN = ENCODING.length;
var TIME_MAX = Math.pow(2, 48) - 1;
var TIME_LEN = 10;
var RANDOM_LEN = 16;
function randomChar(prng) {
    var rand = Math.floor(prng() * ENCODING_LEN);
    if (rand === ENCODING_LEN) {
        rand = ENCODING_LEN - 1;
    }
    return ENCODING.charAt(rand);
}
function encodeTime(now, len) {
    if (isNaN(now)) {
        throw new Error(now + " must be a number");
    }
    if (now > TIME_MAX) {
        throw createError("cannot encode time greater than " + TIME_MAX);
    }
    if (now < 0) {
        throw createError("time must be positive");
    }
    if (Number.isInteger(now) === false) {
        throw createError("time must be an integer");
    }
    var mod = void 0;
    var str = "";
    for (; len > 0; len--) {
        mod = now % ENCODING_LEN;
        str = ENCODING.charAt(mod) + str;
        now = (now - mod) / ENCODING_LEN;
    }
    return str;
}
function encodeRandom(len, prng) {
    var str = "";
    for (; len > 0; len--) {
        str = randomChar(prng) + str;
    }
    return str;
}
function detectPrng() {
    var allowInsecure = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    var root2 = arguments[1];
    if (!root2) {
        root2 = typeof window !== "undefined" ? window : null;
    }
    var browserCrypto = root2 && (root2.crypto || root2.msCrypto);
    if (browserCrypto) {
        return function () {
            var buffer = new Uint8Array(1);
            browserCrypto.getRandomValues(buffer);
            return buffer[0] / 255;
        };
    } else {
        try {
            var nodeCrypto = require("crypto");
            return function () {
                return nodeCrypto.randomBytes(1).readUInt8() / 255;
            };
        } catch (e2) {}
    }
    if (allowInsecure) {
        try {
            console.error("secure crypto unusable, falling back to insecure Math.random()!");
        } catch (e2) {}
        return function () {
            return Math.random();
        };
    }
    throw createError("secure crypto unusable, insecure Math.random not allowed");
}
function factory(currPrng) {
    if (!currPrng) {
        currPrng = detectPrng();
    }
    return function ulid2(seedTime) {
        if (isNaN(seedTime)) {
            seedTime = Date.now();
        }
        return encodeTime(seedTime, TIME_LEN) + encodeRandom(RANDOM_LEN, currPrng);
    };
}
var ulid = factory();
const Add = createSvgIcon$1(
    /* @__PURE__ */ jsxRuntimeExports.jsx("path", {
        d: "M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z",
    }),
    "Add"
);
const Remove = createSvgIcon$1(
    /* @__PURE__ */ jsxRuntimeExports.jsx("path", {
        d: "M19 13H5v-2h14v2z",
    }),
    "Remove"
);
const Visibility = createSvgIcon$1(
    /* @__PURE__ */ jsxRuntimeExports.jsx("path", {
        d: "M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z",
    }),
    "Visibility"
);
const VisibilityOff = createSvgIcon$1(
    /* @__PURE__ */ jsxRuntimeExports.jsx("path", {
        d: "M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78 3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z",
    }),
    "VisibilityOff"
);
const identity = (a) => a;
function joinWhenArray(stringOrArray) {
    return Array.isArray(stringOrArray) ? stringOrArray.join(";") : stringOrArray;
}
const style = {
    position: "absolute",
    top: "50%",
    left: "50%",
    transform: "translate(-50%, -50%)",
    width: 900,
    height: "auto",
    bgcolor: "background.paper",
    border: "2px solid #000",
    boxShadow: 24,
    p: 4,
};
const ButtonWithConfirmation = (props) => {
    const [hasBeenClicked, userClickedButton] = reactExports.useState(false);
    return !hasBeenClicked
        ? /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { disabled: props.disabled, color: "secondary", onClick: () => userClickedButton(true), children: props.label })
        : /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { color: "secondary", onClick: props.msg, children: "Confirm?" });
};
var FileSaver_min = { exports: {} };
(function (module, exports) {
    (function (a, b2) {
        b2();
    })(commonjsGlobal, function () {
        function b2(a2, b3) {
            return (
                "undefined" == typeof b3 ? (b3 = { autoBom: false }) : "object" != typeof b3 && (console.warn("Deprecated: Expected third argument to be a object"), (b3 = { autoBom: !b3 })),
                b3.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(a2.type) ? new Blob(["\uFEFF", a2], { type: a2.type }) : a2
            );
        }
        function c2(a2, b3, c3) {
            var d3 = new XMLHttpRequest();
            d3.open("GET", a2),
                (d3.responseType = "blob"),
                (d3.onload = function () {
                    g2(d3.response, b3, c3);
                }),
                (d3.onerror = function () {
                    console.error("could not download file");
                }),
                d3.send();
        }
        function d2(a2) {
            var b3 = new XMLHttpRequest();
            b3.open("HEAD", a2, false);
            try {
                b3.send();
            } catch (a3) {}
            return 200 <= b3.status && 299 >= b3.status;
        }
        function e2(a2) {
            try {
                a2.dispatchEvent(new MouseEvent("click"));
            } catch (c3) {
                var b3 = document.createEvent("MouseEvents");
                b3.initMouseEvent("click", true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null), a2.dispatchEvent(b3);
            }
        }
        var f2 =
                "object" == typeof window && window.window === window
                    ? window
                    : "object" == typeof self && self.self === self
                    ? self
                    : "object" == typeof commonjsGlobal && commonjsGlobal.global === commonjsGlobal
                    ? commonjsGlobal
                    : void 0,
            a = f2.navigator && /Macintosh/.test(navigator.userAgent) && /AppleWebKit/.test(navigator.userAgent) && !/Safari/.test(navigator.userAgent),
            g2 =
                f2.saveAs ||
                ("object" != typeof window || window !== f2
                    ? function () {}
                    : "download" in HTMLAnchorElement.prototype && !a
                    ? function (b3, g3, h2) {
                          var i = f2.URL || f2.webkitURL,
                              j = document.createElement("a");
                          (g3 = g3 || b3.name || "download"),
                              (j.download = g3),
                              (j.rel = "noopener"),
                              "string" == typeof b3
                                  ? ((j.href = b3), j.origin === location.origin ? e2(j) : d2(j.href) ? c2(b3, g3, h2) : e2(j, (j.target = "_blank")))
                                  : ((j.href = i.createObjectURL(b3)),
                                    setTimeout(function () {
                                        i.revokeObjectURL(j.href);
                                    }, 4e4),
                                    setTimeout(function () {
                                        e2(j);
                                    }, 0));
                      }
                    : "msSaveOrOpenBlob" in navigator
                    ? function (f3, g3, h2) {
                          if (((g3 = g3 || f3.name || "download"), "string" != typeof f3)) navigator.msSaveOrOpenBlob(b2(f3, h2), g3);
                          else if (d2(f3)) c2(f3, g3, h2);
                          else {
                              var i = document.createElement("a");
                              (i.href = f3),
                                  (i.target = "_blank"),
                                  setTimeout(function () {
                                      e2(i);
                                  });
                          }
                      }
                    : function (b3, d3, e3, g3) {
                          if (((g3 = g3 || open("", "_blank")), g3 && (g3.document.title = g3.document.body.innerText = "downloading..."), "string" == typeof b3)) return c2(b3, d3, e3);
                          var h2 = "application/octet-stream" === b3.type,
                              i = /constructor/i.test(f2.HTMLElement) || f2.safari,
                              j = /CriOS\/[\d]+/.test(navigator.userAgent);
                          if ((j || (h2 && i) || a) && "undefined" != typeof FileReader) {
                              var k2 = new FileReader();
                              (k2.onloadend = function () {
                                  var a2 = k2.result;
                                  (a2 = j ? a2 : a2.replace(/^data:[^;]*;/, "data:attachment/file;")), g3 ? (g3.location.href = a2) : (location = a2), (g3 = null);
                              }),
                                  k2.readAsDataURL(b3);
                          } else {
                              var l2 = f2.URL || f2.webkitURL,
                                  m2 = l2.createObjectURL(b3);
                              g3 ? (g3.location = m2) : (location.href = m2),
                                  (g3 = null),
                                  setTimeout(function () {
                                      l2.revokeObjectURL(m2);
                                  }, 4e4);
                          }
                      });
        (f2.saveAs = g2.saveAs = g2), (module.exports = g2);
    });
})(FileSaver_min);
var FileSaver_minExports = FileSaver_min.exports;
var __awaiter$1 =
    (globalThis && globalThis.__awaiter) ||
    function (thisArg, _arguments, P, generator) {
        function adopt(value) {
            return value instanceof P
                ? value
                : new P(function (resolve) {
                      resolve(value);
                  });
        }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) {
                try {
                    step(generator.next(value));
                } catch (e2) {
                    reject(e2);
                }
            }
            function rejected(value) {
                try {
                    step(generator["throw"](value));
                } catch (e2) {
                    reject(e2);
                }
            }
            function step(result) {
                result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
const newLine = "\r\n";
const raf = typeof requestAnimationFrame === "function" ? requestAnimationFrame : process.nextTick;
const makeWrapper = (wrapChar) => (str) => `${wrapChar}${str}${wrapChar}`;
const makeResolver = (resolve, newLineAtEnd) => (content) => {
    if (newLineAtEnd) {
        content.push("");
    }
    resolve(content.join(newLine));
};
const identityMapping = (arr, initialMapping) =>
    arr.reduce((acc, k2) => {
        acc[k2] = k2;
        return acc;
    }, initialMapping);
const extractHeaderFromData = (datas) => datas.reduce((acc, v2) => (Array.isArray(v2) ? acc : identityMapping(Object.keys(v2), acc)), {});
const extractHeaderFromColumns = (columns) =>
    columns.reduce((acc, v2) => {
        var _a;
        if (typeof v2 === "string") {
            acc[v2] = v2;
        } else {
            acc[v2.id] = (_a = v2.displayName) !== null && _a !== void 0 ? _a : v2.id;
        }
        return acc;
    }, {});
function toChunks(arr, chunkSize) {
    return [...Array(Math.ceil(arr.length / chunkSize))].reduce((acc, _2, i) => {
        const begin = i * chunkSize;
        return acc.concat([arr.slice(begin, begin + chunkSize)]);
    }, []);
}
const createChunkProcessor = (resolve, wrap, content, datas, columnOrder, separator, chunkSize) => {
    const chunks = toChunks(datas, chunkSize);
    let i = 0;
    return function processChunk() {
        if (i >= chunks.length) {
            resolve(content);
            return;
        }
        const chunk = chunks[i];
        i += 1;
        chunk
            .map((v2) =>
                Array.isArray(v2)
                    ? v2
                    : columnOrder.map((k2) => {
                          var _a;
                          return (_a = v2[k2]) !== null && _a !== void 0 ? _a : "";
                      })
            )
            .forEach((v2) => {
                content.push(v2.map(wrap).join(separator));
            });
        raf(processChunk);
    };
};
function csv({ columns, datas, separator = ",", noHeader = false, wrapColumnChar = "", newLineAtEnd = false, chunkSize = 1e3 }) {
    return __awaiter$1(this, void 0, void 0, function* () {
        return new Promise((_resolve, reject) =>
            __awaiter$1(this, void 0, void 0, function* () {
                const resolve = makeResolver(_resolve, newLineAtEnd);
                const wrap = makeWrapper(wrapColumnChar);
                try {
                    datas = typeof datas === "function" ? yield datas() : yield datas;
                    if (!Array.isArray(datas)) {
                        return _resolve();
                    }
                    const header = columns ? extractHeaderFromColumns(columns) : extractHeaderFromData(datas);
                    const content = [];
                    if (!noHeader) {
                        const headerNames = Object.values(header);
                        if (headerNames.length > 0) {
                            content.push(headerNames.map(wrap).join(separator));
                        }
                    }
                    const columnOrder = Object.keys(header);
                    const processChunk = createChunkProcessor(resolve, wrap, content, datas, columnOrder, separator, chunkSize);
                    raf(processChunk);
                } catch (err) {
                    return reject(err);
                }
            })
        );
    });
}
var __awaiter =
    (globalThis && globalThis.__awaiter) ||
    function (thisArg, _arguments, P, generator) {
        function adopt(value) {
            return value instanceof P
                ? value
                : new P(function (resolve) {
                      resolve(value);
                  });
        }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) {
                try {
                    step(generator.next(value));
                } catch (e2) {
                    reject(e2);
                }
            }
            function rejected(value) {
                try {
                    step(generator["throw"](value));
                } catch (e2) {
                    reject(e2);
                }
            }
            function step(result) {
                result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
var __rest =
    (globalThis && globalThis.__rest) ||
    function (s, e2) {
        var t2 = {};
        for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0) t2[p2] = s[p2];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
                if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i])) t2[p2[i]] = s[p2[i]];
            }
        return t2;
    };
class CsvDownload extends reactExports.Component {
    constructor() {
        super(...arguments);
        this.handleClick = () =>
            __awaiter(this, void 0, void 0, function* () {
                const { suffix, prefix: prefix2, bom, extension, disabled, meta, separator, handleError, handleEmpty } = this.props;
                if (disabled) {
                    return;
                }
                let { filename } = this.props;
                let csv$1;
                try {
                    csv$1 = yield csv(this.props);
                } catch (err) {
                    return handleError === null || handleError === void 0 ? void 0 : handleError(err);
                }
                if (!csv$1) {
                    if (handleEmpty) {
                        return handleEmpty();
                    } else {
                        csv$1 = "";
                    }
                }
                const bomCode = bom !== false ? "\uFEFF" : "";
                const metaContent = meta
                    ? `sep=${separator}\r
`
                    : "";
                const resolvedExtension = extension || ".csv";
                if (filename.indexOf(resolvedExtension) === -1) {
                    filename += resolvedExtension;
                }
                if (suffix) {
                    filename =
                        typeof suffix === "string" || typeof suffix === "number"
                            ? filename.replace(resolvedExtension, `_${suffix}${resolvedExtension}`)
                            : filename.replace(resolvedExtension, `_${/* @__PURE__ */ new Date().getTime()}${resolvedExtension}`);
                }
                if (prefix2) {
                    filename = typeof prefix2 === "string" || typeof prefix2 === "number" ? `${prefix2}_${filename}` : `${/* @__PURE__ */ new Date().getTime()}_${filename}`;
                }
                const blob = new Blob([`${bomCode}${metaContent}${csv$1}`], {
                    type: "text/csv;charset=utf-8",
                });
                FileSaver_minExports.saveAs(blob, filename);
            });
    }
    render() {
        const _a = this.props,
            {
                children,
                text,
                disabled,
                /* eslint-disable @typescript-eslint/no-unused-vars */
                bom,
                filename,
                extension,
                prefix: prefix2,
                suffix,
                meta,
                handleError,
                handleEmpty,
                columns,
                datas,
                separator,
                noHeader,
                wrapColumnChar,
                newLineAtEnd,
                chunkSize,
            } = _a,
            props = __rest(_a, [
                "children",
                "text",
                "disabled",
                "bom",
                "filename",
                "extension",
                "prefix",
                "suffix",
                "meta",
                "handleError",
                "handleEmpty",
                "columns",
                "datas",
                "separator",
                "noHeader",
                "wrapColumnChar",
                "newLineAtEnd",
                "chunkSize",
            ]);
        if (typeof children === "undefined") {
            return reactExports.createElement("button", Object.assign({ type: "button" }, props, { onClick: this.handleClick, disabled }), text ? text : "Download");
        }
        return reactExports.createElement("div", Object.assign({ role: "button", tabIndex: 0 }, props, { onClick: this.handleClick, onKeyPress: this.handleClick }), children);
    }
}
const UsersTable = () => {
    const { model, updateModel } = useModel();
    const [filteringChars, setFilteringChars] = reactExports.useState("");
    const [orderBy, setOrderBy] = reactExports.useState("login");
    const [order2, setOrder] = reactExports.useState("asc");
    function handleRequestSort(property) {
        const isAsc = orderBy === property && order2 === "asc";
        setOrder(isAsc ? "desc" : "asc");
        setOrderBy(property);
    }
    const renderUsers = SRD.match(
        {
            notAsked: () => /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Let's fetch some data!" }),
            loading: () =>
                /* @__PURE__ */ jsxRuntimeExports.jsx(Box$1, { sx: { display: "flex", justifyContent: "center", p: 4 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress$1, {}) }),
            failure: (msg) =>
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Box$1, {
                    sx: { display: "flex", justifyContent: "center", p: 4 },
                    children: [",", /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: `I stumbled into this error when I tried to fetch data: ${msg}. Please, reload this page.` })],
                }),
            success: (gotUsers) => {
                const sortedUsers = gotUsers.slice().sort((a, b2) => {
                    const left2 = a[orderBy];
                    const right2 = b2[orderBy];
                    return order2 === "asc" ? left2.localeCompare(right2) : right2.localeCompare(left2);
                });
                const datas = gotUsers.map((user) => {
                    const { groups, _type, password, ...restOfProperties } = user;
                    const data = {
                        ...restOfProperties,
                        groups: groups.join(";"),
                    };
                    return data;
                });
                return /* @__PURE__ */ jsxRuntimeExports.jsx(Box$1, {
                    sx: { display: "flex", justifyContent: "center", p: 4 },
                    children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack$1, {
                        spacing: 2,
                        children: [
                            /* @__PURE__ */ jsxRuntimeExports.jsx(CsvDownload, { separator: "	", filename: "users", extension: ".tsv", datas }),
                            /* @__PURE__ */ jsxRuntimeExports.jsx(Autocomplete$1, {
                                disablePortal: true,
                                id: "search-users",
                                options: gotUsers.map((user) => user.login),
                                sx: { width: 300 },
                                onInputChange: (event, newInputValue) => {
                                    setFilteringChars(newInputValue);
                                },
                                renderInput: (params) => /* @__PURE__ */ jsxRuntimeExports.jsx(TextField$1, { ...params, label: "Search Users by login" }),
                            }),
                            /* @__PURE__ */ jsxRuntimeExports.jsx(Box$1, {
                                id: "table-container",
                                sx: { justifyContent: "center", display: "flex", width: "600" },
                                children: /* @__PURE__ */ jsxRuntimeExports.jsx(TableContainer$1, {
                                    sx: { maxHeight: "400px" },
                                    component: Paper$1,
                                    children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Table$1, {
                                        sx: { width: "100%" },
                                        children: [
                                            /* @__PURE__ */ jsxRuntimeExports.jsx(TableHead$1, {
                                                children: /* @__PURE__ */ jsxRuntimeExports.jsxs(TableRow$1, {
                                                    style: { fontWeight: "bold" },
                                                    children: [
                                                        /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell$1, { style: { fontWeight: "bold" }, children: "Source" }),
                                                        /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell$1, {
                                                            style: { fontWeight: "bold" },
                                                            children: /* @__PURE__ */ jsxRuntimeExports.jsx(TableSortLabel$1, {
                                                                active: orderBy === "login",
                                                                direction: order2,
                                                                onClick: () => handleRequestSort("login"),
                                                                children: "Name",
                                                            }),
                                                        }),
                                                        /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell$1, { style: { fontWeight: "bold" }, children: "groups" }),
                                                        /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell$1, { style: { fontWeight: "bold" }, children: "Actions" }),
                                                    ],
                                                }),
                                            }),
                                            /* @__PURE__ */ jsxRuntimeExports.jsx(TableBody$1, {
                                                sx: { width: "100%", overflow: "visible" },
                                                children: sortedUsers
                                                    .filter((user) => user.login.includes(filteringChars))
                                                    .map((user) => {
                                                        return /* @__PURE__ */ jsxRuntimeExports.jsxs(
                                                            TableRow$1,
                                                            {
                                                                children: [
                                                                    /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell$1, { children: user.source }),
                                                                    /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell$1, { children: user.login }),
                                                                    /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell$1, { children: user.groups.join(", ") }),
                                                                    /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell$1, {
                                                                        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box$1, {
                                                                            sx: { display: "flex" },
                                                                            children: [
                                                                                /* @__PURE__ */ jsxRuntimeExports.jsx(UserForm, { id: `edit-button-${user.id}`, maybeuser: user }),
                                                                                /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonWithConfirmation, {
                                                                                    label: "Delete",
                                                                                    msg: () => deleteUser(user, updateModel),
                                                                                }),
                                                                                " ",
                                                                            ],
                                                                        }),
                                                                    }),
                                                                ],
                                                            },
                                                            user.id
                                                        );
                                                    }),
                                            }),
                                        ],
                                    }),
                                }),
                            }),
                            /* @__PURE__ */ jsxRuntimeExports.jsx(Box$1, {
                                sx: { display: "flex", justifyContent: "center", p: 4 },
                                children: /* @__PURE__ */ jsxRuntimeExports.jsx(UserForm, { id: `create-button`, create: true }),
                            }),
                        ],
                    }),
                });
            },
        },
        model.users
    );
    return renderUsers;
};
var Type$2 = /* @__PURE__ */ ((Type2) => {
    Type2[(Type2["UserClickedModal"] = 0)] = "UserClickedModal";
    Type2[(Type2["UserUpdatedField"] = 1)] = "UserUpdatedField";
    Type2[(Type2["ResetUser"] = 2)] = "ResetUser";
    return Type2;
})(Type$2 || {});
var Mode$2 = /* @__PURE__ */ ((Mode2) => {
    Mode2[(Mode2["Creation"] = 0)] = "Creation";
    Mode2[(Mode2["Edition"] = 1)] = "Edition";
    return Mode2;
})(Mode$2 || {});
const updateUser = (userEditionState, msg) => {
    const { model } = useModel();
    const unwrappedUsers = SRD.unwrap([], identity, model.users);
    const getUnmodifiedUsers = unwrappedUsers.reduce((acc, value) => (userEditionState.userForm.id === value.id ? value : acc), newUser(ulid()));
    const resetSourceForm = msg.payload ? userEditionState.userForm : getUnmodifiedUsers;
    const fieldToUpdate = msg.type === 1 ? msg.payload.fieldname : null;
    switch (msg.type) {
        case 0:
            return { ...userEditionState, modal: msg.payload };
        case 1:
            return { ...userEditionState, userForm: { ...userEditionState.userForm, [fieldToUpdate]: msg.payload.newValue } };
        case 2:
            switch (msg.payload) {
                case 0:
                    return { ...userEditionState, userForm: newUser(ulid()) };
                case 1:
                    return { ...userEditionState, userForm: msg.payload ? userEditionState.userForm : resetSourceForm };
            }
    }
};
const UserForm = ({ maybeuser: maybeUser, create = false, id }) => {
    const user = maybeUser ? maybeUser : newUser(ulid());
    const { model, updateModel } = useModel();
    const unwrappedProfiles = SRD.unwrap([], identity, model.profiles);
    const [userModel, update2] = reactExports.useReducer(updateUser, { modal: false, userForm: user });
    const [displayPassword, setDisplayPassword] = reactExports.useState(false);
    const handleClickShowPassword = () => {
        setDisplayPassword(!displayPassword);
    };
    const handleMouseDownPassword = (event) => {
        event.preventDefault();
    };
    const handleOpen = () => update2({ type: 0, payload: true });
    const handleClose = () => update2({ type: 0, payload: false });
    const handleFieldUpdate = (fieldname) => (event) => update2({ type: 1, payload: { fieldname, newValue: event.target.value } });
    const saveSources = () => {
        if (create) {
            void saveUserBis(userModel.userForm, 0, updateModel, update2);
        } else {
            void saveUserBis(userModel.userForm, 1, updateModel, update2);
        }
    };
    const config = SRD.unwrap({ auth: "json", tools_available: [] }, identity, model.config);
    const createEditButton = /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { id, color: "primary", variant: "contained", onClick: handleOpen, children: create ? "Create User" : "Edit" });
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
        children: [
            create ? (config.auth != "keycloak" ? createEditButton : null) : createEditButton,
            /* @__PURE__ */ jsxRuntimeExports.jsx(Modal$1, {
                onClose: handleClose,
                open: userModel.modal,
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(Box$1, {
                    sx: style,
                    children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack$1, {
                        spacing: 4,
                        children: [
                            /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: `Edit ${user.login}` }),
                            /* @__PURE__ */ jsxRuntimeExports.jsxs(FormControl$1, {
                                children: [
                                    /* @__PURE__ */ jsxRuntimeExports.jsx(InputLabel$1, { id: "login-label", children: "Login" }),
                                    /* @__PURE__ */ jsxRuntimeExports.jsx(OutlinedInput$1, {
                                        fullWidth: true,
                                        onChange: handleFieldUpdate("login"),
                                        value: userModel.userForm.login,
                                        id: `login`,
                                        label: "Login",
                                        disabled: create ? false : true,
                                    }),
                                ],
                            }),
                            /* @__PURE__ */ jsxRuntimeExports.jsxs(FormControl$1, {
                                children: [
                                    /* @__PURE__ */ jsxRuntimeExports.jsx(InputLabel$1, { id: "password-label", children: "Password" }),
                                    /* @__PURE__ */ jsxRuntimeExports.jsx(OutlinedInput$1, {
                                        fullWidth: true,
                                        onChange: handleFieldUpdate("password"),
                                        value: userModel.userForm.password,
                                        type: displayPassword ? "text" : "password",
                                        id: `password`,
                                        label: "Password",
                                        disabled: user.source != "keycloak" ? false : true,
                                        endAdornment: /* @__PURE__ */ jsxRuntimeExports.jsx(InputAdornment$1, {
                                            position: "end",
                                            children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton$1, {
                                                "aria-label": "toggle password visibility",
                                                onClick: handleClickShowPassword,
                                                onMouseDown: handleMouseDownPassword,
                                                edge: "end",
                                                children: displayPassword ? /* @__PURE__ */ jsxRuntimeExports.jsx(VisibilityOff, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(Visibility, {}),
                                            }),
                                        }),
                                    }),
                                ],
                            }),
                            /* @__PURE__ */ jsxRuntimeExports.jsxs(FormControl$1, {
                                children: [
                                    /* @__PURE__ */ jsxRuntimeExports.jsx(InputLabel$1, { id: "select-groups-label", children: "Groups" }),
                                    /* @__PURE__ */ jsxRuntimeExports.jsx(Select$1, {
                                        labelId: "select-groups-label",
                                        id: "select-groups",
                                        multiple: true,
                                        value: userModel.userForm.groups,
                                        label: "select-groups-label",
                                        fullWidth: true,
                                        renderValue: (selected) => (typeof selected === "string" ? selected : selected.join(", ")),
                                        onChange: handleFieldUpdate("groups"),
                                        children: unwrappedProfiles.map((profile) =>
                                            /* @__PURE__ */ jsxRuntimeExports.jsxs(
                                                MenuItem$1,
                                                {
                                                    value: profile.name,
                                                    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(Checkbox$1, { checked: userModel.userForm.groups.indexOf(profile.name) > -1 }), profile.name],
                                                },
                                                profile.name
                                            )
                                        ),
                                    }),
                                ],
                            }),
                            /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { id: "btn-save-user", color: "primary", variant: "contained", onClick: saveSources, children: "Save User" }),
                        ],
                    }),
                }),
            }),
        ],
    });
};
const endpoint$3 = "/api/v1/users";
async function getUsers() {
    const response = await fetch(endpoint$3);
    const { resources } = await response.json();
    return mapUsers(resources);
}
function mapUsers(resources) {
    const users = Object.entries(resources);
    const mapped_users = users
        .map(([, val]) => decodeUser(val))
        .sort((user1, user2) => {
            const name1 = user1.login.toUpperCase();
            const name2 = user2.login.toUpperCase();
            if (name1 < name2) {
                return -1;
            }
            if (name1 > name2) {
                return 1;
            }
            return 0;
        });
    return mapped_users;
}
async function saveUserBis(body, mode, updateModel, updateLocal) {
    try {
        const response = await fetch(endpoint$3, {
            method: mode === Mode$2.Edition ? "put" : "post",
            body: JSON.stringify({ [body.id]: body }, null, "	"),
            headers: { "Content-Type": "application/json" },
        });
        const { message, resources } = await response.json();
        if (response.status === 200) {
            updateModel({ type: "ServerRespondedWithUsers", payload: success(mapUsers(resources)) });
            updateLocal({ type: Type$2.UserClickedModal, payload: false });
            updateLocal({ type: Type$2.ResetUser, payload: mode });
        } else {
            updateModel({ type: "ServerRespondedWithUsers", payload: failure(`${response.status}, ${message}`) });
        }
    } catch (e2) {
        updateModel({ type: "ServerRespondedWithUsers", payload: failure(e2) });
    }
}
async function deleteUser(user, updateModel) {
    try {
        const response = await fetch(`${endpoint$3}/${user.login}`, { method: "delete" });
        const { message, resources } = await response.json();
        if (response.status === 200) {
            updateModel({ type: "ServerRespondedWithUsers", payload: success(mapUsers(resources)) });
        } else {
            updateModel({ type: "ServerRespondedWithUsers", payload: failure(`${response.status}, ${message}`) });
        }
    } catch (e2) {
        updateModel({ type: "ServerRespondedWithUsers", payload: failure(e2) });
    }
}
const decodeUser = (user) => {
    return {
        id: user.id ? user.id : ulid(),
        login: user.login,
        password: user.password,
        groups: user.groups,
        source: user.source ? user.source : "json",
        _type: "user",
    };
};
const newUser = (key) => {
    return { id: key, _type: "user", login: "", password: "", groups: [], source: "json" };
};
function r(e2) {
    var t2,
        f2,
        n2 = "";
    if ("string" == typeof e2 || "number" == typeof e2) n2 += e2;
    else if ("object" == typeof e2)
        if (Array.isArray(e2)) for (t2 = 0; t2 < e2.length; t2++) e2[t2] && (f2 = r(e2[t2])) && (n2 && (n2 += " "), (n2 += f2));
        else for (t2 in e2) e2[t2] && (n2 && (n2 += " "), (n2 += t2));
    return n2;
}
function clsx() {
    for (var e2, t2, f2 = 0, n2 = ""; f2 < arguments.length; ) (e2 = arguments[f2++]) && (t2 = r(e2)) && (n2 && (n2 += " "), (n2 += t2));
    return n2;
}
var interopRequireDefault = { exports: {} };
(function (module) {
    function _interopRequireDefault2(obj) {
        return obj && obj.__esModule
            ? obj
            : {
                  default: obj,
              };
    }
    (module.exports = _interopRequireDefault2), (module.exports.__esModule = true), (module.exports["default"] = module.exports);
})(interopRequireDefault);
var interopRequireDefaultExports = interopRequireDefault.exports;
const TreeViewContext = /* @__PURE__ */ reactExports.createContext({
    registerNode: () => {},
    unregisterNode: () => {},
    isFocused: () => false,
    isSelected: () => false,
    isExpanded: () => false,
    isExpandable: () => false,
    isDisabled: () => false,
    mapFirstChar: () => {},
    unMapFirstChar: () => {},
    focus: () => {},
    toggleExpansion: () => {},
    selectNode: () => {},
    selectRange: () => {},
    multiSelect: false,
    disabledItemsFocusable: false,
    treeId: void 0,
    icons: {
        defaultCollapseIcon: null,
        defaultExpandIcon: null,
        defaultParentIcon: null,
        defaultEndIcon: null,
    },
});
const _excluded$3 = ["element"];
function findIndex(array, comp) {
    for (let i = 0; i < array.length; i += 1) {
        if (comp(array[i])) {
            return i;
        }
    }
    return -1;
}
function binaryFindElement(array, element) {
    let start2 = 0;
    let end2 = array.length - 1;
    while (start2 <= end2) {
        const middle = Math.floor((start2 + end2) / 2);
        if (array[middle].element === element) {
            return middle;
        }
        if (array[middle].element.compareDocumentPosition(element) & Node.DOCUMENT_POSITION_PRECEDING) {
            end2 = middle - 1;
        } else {
            start2 = middle + 1;
        }
    }
    return start2;
}
const DescendantContext = /* @__PURE__ */ reactExports.createContext({});
function usePrevious(value) {
    const ref = reactExports.useRef(null);
    reactExports.useEffect(() => {
        ref.current = value;
    }, [value]);
    return ref.current;
}
const noop = () => {};
function useDescendant(descendant) {
    const [, forceUpdate] = reactExports.useState();
    const { registerDescendant = noop, unregisterDescendant = noop, descendants = [], parentId = null } = reactExports.useContext(DescendantContext);
    const index = findIndex(descendants, (item) => item.element === descendant.element);
    const previousDescendants = usePrevious(descendants);
    const someDescendantsHaveChanged = descendants.some((newDescendant, position2) => {
        return previousDescendants && previousDescendants[position2] && previousDescendants[position2].element !== newDescendant.element;
    });
    useEnhancedEffect$1(() => {
        if (descendant.element) {
            registerDescendant(
                _extends({}, descendant, {
                    index,
                })
            );
            return () => {
                unregisterDescendant(descendant.element);
            };
        }
        forceUpdate({});
        return void 0;
    }, [registerDescendant, unregisterDescendant, index, someDescendantsHaveChanged, descendant]);
    return {
        parentId,
        index,
    };
}
function DescendantProvider(props) {
    const { children, id } = props;
    const [items, set] = reactExports.useState([]);
    const registerDescendant = reactExports.useCallback((_ref) => {
        let { element } = _ref,
            other = _objectWithoutPropertiesLoose(_ref, _excluded$3);
        set((oldItems) => {
            if (oldItems.length === 0) {
                return [
                    _extends({}, other, {
                        element,
                        index: 0,
                    }),
                ];
            }
            const index = binaryFindElement(oldItems, element);
            let newItems;
            if (oldItems[index] && oldItems[index].element === element) {
                newItems = oldItems;
            } else {
                const newItem = _extends({}, other, {
                    element,
                    index,
                });
                newItems = oldItems.slice();
                newItems.splice(index, 0, newItem);
            }
            newItems.forEach((item, position2) => {
                item.index = position2;
            });
            return newItems;
        });
    }, []);
    const unregisterDescendant = reactExports.useCallback((element) => {
        set((oldItems) => oldItems.filter((item) => element !== item.element));
    }, []);
    const value = reactExports.useMemo(
        () => ({
            descendants: items,
            registerDescendant,
            unregisterDescendant,
            parentId: id,
        }),
        [items, registerDescendant, unregisterDescendant, id]
    );
    return /* @__PURE__ */ jsxRuntimeExports.jsx(DescendantContext.Provider, {
        value,
        children,
    });
}
function useTreeItem(nodeId) {
    const { focus, isExpanded, isExpandable, isFocused, isDisabled, isSelected, multiSelect, selectNode, selectRange, toggleExpansion } = reactExports.useContext(TreeViewContext);
    const expandable = isExpandable ? isExpandable(nodeId) : false;
    const expanded = isExpanded ? isExpanded(nodeId) : false;
    const focused = isFocused ? isFocused(nodeId) : false;
    const disabled = isDisabled ? isDisabled(nodeId) : false;
    const selected = isSelected ? isSelected(nodeId) : false;
    const handleExpansion = (event) => {
        if (!disabled) {
            if (!focused) {
                focus(event, nodeId);
            }
            const multiple = multiSelect && (event.shiftKey || event.ctrlKey || event.metaKey);
            if (expandable && !(multiple && isExpanded(nodeId))) {
                toggleExpansion(event, nodeId);
            }
        }
    };
    const handleSelection = (event) => {
        if (!disabled) {
            if (!focused) {
                focus(event, nodeId);
            }
            const multiple = multiSelect && (event.shiftKey || event.ctrlKey || event.metaKey);
            if (multiple) {
                if (event.shiftKey) {
                    selectRange(event, {
                        end: nodeId,
                    });
                } else {
                    selectNode(event, nodeId, true);
                }
            } else {
                selectNode(event, nodeId);
            }
        }
    };
    const preventSelection = (event) => {
        if (event.shiftKey || event.ctrlKey || event.metaKey || disabled) {
            event.preventDefault();
        }
    };
    return {
        disabled,
        expanded,
        selected,
        focused,
        handleExpansion,
        handleSelection,
        preventSelection,
    };
}
const _excluded$2 = ["classes", "className", "displayIcon", "expansionIcon", "icon", "label", "nodeId", "onClick", "onMouseDown"];
const TreeItemContent = /* @__PURE__ */ reactExports.forwardRef(function TreeItemContent2(props, ref) {
    const { classes, className, displayIcon, expansionIcon, icon: iconProp, label, nodeId, onClick, onMouseDown } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded$2);
    const { disabled, expanded, selected, focused, handleExpansion, handleSelection, preventSelection } = useTreeItem(nodeId);
    const icon = iconProp || expansionIcon || displayIcon;
    const handleMouseDown = (event) => {
        preventSelection(event);
        if (onMouseDown) {
            onMouseDown(event);
        }
    };
    const handleClick = (event) => {
        handleExpansion(event);
        handleSelection(event);
        if (onClick) {
            onClick(event);
        }
    };
    return (
        /* eslint-disable-next-line jsx-a11y/click-events-have-key-events,jsx-a11y/no-static-element-interactions -- Key event is handled by the TreeView */
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            _extends({}, other, {
                className: clsx(className, classes.root, expanded && classes.expanded, selected && classes.selected, focused && classes.focused, disabled && classes.disabled),
                onClick: handleClick,
                onMouseDown: handleMouseDown,
                ref,
                children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
                        className: classes.iconContainer,
                        children: icon,
                    }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
                        className: classes.label,
                        children: label,
                    }),
                ],
            })
        )
    );
});
function getTreeItemUtilityClass(slot) {
    return generateUtilityClass("MuiTreeItem", slot);
}
const treeItemClasses = generateUtilityClasses("MuiTreeItem", ["root", "group", "content", "expanded", "selected", "focused", "disabled", "iconContainer", "label"]);
const _excluded$1 = [
    "children",
    "className",
    "collapseIcon",
    "ContentComponent",
    "ContentProps",
    "endIcon",
    "expandIcon",
    "disabled",
    "icon",
    "id",
    "label",
    "nodeId",
    "onClick",
    "onMouseDown",
    "TransitionComponent",
    "TransitionProps",
];
const useUtilityClasses$1 = (ownerState) => {
    const { classes } = ownerState;
    const slots = {
        root: ["root"],
        content: ["content"],
        expanded: ["expanded"],
        selected: ["selected"],
        focused: ["focused"],
        disabled: ["disabled"],
        iconContainer: ["iconContainer"],
        label: ["label"],
        group: ["group"],
    };
    return composeClasses(slots, getTreeItemUtilityClass, classes);
};
const TreeItemRoot = styled$1("li", {
    name: "MuiTreeItem",
    slot: "Root",
    overridesResolver: (props, styles2) => styles2.root,
})({
    listStyle: "none",
    margin: 0,
    padding: 0,
    outline: 0,
});
const StyledTreeItemContent = styled$1(TreeItemContent, {
    name: "MuiTreeItem",
    slot: "Content",
    overridesResolver: (props, styles2) => {
        return [
            styles2.content,
            styles2.iconContainer && {
                [`& .${treeItemClasses.iconContainer}`]: styles2.iconContainer,
            },
            styles2.label && {
                [`& .${treeItemClasses.label}`]: styles2.label,
            },
        ];
    },
})(({ theme }) => ({
    padding: "0 8px",
    width: "100%",
    display: "flex",
    alignItems: "center",
    cursor: "pointer",
    WebkitTapHighlightColor: "transparent",
    "&:hover": {
        backgroundColor: (theme.vars || theme).palette.action.hover,
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
            backgroundColor: "transparent",
        },
    },
    [`&.${treeItemClasses.disabled}`]: {
        opacity: (theme.vars || theme).palette.action.disabledOpacity,
        backgroundColor: "transparent",
    },
    [`&.${treeItemClasses.focused}`]: {
        backgroundColor: (theme.vars || theme).palette.action.focus,
    },
    [`&.${treeItemClasses.selected}`]: {
        backgroundColor: theme.vars
            ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.selectedOpacity})`
            : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity),
        "&:hover": {
            backgroundColor: theme.vars
                ? `rgba(${theme.vars.palette.primary.mainChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.hoverOpacity}))`
                : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity + theme.palette.action.hoverOpacity),
            // Reset on touch devices, it doesn't add specificity
            "@media (hover: none)": {
                backgroundColor: theme.vars
                    ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.selectedOpacity})`
                    : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity),
            },
        },
        [`&.${treeItemClasses.focused}`]: {
            backgroundColor: theme.vars
                ? `rgba(${theme.vars.palette.primary.mainChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.focusOpacity}))`
                : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity + theme.palette.action.focusOpacity),
        },
    },
    [`& .${treeItemClasses.iconContainer}`]: {
        marginRight: 4,
        width: 15,
        display: "flex",
        flexShrink: 0,
        justifyContent: "center",
        "& svg": {
            fontSize: 18,
        },
    },
    [`& .${treeItemClasses.label}`]: _extends(
        {
            width: "100%",
            // fixes overflow - see https://github.com/mui/material-ui/issues/27372
            minWidth: 0,
            paddingLeft: 4,
            position: "relative",
        },
        theme.typography.body1
    ),
}));
const TreeItemGroup = styled$1(Collapse$1, {
    name: "MuiTreeItem",
    slot: "Group",
    overridesResolver: (props, styles2) => styles2.group,
})({
    margin: 0,
    padding: 0,
    marginLeft: 17,
});
const TreeItem$2 = /* @__PURE__ */ reactExports.forwardRef(function TreeItem(inProps, ref) {
    const props = useThemeProps({
        props: inProps,
        name: "MuiTreeItem",
    });
    const {
            children,
            className,
            collapseIcon,
            ContentComponent = TreeItemContent,
            ContentProps,
            endIcon,
            expandIcon,
            disabled: disabledProp,
            icon,
            id: idProp,
            label,
            nodeId,
            onClick,
            onMouseDown,
            TransitionComponent = Collapse$1,
            TransitionProps,
        } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded$1);
    const {
        icons: contextIcons,
        focus,
        isExpanded,
        isFocused,
        isSelected,
        isDisabled,
        multiSelect,
        disabledItemsFocusable,
        mapFirstChar,
        unMapFirstChar,
        registerNode,
        unregisterNode,
        treeId,
    } = reactExports.useContext(TreeViewContext);
    let id;
    if (idProp != null) {
        id = idProp;
    } else if (treeId && nodeId) {
        id = `${treeId}-${nodeId}`;
    }
    const [treeItemElement, setTreeItemElement] = reactExports.useState(null);
    const contentRef = reactExports.useRef(null);
    const handleRef = useForkRef(setTreeItemElement, ref);
    const descendant = reactExports.useMemo(
        () => ({
            element: treeItemElement,
            id: nodeId,
        }),
        [nodeId, treeItemElement]
    );
    const { index, parentId } = useDescendant(descendant);
    const expandable = Boolean(Array.isArray(children) ? children.length : children);
    const expanded = isExpanded ? isExpanded(nodeId) : false;
    const focused = isFocused ? isFocused(nodeId) : false;
    const selected = isSelected ? isSelected(nodeId) : false;
    const disabled = isDisabled ? isDisabled(nodeId) : false;
    const ownerState = _extends({}, props, {
        expanded,
        focused,
        selected,
        disabled,
    });
    const classes = useUtilityClasses$1(ownerState);
    let displayIcon;
    let expansionIcon;
    if (expandable) {
        if (!expanded) {
            expansionIcon = expandIcon || contextIcons.defaultExpandIcon;
        } else {
            expansionIcon = collapseIcon || contextIcons.defaultCollapseIcon;
        }
    }
    if (expandable) {
        displayIcon = contextIcons.defaultParentIcon;
    } else {
        displayIcon = endIcon || contextIcons.defaultEndIcon;
    }
    reactExports.useEffect(() => {
        if (registerNode && unregisterNode && index !== -1) {
            registerNode({
                id: nodeId,
                idAttribute: id,
                index,
                parentId,
                expandable,
                disabled: disabledProp,
            });
            return () => {
                unregisterNode(nodeId);
            };
        }
        return void 0;
    }, [registerNode, unregisterNode, parentId, index, nodeId, expandable, disabledProp, id]);
    reactExports.useEffect(() => {
        if (mapFirstChar && unMapFirstChar && label) {
            var _contentRef$current$t, _contentRef$current;
            mapFirstChar(
                nodeId,
                ((_contentRef$current$t = (_contentRef$current = contentRef.current) == null ? void 0 : _contentRef$current.textContent) != null ? _contentRef$current$t : "")
                    .substring(0, 1)
                    .toLowerCase()
            );
            return () => {
                unMapFirstChar(nodeId);
            };
        }
        return void 0;
    }, [mapFirstChar, unMapFirstChar, nodeId, label]);
    let ariaSelected;
    if (multiSelect) {
        ariaSelected = selected;
    } else if (selected) {
        ariaSelected = true;
    }
    function handleFocus(event) {
        if (event.target === event.currentTarget) {
            let rootElement;
            if (typeof event.target.getRootNode === "function") {
                rootElement = event.target.getRootNode();
            } else {
                rootElement = ownerDocument(event.target);
            }
            rootElement.getElementById(treeId).focus({
                preventScroll: true,
            });
        }
        const unfocusable = !disabledItemsFocusable && disabled;
        if (!focused && event.currentTarget === event.target && !unfocusable) {
            focus(event, nodeId);
        }
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        TreeItemRoot,
        _extends(
            {
                className: clsx(classes.root, className),
                role: "treeitem",
                "aria-expanded": expandable ? expanded : void 0,
                "aria-selected": ariaSelected,
                "aria-disabled": disabled || void 0,
                id,
                tabIndex: -1,
            },
            other,
            {
                ownerState,
                onFocus: handleFocus,
                ref: handleRef,
                children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                        StyledTreeItemContent,
                        _extends(
                            {
                                as: ContentComponent,
                                ref: contentRef,
                                classes: {
                                    root: classes.content,
                                    expanded: classes.expanded,
                                    selected: classes.selected,
                                    focused: classes.focused,
                                    disabled: classes.disabled,
                                    iconContainer: classes.iconContainer,
                                    label: classes.label,
                                },
                                label,
                                nodeId,
                                onClick,
                                onMouseDown,
                                icon,
                                expansionIcon,
                                displayIcon,
                                ownerState,
                            },
                            ContentProps
                        )
                    ),
                    children &&
                        /* @__PURE__ */ jsxRuntimeExports.jsx(DescendantProvider, {
                            id: nodeId,
                            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                                TreeItemGroup,
                                _extends(
                                    {
                                        as: TransitionComponent,
                                        unmountOnExit: true,
                                        className: classes.group,
                                        in: expanded,
                                        component: "ul",
                                        role: "group",
                                    },
                                    TransitionProps,
                                    {
                                        children,
                                    }
                                )
                            ),
                        }),
                ],
            }
        )
    );
});
let warnedOnce$1 = false;
const warn$1 = () => {
    if (!warnedOnce$1) {
        console.warn(
            [
                "MUI: The TreeItem component was moved from `@mui/lab` to `@mui/x-tree-view`.",
                "The component will no longer be exported from `@mui/lab` in the first release of October 2023.",
                "",
                "You should use `import { TreeItem } from '@mui/x-tree-view'`",
                "or `import { TreeItem } from '@mui/x-tree-view/TreeItem'`",
                "",
                "More information about this migration on our blog: https://mui.com/blog/lab-tree-view-to-mui-x/.",
            ].join("\n")
        );
        warnedOnce$1 = true;
    }
};
const TreeItem2 = /* @__PURE__ */ reactExports.forwardRef(function DeprecatedTreeItem(props, ref) {
    warn$1();
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
        TreeItem$2,
        _extends({}, props, {
            ref,
        })
    );
});
const TreeItem$1 = TreeItem2;
function getTreeViewUtilityClass(slot) {
    return generateUtilityClass("MuiTreeView", slot);
}
generateUtilityClasses("MuiTreeView", ["root"]);
const _excluded = [
    "children",
    "className",
    "defaultCollapseIcon",
    "defaultEndIcon",
    "defaultExpanded",
    "defaultExpandIcon",
    "defaultParentIcon",
    "defaultSelected",
    "disabledItemsFocusable",
    "disableSelection",
    "expanded",
    "id",
    "multiSelect",
    "onBlur",
    "onFocus",
    "onKeyDown",
    "onNodeFocus",
    "onNodeSelect",
    "onNodeToggle",
    "selected",
];
const useUtilityClasses = (ownerState) => {
    const { classes } = ownerState;
    const slots = {
        root: ["root"],
    };
    return composeClasses(slots, getTreeViewUtilityClass, classes);
};
const TreeViewRoot = styled$1("ul", {
    name: "MuiTreeView",
    slot: "Root",
    overridesResolver: (props, styles2) => styles2.root,
})({
    padding: 0,
    margin: 0,
    listStyle: "none",
    outline: 0,
});
function isPrintableCharacter(string) {
    return string && string.length === 1 && string.match(/\S/);
}
function findNextFirstChar(firstChars, startIndex, char2) {
    for (let i = startIndex; i < firstChars.length; i += 1) {
        if (char2 === firstChars[i]) {
            return i;
        }
    }
    return -1;
}
function noopSelection() {
    return false;
}
const defaultDefaultExpanded = [];
const defaultDefaultSelected = [];
const TreeView$2 = /* @__PURE__ */ reactExports.forwardRef(function TreeView(inProps, ref) {
    var _themeProps$disabledI, _themeProps$disableSe, _themeProps$multiSele, _themeProps$defaultEx, _themeProps$defaultSe;
    const themeProps = useThemeProps({
        props: inProps,
        name: "MuiTreeView",
    });
    const props = _extends({}, themeProps, {
        disabledItemsFocusable: (_themeProps$disabledI = themeProps.disabledItemsFocusable) != null ? _themeProps$disabledI : false,
        disableSelection: (_themeProps$disableSe = themeProps.disableSelection) != null ? _themeProps$disableSe : false,
        multiSelect: (_themeProps$multiSele = themeProps.multiSelect) != null ? _themeProps$multiSele : false,
        defaultExpanded: (_themeProps$defaultEx = themeProps.defaultExpanded) != null ? _themeProps$defaultEx : defaultDefaultExpanded,
        defaultSelected: (_themeProps$defaultSe = themeProps.defaultSelected) != null ? _themeProps$defaultSe : defaultDefaultSelected,
    });
    const {
            children,
            className,
            defaultCollapseIcon,
            defaultEndIcon,
            defaultExpanded,
            defaultExpandIcon,
            defaultParentIcon,
            defaultSelected,
            disabledItemsFocusable,
            disableSelection,
            expanded: expandedProp,
            id: idProp,
            multiSelect,
            onBlur,
            onFocus,
            onKeyDown,
            onNodeFocus,
            onNodeSelect,
            onNodeToggle,
            selected: selectedProp,
        } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded);
    const theme = useTheme();
    const isRtl = theme.direction === "rtl";
    const classes = useUtilityClasses(props);
    const treeId = useId(idProp);
    const treeRef = reactExports.useRef(null);
    const handleRef = useForkRef(treeRef, ref);
    const [focusedNodeId, setFocusedNodeId] = reactExports.useState(null);
    const nodeMap = reactExports.useRef({});
    const firstCharMap = reactExports.useRef({});
    const [expanded, setExpandedState] = useControlled({
        controlled: expandedProp,
        default: defaultExpanded,
        name: "TreeView",
        state: "expanded",
    });
    const [selected, setSelectedState] = useControlled({
        controlled: selectedProp,
        default: defaultSelected,
        name: "TreeView",
        state: "selected",
    });
    const isExpanded = reactExports.useCallback((nodeId) => (Array.isArray(expanded) ? expanded.indexOf(nodeId) !== -1 : false), [expanded]);
    const isExpandable = reactExports.useCallback((nodeId) => nodeMap.current[nodeId] && nodeMap.current[nodeId].expandable, []);
    const isSelected = reactExports.useCallback((nodeId) => (Array.isArray(selected) ? selected.indexOf(nodeId) !== -1 : selected === nodeId), [selected]);
    const isDisabled = reactExports.useCallback((nodeId) => {
        if (nodeId == null) {
            return false;
        }
        let node2 = nodeMap.current[nodeId];
        if (!node2) {
            return false;
        }
        if (node2.disabled) {
            return true;
        }
        while (node2.parentId != null) {
            node2 = nodeMap.current[node2.parentId];
            if (node2.disabled) {
                return true;
            }
        }
        return false;
    }, []);
    const isFocused = (nodeId) => focusedNodeId === nodeId;
    const getChildrenIds = (nodeId) =>
        Object.keys(nodeMap.current)
            .map((key) => {
                return nodeMap.current[key];
            })
            .filter((node2) => node2.parentId === nodeId)
            .sort((a, b2) => a.index - b2.index)
            .map((child) => child.id);
    const getNavigableChildrenIds = (nodeId) => {
        let childrenIds = getChildrenIds(nodeId);
        if (!disabledItemsFocusable) {
            childrenIds = childrenIds.filter((node2) => !isDisabled(node2));
        }
        return childrenIds;
    };
    const getNextNode = (nodeId) => {
        if (isExpanded(nodeId) && getNavigableChildrenIds(nodeId).length > 0) {
            return getNavigableChildrenIds(nodeId)[0];
        }
        let node2 = nodeMap.current[nodeId];
        while (node2 != null) {
            const siblings = getNavigableChildrenIds(node2.parentId);
            const nextSibling = siblings[siblings.indexOf(node2.id) + 1];
            if (nextSibling) {
                return nextSibling;
            }
            node2 = nodeMap.current[node2.parentId];
        }
        return null;
    };
    const getPreviousNode = (nodeId) => {
        const node2 = nodeMap.current[nodeId];
        const siblings = getNavigableChildrenIds(node2.parentId);
        const nodeIndex = siblings.indexOf(nodeId);
        if (nodeIndex === 0) {
            return node2.parentId;
        }
        let currentNode = siblings[nodeIndex - 1];
        while (isExpanded(currentNode) && getNavigableChildrenIds(currentNode).length > 0) {
            currentNode = getNavigableChildrenIds(currentNode).pop();
        }
        return currentNode;
    };
    const getLastNode = () => {
        let lastNode = getNavigableChildrenIds(null).pop();
        while (isExpanded(lastNode)) {
            lastNode = getNavigableChildrenIds(lastNode).pop();
        }
        return lastNode;
    };
    const getFirstNode = () => getNavigableChildrenIds(null)[0];
    const getParent = (nodeId) => nodeMap.current[nodeId].parentId;
    const findOrderInTremauxTree = (nodeAId, nodeBId) => {
        if (nodeAId === nodeBId) {
            return [nodeAId, nodeBId];
        }
        const nodeA = nodeMap.current[nodeAId];
        const nodeB = nodeMap.current[nodeBId];
        if (nodeA.parentId === nodeB.id || nodeB.parentId === nodeA.id) {
            return nodeB.parentId === nodeA.id ? [nodeA.id, nodeB.id] : [nodeB.id, nodeA.id];
        }
        const aFamily = [nodeA.id];
        const bFamily = [nodeB.id];
        let aAncestor = nodeA.parentId;
        let bAncestor = nodeB.parentId;
        let aAncestorIsCommon = bFamily.indexOf(aAncestor) !== -1;
        let bAncestorIsCommon = aFamily.indexOf(bAncestor) !== -1;
        let continueA = true;
        let continueB = true;
        while (!bAncestorIsCommon && !aAncestorIsCommon) {
            if (continueA) {
                aFamily.push(aAncestor);
                aAncestorIsCommon = bFamily.indexOf(aAncestor) !== -1;
                continueA = aAncestor !== null;
                if (!aAncestorIsCommon && continueA) {
                    aAncestor = nodeMap.current[aAncestor].parentId;
                }
            }
            if (continueB && !aAncestorIsCommon) {
                bFamily.push(bAncestor);
                bAncestorIsCommon = aFamily.indexOf(bAncestor) !== -1;
                continueB = bAncestor !== null;
                if (!bAncestorIsCommon && continueB) {
                    bAncestor = nodeMap.current[bAncestor].parentId;
                }
            }
        }
        const commonAncestor = aAncestorIsCommon ? aAncestor : bAncestor;
        const ancestorFamily = getChildrenIds(commonAncestor);
        const aSide = aFamily[aFamily.indexOf(commonAncestor) - 1];
        const bSide = bFamily[bFamily.indexOf(commonAncestor) - 1];
        return ancestorFamily.indexOf(aSide) < ancestorFamily.indexOf(bSide) ? [nodeAId, nodeBId] : [nodeBId, nodeAId];
    };
    const getNodesInRange = (nodeAId, nodeBId) => {
        const [first, last] = findOrderInTremauxTree(nodeAId, nodeBId);
        const nodes = [first];
        let current = first;
        while (current !== last) {
            current = getNextNode(current);
            nodes.push(current);
        }
        return nodes;
    };
    const focus = (event, nodeId) => {
        if (nodeId) {
            setFocusedNodeId(nodeId);
            if (onNodeFocus) {
                onNodeFocus(event, nodeId);
            }
        }
    };
    const focusNextNode = (event, nodeId) => focus(event, getNextNode(nodeId));
    const focusPreviousNode = (event, nodeId) => focus(event, getPreviousNode(nodeId));
    const focusFirstNode = (event) => focus(event, getFirstNode());
    const focusLastNode = (event) => focus(event, getLastNode());
    const focusByFirstCharacter = (event, nodeId, firstChar) => {
        let start2;
        let index;
        const lowercaseChar = firstChar.toLowerCase();
        const firstCharIds = [];
        const firstChars = [];
        Object.keys(firstCharMap.current).forEach((mapNodeId) => {
            const map = nodeMap.current[mapNodeId];
            const visible = map.parentId ? isExpanded(map.parentId) : true;
            const shouldBeSkipped = disabledItemsFocusable ? false : isDisabled(mapNodeId);
            if (visible && !shouldBeSkipped) {
                firstCharIds.push(mapNodeId);
                firstChars.push(firstCharMap.current[mapNodeId]);
            }
        });
        start2 = firstCharIds.indexOf(nodeId) + 1;
        if (start2 >= firstCharIds.length) {
            start2 = 0;
        }
        index = findNextFirstChar(firstChars, start2, lowercaseChar);
        if (index === -1) {
            index = findNextFirstChar(firstChars, 0, lowercaseChar);
        }
        if (index > -1) {
            focus(event, firstCharIds[index]);
        }
    };
    const toggleExpansion = (event, value = focusedNodeId) => {
        if (value == null) {
            return;
        }
        let newExpanded;
        if (expanded.indexOf(value) !== -1) {
            newExpanded = expanded.filter((id) => id !== value);
        } else {
            newExpanded = [value].concat(expanded);
        }
        if (onNodeToggle) {
            onNodeToggle(event, newExpanded);
        }
        setExpandedState(newExpanded);
    };
    const expandAllSiblings = (event, nodeId) => {
        const map = nodeMap.current[nodeId];
        const siblings = getChildrenIds(map.parentId);
        const diff = siblings.filter((child) => isExpandable(child) && !isExpanded(child));
        const newExpanded = expanded.concat(diff);
        if (diff.length > 0) {
            setExpandedState(newExpanded);
            if (onNodeToggle) {
                onNodeToggle(event, newExpanded);
            }
        }
    };
    const lastSelectedNode = reactExports.useRef(null);
    const lastSelectionWasRange = reactExports.useRef(false);
    const currentRangeSelection = reactExports.useRef([]);
    const handleRangeArrowSelect = (event, nodes) => {
        let base = selected.slice();
        const { start: start2, next: next2, current } = nodes;
        if (!next2 || !current) {
            return;
        }
        if (currentRangeSelection.current.indexOf(current) === -1) {
            currentRangeSelection.current = [];
        }
        if (lastSelectionWasRange.current) {
            if (currentRangeSelection.current.indexOf(next2) !== -1) {
                base = base.filter((id) => id === start2 || id !== current);
                currentRangeSelection.current = currentRangeSelection.current.filter((id) => id === start2 || id !== current);
            } else {
                base.push(next2);
                currentRangeSelection.current.push(next2);
            }
        } else {
            base.push(next2);
            currentRangeSelection.current.push(current, next2);
        }
        if (onNodeSelect) {
            onNodeSelect(event, base);
        }
        setSelectedState(base);
    };
    const handleRangeSelect = (event, nodes) => {
        let base = selected.slice();
        const { start: start2, end: end2 } = nodes;
        if (lastSelectionWasRange.current) {
            base = base.filter((id) => currentRangeSelection.current.indexOf(id) === -1);
        }
        let range = getNodesInRange(start2, end2);
        range = range.filter((node2) => !isDisabled(node2));
        currentRangeSelection.current = range;
        let newSelected = base.concat(range);
        newSelected = newSelected.filter((id, i) => newSelected.indexOf(id) === i);
        if (onNodeSelect) {
            onNodeSelect(event, newSelected);
        }
        setSelectedState(newSelected);
    };
    const handleMultipleSelect = (event, nodeId) => {
        if (!Array.isArray(selected)) {
            return;
        }
        let newSelected;
        if (selected.indexOf(nodeId) !== -1) {
            newSelected = selected.filter((id) => id !== nodeId);
        } else {
            newSelected = [nodeId].concat(selected);
        }
        if (onNodeSelect) {
            onNodeSelect(event, newSelected);
        }
        setSelectedState(newSelected);
    };
    const handleSingleSelect = (event, nodeId) => {
        const newSelected = multiSelect ? [nodeId] : nodeId;
        if (onNodeSelect) {
            onNodeSelect(event, newSelected);
        }
        setSelectedState(newSelected);
    };
    const selectNode = (event, nodeId, multiple = false) => {
        if (nodeId) {
            if (multiple) {
                handleMultipleSelect(event, nodeId);
            } else {
                handleSingleSelect(event, nodeId);
            }
            lastSelectedNode.current = nodeId;
            lastSelectionWasRange.current = false;
            currentRangeSelection.current = [];
            return true;
        }
        return false;
    };
    const selectRange = (event, nodes, stacked = false) => {
        const { start: start2 = lastSelectedNode.current, end: end2, current } = nodes;
        if (stacked) {
            handleRangeArrowSelect(event, {
                start: start2,
                next: end2,
                current,
            });
        } else if (start2 != null && end2 != null) {
            handleRangeSelect(event, {
                start: start2,
                end: end2,
            });
        }
        lastSelectionWasRange.current = true;
    };
    const rangeSelectToFirst = (event, id) => {
        if (!lastSelectedNode.current) {
            lastSelectedNode.current = id;
        }
        const start2 = lastSelectionWasRange.current ? lastSelectedNode.current : id;
        selectRange(event, {
            start: start2,
            end: getFirstNode(),
        });
    };
    const rangeSelectToLast = (event, id) => {
        if (!lastSelectedNode.current) {
            lastSelectedNode.current = id;
        }
        const start2 = lastSelectionWasRange.current ? lastSelectedNode.current : id;
        selectRange(event, {
            start: start2,
            end: getLastNode(),
        });
    };
    const selectNextNode = (event, id) => {
        if (!isDisabled(getNextNode(id))) {
            selectRange(
                event,
                {
                    end: getNextNode(id),
                    current: id,
                },
                true
            );
        }
    };
    const selectPreviousNode = (event, id) => {
        if (!isDisabled(getPreviousNode(id))) {
            selectRange(
                event,
                {
                    end: getPreviousNode(id),
                    current: id,
                },
                true
            );
        }
    };
    const selectAllNodes = (event) => {
        selectRange(event, {
            start: getFirstNode(),
            end: getLastNode(),
        });
    };
    const registerNode = reactExports.useCallback((node2) => {
        const { id, index, parentId, expandable, idAttribute, disabled } = node2;
        nodeMap.current[id] = {
            id,
            index,
            parentId,
            expandable,
            idAttribute,
            disabled,
        };
    }, []);
    const unregisterNode = reactExports.useCallback((nodeId) => {
        const newMap = _extends({}, nodeMap.current);
        delete newMap[nodeId];
        nodeMap.current = newMap;
        setFocusedNodeId((oldFocusedNodeId) => {
            if (oldFocusedNodeId === nodeId && treeRef.current === ownerDocument(treeRef.current).activeElement) {
                return getChildrenIds(null)[0];
            }
            return oldFocusedNodeId;
        });
    }, []);
    const mapFirstChar = reactExports.useCallback((nodeId, firstChar) => {
        firstCharMap.current[nodeId] = firstChar;
    }, []);
    const unMapFirstChar = reactExports.useCallback((nodeId) => {
        const newMap = _extends({}, firstCharMap.current);
        delete newMap[nodeId];
        firstCharMap.current = newMap;
    }, []);
    const handleNextArrow = (event) => {
        if (focusedNodeId != null && isExpandable(focusedNodeId)) {
            if (isExpanded(focusedNodeId)) {
                focusNextNode(event, focusedNodeId);
            } else if (!isDisabled(focusedNodeId)) {
                toggleExpansion(event);
            }
        }
        return true;
    };
    const handlePreviousArrow = (event) => {
        if (focusedNodeId == null) {
            return false;
        }
        if (isExpanded(focusedNodeId) && !isDisabled(focusedNodeId)) {
            toggleExpansion(event, focusedNodeId);
            return true;
        }
        const parent = getParent(focusedNodeId);
        if (parent) {
            focus(event, parent);
            return true;
        }
        return false;
    };
    const handleKeyDown2 = (event) => {
        let flag = false;
        const key = event.key;
        if (event.altKey || event.currentTarget !== event.target || !focusedNodeId) {
            return;
        }
        const ctrlPressed = event.ctrlKey || event.metaKey;
        switch (key) {
            case " ":
                if (!disableSelection && focusedNodeId != null && !isDisabled(focusedNodeId)) {
                    if (multiSelect && event.shiftKey) {
                        selectRange(event, {
                            end: focusedNodeId,
                        });
                        flag = true;
                    } else if (multiSelect) {
                        flag = selectNode(event, focusedNodeId, true);
                    } else {
                        flag = selectNode(event, focusedNodeId);
                    }
                }
                event.stopPropagation();
                break;
            case "Enter":
                if (!isDisabled(focusedNodeId)) {
                    if (isExpandable(focusedNodeId)) {
                        toggleExpansion(event);
                        flag = true;
                    } else if (multiSelect) {
                        flag = selectNode(event, focusedNodeId, true);
                    } else {
                        flag = selectNode(event, focusedNodeId);
                    }
                }
                event.stopPropagation();
                break;
            case "ArrowDown":
                if (multiSelect && event.shiftKey && !disableSelection) {
                    selectNextNode(event, focusedNodeId);
                }
                focusNextNode(event, focusedNodeId);
                flag = true;
                break;
            case "ArrowUp":
                if (multiSelect && event.shiftKey && !disableSelection) {
                    selectPreviousNode(event, focusedNodeId);
                }
                focusPreviousNode(event, focusedNodeId);
                flag = true;
                break;
            case "ArrowRight":
                if (isRtl) {
                    flag = handlePreviousArrow(event);
                } else {
                    flag = handleNextArrow(event);
                }
                break;
            case "ArrowLeft":
                if (isRtl) {
                    flag = handleNextArrow(event);
                } else {
                    flag = handlePreviousArrow(event);
                }
                break;
            case "Home":
                if (multiSelect && ctrlPressed && event.shiftKey && !disableSelection && !isDisabled(focusedNodeId)) {
                    rangeSelectToFirst(event, focusedNodeId);
                }
                focusFirstNode(event);
                flag = true;
                break;
            case "End":
                if (multiSelect && ctrlPressed && event.shiftKey && !disableSelection && !isDisabled(focusedNodeId)) {
                    rangeSelectToLast(event, focusedNodeId);
                }
                focusLastNode(event);
                flag = true;
                break;
            default:
                if (key === "*") {
                    expandAllSiblings(event, focusedNodeId);
                    flag = true;
                } else if (multiSelect && ctrlPressed && key.toLowerCase() === "a" && !disableSelection) {
                    selectAllNodes(event);
                    flag = true;
                } else if (!ctrlPressed && !event.shiftKey && isPrintableCharacter(key)) {
                    focusByFirstCharacter(event, focusedNodeId, key);
                    flag = true;
                }
        }
        if (flag) {
            event.preventDefault();
            event.stopPropagation();
        }
        if (onKeyDown) {
            onKeyDown(event);
        }
    };
    const handleFocus = (event) => {
        if (event.target === event.currentTarget) {
            const firstSelected = Array.isArray(selected) ? selected[0] : selected;
            focus(event, firstSelected || getNavigableChildrenIds(null)[0]);
        }
        if (onFocus) {
            onFocus(event);
        }
    };
    const handleBlur = (event) => {
        setFocusedNodeId(null);
        if (onBlur) {
            onBlur(event);
        }
    };
    const activeDescendant = nodeMap.current[focusedNodeId] ? nodeMap.current[focusedNodeId].idAttribute : null;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(TreeViewContext.Provider, {
        // TODO: fix this lint error
        // eslint-disable-next-line react/jsx-no-constructed-context-values
        value: {
            icons: {
                defaultCollapseIcon,
                defaultExpandIcon,
                defaultParentIcon,
                defaultEndIcon,
            },
            focus,
            toggleExpansion,
            isExpanded,
            isExpandable,
            isFocused,
            isSelected,
            isDisabled,
            selectNode: disableSelection ? noopSelection : selectNode,
            selectRange: disableSelection ? noopSelection : selectRange,
            multiSelect,
            disabledItemsFocusable,
            mapFirstChar,
            unMapFirstChar,
            registerNode,
            unregisterNode,
            treeId,
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(DescendantProvider, {
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                TreeViewRoot,
                _extends(
                    {
                        role: "tree",
                        id: treeId,
                        "aria-activedescendant": activeDescendant != null ? activeDescendant : void 0,
                        "aria-multiselectable": multiSelect,
                        className: clsx(classes.root, className),
                        tabIndex: 0,
                        onKeyDown: handleKeyDown2,
                        onFocus: handleFocus,
                        onBlur: handleBlur,
                        ownerState: props,
                    },
                    other,
                    {
                        ref: handleRef,
                        children,
                    }
                )
            ),
        }),
    });
});
let warnedOnce = false;
const warn = () => {
    if (!warnedOnce) {
        console.warn(
            [
                "MUI: The TreeView component was moved from `@mui/lab` to `@mui/x-tree-view`.",
                "The component will no longer be exported from `@mui/lab` in the first release of October 2023.",
                "",
                "You should use `import { TreeView } from '@mui/x-tree-view'`",
                "or `import { TreeView } from '@mui/x-tree-view/TreeView'`",
                "",
                "More information about this migration on our blog: https://mui.com/blog/lab-tree-view-to-mui-x/.",
            ].join("\n")
        );
        warnedOnce = true;
    }
};
const TreeView2 = /* @__PURE__ */ reactExports.forwardRef(function DeprecatedTreeView(props, ref) {
    warn();
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
        TreeView$2,
        _extends({}, props, {
            ref,
        })
    );
});
const TreeView$1 = TreeView2;
var ExpandMore = {};
var createSvgIcon = {};
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(utils);
var hasRequiredCreateSvgIcon;
function requireCreateSvgIcon() {
    if (hasRequiredCreateSvgIcon) return createSvgIcon;
    hasRequiredCreateSvgIcon = 1;
    (function (exports) {
        Object.defineProperty(exports, "__esModule", {
            value: true,
        });
        Object.defineProperty(exports, "default", {
            enumerable: true,
            get: function () {
                return _utils.createSvgIcon;
            },
        });
        var _utils = require$$0;
    })(createSvgIcon);
    return createSvgIcon;
}
var _interopRequireDefault$2 = interopRequireDefaultExports;
Object.defineProperty(ExpandMore, "__esModule", {
    value: true,
});
var default_1$2 = (ExpandMore.default = void 0);
var _createSvgIcon$2 = _interopRequireDefault$2(requireCreateSvgIcon());
var _jsxRuntime$2 = jsxRuntimeExports;
var _default$2 = (0, _createSvgIcon$2.default)(
    /* @__PURE__ */ (0, _jsxRuntime$2.jsx)("path", {
        d: "M16.59 8.59 12 13.17 7.41 8.59 6 10l6 6 6-6z",
    }),
    "ExpandMore"
);
default_1$2 = ExpandMore.default = _default$2;
var ChevronRight = {};
var _interopRequireDefault$1 = interopRequireDefaultExports;
Object.defineProperty(ChevronRight, "__esModule", {
    value: true,
});
var default_1$1 = (ChevronRight.default = void 0);
var _createSvgIcon$1 = _interopRequireDefault$1(requireCreateSvgIcon());
var _jsxRuntime$1 = jsxRuntimeExports;
var _default$1 = (0, _createSvgIcon$1.default)(
    /* @__PURE__ */ (0, _jsxRuntime$1.jsx)("path", {
        d: "M10 6 8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z",
    }),
    "ChevronRight"
);
default_1$1 = ChevronRight.default = _default$1;
const charCodeOfDot = ".".charCodeAt(0);
const reEscapeChar = /\\(\\)?/g;
const rePropName = RegExp(`[^.[\\]]+|\\[(?:([^"'][^[]*)|(["'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))`, "g");
const stringToPath = (string) => {
    const result = [];
    if (string.charCodeAt(0) === charCodeOfDot) {
        result.push("");
    }
    string.replace(rePropName, (match2, expression, quote, subString) => {
        let key = match2;
        if (quote) {
            key = subString.replace(reEscapeChar, "$1");
        } else if (expression) {
            key = expression.trim();
        }
        result.push(key);
        return "";
    });
    return result;
};
const keysCache = {};
const toPath = (key) => {
    if (key === null || key === void 0 || !key.length) {
        return [];
    }
    if (typeof key !== "string") {
        throw new Error("toPath() expects a string");
    }
    if (keysCache[key] == null) {
        keysCache[key] = stringToPath(key);
    }
    return keysCache[key];
};
const setInRecursor = (current, index, path, value, destroyArrays) => {
    if (index >= path.length) {
        return value;
    }
    const key = path[index];
    if (isNaN(key)) {
        if (current === void 0 || current === null) {
            const result3 = setInRecursor(void 0, index + 1, path, value, destroyArrays);
            return result3 === void 0 ? void 0 : { [key]: result3 };
        }
        if (Array.isArray(current)) {
            throw new Error("Cannot set a non-numeric property on an array");
        }
        const result2 = setInRecursor(current[key], index + 1, path, value, destroyArrays);
        if (result2 === void 0) {
            const numKeys = Object.keys(current).length;
            if (current[key] === void 0 && numKeys === 0) {
                return void 0;
            }
            if (current[key] !== void 0 && numKeys <= 1) {
                if (!isNaN(path[index - 1]) && !destroyArrays) {
                    return {};
                } else {
                    return void 0;
                }
            }
            const { [key]: _removed, ...final } = current;
            return final;
        }
        return {
            ...current,
            [key]: result2,
        };
    }
    const numericKey = Number(key);
    if (current === void 0 || current === null) {
        const result2 = setInRecursor(void 0, index + 1, path, value, destroyArrays);
        if (result2 === void 0) {
            return void 0;
        }
        const array2 = [];
        array2[numericKey] = result2;
        return array2;
    }
    if (!Array.isArray(current)) {
        throw new Error("Cannot set a numeric property on an object");
    }
    const existingValue = current[numericKey];
    const result = setInRecursor(existingValue, index + 1, path, value, destroyArrays);
    const array = [...current];
    if (destroyArrays && result === void 0) {
        array.splice(numericKey, 1);
        if (array.length === 0) {
            return void 0;
        }
    } else {
        array[numericKey] = result;
    }
    return array;
};
const setIn = (state, key, value) => {
    if (state === void 0 || state === null) {
        throw new Error(`Cannot call setIn() with ${String(state)} state`);
    }
    if (key === void 0 || key === null) {
        throw new Error(`Cannot call setIn() with ${String(key)} key`);
    }
    return setInRecursor(state, 0, toPath(key), value, false);
};
function fixHoles(ob) {
    if (Array.isArray(ob)) {
        const array = ob;
        for (let index = 0, length2 = array.length; index < length2; index++) {
            if (!(index in array)) {
                array[index] = void 0;
            } else {
                fixHoles(array[index]);
            }
        }
    }
    if (ob === null) {
        return;
    }
    if (typeof ob === "object") {
        for (const value of Object.values(ob)) {
            fixHoles(value);
        }
    }
}
function parseFormAny(form) {
    let data;
    if ("onsubmit" in form) {
        data = new FormData(form);
    } else {
        data = form;
    }
    let ret = {};
    for (const [key, value] of data.entries()) {
        ret = setIn(ret, key, value);
    }
    fixHoles(ret);
    return ret;
}
function safeParseForm(schema, form) {
    return schema.safeParse(parseFormAny(form));
}
function arrayEquals(a, b2) {
    return (
        a.length === b2.length &&
        a.every((item, index) => {
            return item === b2[index];
        })
    );
}
function addArrayIndex(path, index) {
    const last = path[path.length - 1];
    return [...path.slice(0, -1), `${last}[${index}]`];
}
function fieldChain(ns, schema) {
    return new Proxy(
        {},
        {
            get(_target, prop) {
                return _fieldChain(ns, [])[prop];
            },
        }
    );
}
function _fieldChain(ns, path) {
    const proxy = new Proxy(() => {}, {
        apply(_target, _thisArg, args) {
            if (typeof args[0] === "number") {
                return _fieldChain(ns, addArrayIndex(path, args[0]));
            }
            const name = path.join(".");
            const id = ns + ":" + path.join(".");
            if (args[0] === "id") {
                return id;
            }
            if (typeof args[0] === "function") {
                return args[0]({ id, name });
            }
            return name;
        },
        get(_target, prop) {
            if (typeof prop === "string") {
                return _fieldChain(ns, [...path, prop]);
            }
            return _fieldChain(ns, path);
        },
    });
    return proxy;
}
function errorChain(schema, issues, _path) {
    let path = _path || [];
    const proxy = new Proxy(() => {}, {
        apply(_target, _thisArg, args) {
            if (typeof args[0] === "number") {
                return errorChain(schema, issues, [...path, args[0]]);
            }
            const issue = issues.find((issue2) => {
                return arrayEquals(issue2.path, path);
            });
            if (args[0] === Boolean) {
                return Boolean(issue);
            }
            if (typeof args[0] === "function") {
                if (issue) {
                    return args[0](issue);
                }
                return void 0;
            }
            if (args[0]) {
                if (issue) {
                    return args[0];
                } else {
                    return void 0;
                }
            }
            return issue || void 0;
        },
        get(_target, prop) {
            if (typeof prop === "string") {
                return errorChain(schema, issues, [...path, prop]);
            }
            return errorChain(schema, issues, path);
        },
    });
    return proxy;
}
function createCustomIssues(schema, _state) {
    const state = _state
        ? _state
        : {
              path: [],
              issues: [],
          };
    const methods = {
        toJSON: () => state.issues.slice(0),
        toArray: () => state.issues.slice(0),
        hasIssues: () => state.issues.length > 0,
    };
    const proxy = new Proxy(() => {}, {
        apply(_target, _thisArg, args) {
            if (typeof args[0] === "number") {
                return createCustomIssues(schema, {
                    ...state,
                    path: [...state.path, args[0]],
                });
            }
            const issue = {
                code: "custom",
                path: state.path,
                message: args[0],
                params: args[1] ?? {},
            };
            state.issues.push(issue);
            return issue;
        },
        get(_target, prop) {
            if (state.path.length === 0 && prop in methods) {
                return methods[prop];
            }
            if (typeof prop === "string") {
                return createCustomIssues(schema, {
                    ...state,
                    path: [...state.path, prop],
                });
            }
            return createCustomIssues(schema, state);
        },
    });
    return proxy;
}
function useZorm(formName, schema, options) {
    const formRef = reactExports.useRef();
    const submittedOnceRef = reactExports.useRef(false);
    const submitRef = reactExports.useRef(options == null ? void 0 : options.onValidSubmit);
    submitRef.current = options == null ? void 0 : options.onValidSubmit;
    const [validation, setValidation] = reactExports.useState(null);
    const getForm = reactExports.useCallback(() => {
        if (!formRef.current) {
            throw new Error("[react-zorm]: Form ref not passed");
        }
        return formRef.current;
    }, []);
    const validate = reactExports.useCallback(() => {
        const res = safeParseForm(schema, getForm());
        setValidation(res);
        return res;
    }, [getForm, schema]);
    const changeHandler = reactExports.useCallback(() => {
        if (!submittedOnceRef.current) {
            return;
        }
        validate();
    }, [validate]);
    const submitHandler = reactExports.useCallback(
        (e2) => {
            var _a;
            submittedOnceRef.current = true;
            const validation2 = validate();
            if (!validation2.success) {
                e2.preventDefault();
            } else {
                (_a = submitRef.current) == null
                    ? void 0
                    : _a.call(submitRef, {
                          data: validation2.data,
                          target: getForm(),
                          preventDefault: () => {
                              e2.preventDefault();
                          },
                      });
            }
        },
        [getForm, validate]
    );
    const callbackRef = reactExports.useCallback(
        (form) => {
            if (form !== formRef.current) {
                if (formRef.current) {
                    formRef.current.removeEventListener("change", changeHandler);
                    formRef.current.removeEventListener("submit", submitHandler);
                }
                if (form && (options == null ? void 0 : options.setupListeners) !== false) {
                    form.addEventListener("change", changeHandler);
                    form.addEventListener("submit", submitHandler);
                }
                formRef.current = form ?? void 0;
            }
        },
        [changeHandler, options == null ? void 0 : options.setupListeners, submitHandler]
    );
    return reactExports.useMemo(() => {
        let customIssues = (options == null ? void 0 : options.customIssues) ?? [];
        let error = !(validation == null ? void 0 : validation.success) ? (validation == null ? void 0 : validation.error) : void 0;
        const errors = errorChain(schema, [...((error == null ? void 0 : error.issues) ?? []), ...customIssues]);
        const fields = fieldChain(formName);
        return {
            ref: callbackRef,
            refObject: formRef,
            validate,
            get form() {
                return formRef.current;
            },
            validation,
            fields,
            errors,
            customIssues,
        };
    }, [callbackRef, formName, options == null ? void 0 : options.customIssues, schema, validate, validation]);
}
function errorMessage(zormError) {
    return zormError((e2) => /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { color: "red" }, children: e2.message }));
}
const ProfilesTable = () => {
    const { model, updateModel } = useModel();
    const [filteringChars, setFilteringChars] = reactExports.useState("");
    const [orderBy, setOrderBy] = reactExports.useState("name");
    const [order2, setOrder] = reactExports.useState("asc");
    function handleRequestSort(property) {
        const isAsc = orderBy === property && order2 === "asc";
        setOrder(isAsc ? "desc" : "asc");
        setOrderBy(property);
    }
    const renderProfiles = SRD.match(
        {
            // eslint-disable-next-line react/no-unescaped-entities
            notAsked: () => /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Let's fetch some data!" }),
            loading: () =>
                /* @__PURE__ */ jsxRuntimeExports.jsx(Box$1, { sx: { display: "flex", justifyContent: "center", p: 4 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress$1, {}) }),
            failure: (msg) =>
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Box$1, {
                    sx: { display: "flex", justifyContent: "center", p: 4 },
                    children: [",", /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: `I stumbled into this error when I tried to fetch data: ${msg}. Please, reload this page.` })],
                }),
            success: (gotProfiles) => {
                const datas = gotProfiles.map((profile) => {
                    const { allowedSourceSchemas, forbiddenTools, allowedTools, sourcesAccessControl, blender, ...restOfProperties } = profile;
                    const processedData = {
                        ...restOfProperties,
                        forbiddenTools: joinWhenArray(forbiddenTools),
                        allowedTools: joinWhenArray(allowedTools),
                        allowedSourceSchemas: allowedSourceSchemas.join(";"),
                        sourcesAccessControl: JSON.stringify(sourcesAccessControl),
                    };
                    const dataWithoutCarriageReturns = Object.fromEntries(
                        Object.entries(processedData).map(([key, value]) => {
                            if (typeof value === "string") {
                                return [key, value.replace("\n", " ")];
                            }
                            return [key, value];
                        })
                    );
                    return { ...dataWithoutCarriageReturns };
                });
                const sortedProfiles = gotProfiles.slice().sort((a, b2) => {
                    const left2 = a[orderBy];
                    const right2 = b2[orderBy];
                    return order2 === "asc" ? left2.localeCompare(right2) : right2.localeCompare(left2);
                });
                return /* @__PURE__ */ jsxRuntimeExports.jsx(Box$1, {
                    sx: { display: "flex", justifyContent: "center", p: 4 },
                    children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack$1, {
                        children: [
                            /* @__PURE__ */ jsxRuntimeExports.jsx(CsvDownload, { separator: "	", filename: "profiles", extension: ".tsv", datas }),
                            /* @__PURE__ */ jsxRuntimeExports.jsx(Autocomplete$1, {
                                disablePortal: true,
                                id: "filter profiles",
                                options: gotProfiles.map((profile) => profile.name),
                                sx: { width: 300 },
                                onInputChange: (event, newInputValue) => {
                                    setFilteringChars(newInputValue);
                                },
                                renderInput: (params) => /* @__PURE__ */ jsxRuntimeExports.jsx(TextField$1, { ...params, label: "Search Profiles by name" }),
                            }),
                            /* @__PURE__ */ jsxRuntimeExports.jsx(Box$1, {
                                sx: { justifyContent: "center", display: "flex" },
                                children: /* @__PURE__ */ jsxRuntimeExports.jsx(TableContainer$1, {
                                    sx: { height: "400px" },
                                    component: Paper$1,
                                    children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Table$1, {
                                        children: [
                                            /* @__PURE__ */ jsxRuntimeExports.jsx(TableHead$1, {
                                                children: /* @__PURE__ */ jsxRuntimeExports.jsxs(TableRow$1, {
                                                    children: [
                                                        /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell$1, {
                                                            style: { fontWeight: "bold" },
                                                            children: /* @__PURE__ */ jsxRuntimeExports.jsx(TableSortLabel$1, {
                                                                active: orderBy === "name",
                                                                direction: order2,
                                                                onClick: () => handleRequestSort("name"),
                                                                children: "Name",
                                                            }),
                                                        }),
                                                        /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell$1, { style: { fontWeight: "bold" }, children: "Allowed Sources" }),
                                                        /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell$1, { style: { fontWeight: "bold" }, children: "Actions" }),
                                                    ],
                                                }),
                                            }),
                                            /* @__PURE__ */ jsxRuntimeExports.jsx(TableBody$1, {
                                                sx: { width: "100%", overflow: "visible" },
                                                children: sortedProfiles
                                                    .filter((profile) => profile.name.includes(filteringChars))
                                                    .map((profile) => {
                                                        return /* @__PURE__ */ jsxRuntimeExports.jsxs(
                                                            TableRow$1,
                                                            {
                                                                children: [
                                                                    /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell$1, { children: profile.name }),
                                                                    /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell$1, { children: profile.allowedSourceSchemas.join(", ") }),
                                                                    /* @__PURE__ */ jsxRuntimeExports.jsxs(TableCell$1, {
                                                                        children: [
                                                                            /* @__PURE__ */ jsxRuntimeExports.jsx(ProfileForm, { profile }),
                                                                            /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonWithConfirmation, {
                                                                                label: "Delete",
                                                                                msg: () => deleteProfile(profile, updateModel),
                                                                            }),
                                                                        ],
                                                                    }),
                                                                ],
                                                            },
                                                            profile.id
                                                        );
                                                    }),
                                            }),
                                        ],
                                    }),
                                }),
                            }),
                            /* @__PURE__ */ jsxRuntimeExports.jsx(Box$1, {
                                sx: { display: "flex", justifyContent: "center", p: 4 },
                                children: /* @__PURE__ */ jsxRuntimeExports.jsx(ProfileForm, { create: true }),
                            }),
                        ],
                    }),
                });
            },
        },
        model.profiles
    );
    return renderProfiles;
};
var Type$1 = /* @__PURE__ */ ((Type2) => {
    Type2[(Type2["UserClickedModal"] = 0)] = "UserClickedModal";
    Type2[(Type2["UserUpdatedField"] = 1)] = "UserUpdatedField";
    Type2[(Type2["UserUpdatedSourceAccessControl"] = 2)] = "UserUpdatedSourceAccessControl";
    Type2[(Type2["ResetProfile"] = 3)] = "ResetProfile";
    Type2[(Type2["UserClickedCheckAll"] = 4)] = "UserClickedCheckAll";
    Type2[(Type2["UserUpdatedBlenderLevel"] = 5)] = "UserUpdatedBlenderLevel";
    return Type2;
})(Type$1 || {});
var Mode$1 = /* @__PURE__ */ ((Mode2) => {
    Mode2[(Mode2["Creation"] = 0)] = "Creation";
    Mode2[(Mode2["Edition"] = 1)] = "Edition";
    return Mode2;
})(Mode$1 || {});
const updateProfile = (profileEditionState, msg) => {
    const fieldToUpdate = msg.type === 4 || msg.type === 1 ? msg.payload.fieldname : null;
    switch (msg.type) {
        case 0:
            return { ...profileEditionState, modal: msg.payload };
        case 1:
            return { ...profileEditionState, profileForm: { ...profileEditionState.profileForm, [fieldToUpdate]: msg.payload.newValue } };
        case 2: {
            const { treeStr, newValue } = msg.payload;
            let newSourcesAccessControls;
            const previousSourcesAccessControl = profileEditionState.profileForm.sourcesAccessControl;
            if (newValue === null) {
                const { [treeStr]: value, ...otherSource } = previousSourcesAccessControl;
                newSourcesAccessControls = otherSource;
            } else {
                newSourcesAccessControls = {
                    ...profileEditionState.profileForm.sourcesAccessControl,
                    [msg.payload.treeStr]: newValue,
                };
            }
            return {
                ...profileEditionState,
                profileForm: {
                    ...profileEditionState.profileForm,
                    sourcesAccessControl: newSourcesAccessControls,
                },
            };
        }
        case 4:
            return { ...profileEditionState, profileForm: { ...profileEditionState.profileForm, [fieldToUpdate]: msg.payload.value ? "ALL" : [] } };
        case 5:
            return { ...profileEditionState, profileForm: { ...profileEditionState.profileForm, blender: { contextMenuActionStartLevel: msg.payload } } };
        case 3:
            return { ...profileEditionState, profileForm: msg.payload };
    }
};
const ProfileForm = ({ profile = defaultProfile(ulid()), create = false }) => {
    var _a;
    const [nodesClicked, setNodeToExpand] = reactExports.useState([]);
    const { model, updateModel } = useModel();
    const unwrappedSources = SRD.unwrap([], identity, model.sources);
    const unwrappedProfiles = SRD.unwrap([], identity, model.profiles);
    const [issues, setIssues] = reactExports.useState([]);
    const sources = reactExports.useMemo(() => {
        return unwrappedSources;
    }, [unwrappedSources]);
    const schemaTypes = [...new Set(sources.map((source) => source.schemaType))];
    const config = SRD.withDefault({ auth: "", tools_available: [] }, model.config);
    const [profileModel, update2] = reactExports.useReducer(updateProfile, { modal: false, profileForm: profile });
    const tools = ["ALL", ...profileModel.profileForm.forbiddenTools, ...config.tools_available].filter((val, idx, array) => {
        return array.indexOf(val) === idx;
    });
    reactExports.useEffect(() => {
        update2({ type: 3, payload: profile });
    }, [profileModel.modal]);
    const handleOpen = () => update2({ type: 0, payload: true });
    const handleClose = () => {
        setNodeToExpand([]);
        update2({ type: 0, payload: false });
    };
    const handleFieldUpdate = (fieldname) => (event) => update2({ type: 1, payload: { fieldname, newValue: event.target.value } });
    const zo = useZorm("form", ProfileSchema, { setupListeners: false, customIssues: issues });
    const handleSourceAccessControlUpdate = (src) => (event) => {
        const treeStr = src.treeStr;
        let bf = "";
        const parentList = treeStr
            .split("/")
            .map((branch) => {
                const prt = bf === "" ? branch : [bf, branch].join("/");
                bf = prt;
                return prt;
            })
            .slice(0, -1);
        const currentSac = profileModel.profileForm.sourcesAccessControl;
        const parentListWithValue = Object.entries(currentSac)
            .map(([branch, _val]) => branch)
            .filter((branch) => {
                if (parentList.includes(branch)) {
                    return branch;
                }
            });
        const nearestParentWithValue =
            parentListWithValue.length > 0
                ? Object.entries(currentSac)
                      .map(([branch, _val]) => branch)
                      .filter((branch) => {
                          if (parentList.includes(branch)) {
                              return branch;
                          }
                      })
                      .reduce((a, b2) => {
                          return a.length >= b2.length ? a : b2;
                      })
                : "";
        if (currentSac[nearestParentWithValue] === event.target.value) {
            update2({ type: 2, payload: { treeStr, newValue: null } });
        } else {
            update2({ type: 2, payload: { treeStr, newValue: event.target.value } });
        }
        src.children.forEach((srcNode) => {
            update2({ type: 2, payload: { treeStr: srcNode.treeStr, newValue: null } });
        });
    };
    const handleCheckedAll = (fieldname) => (event) => update2({ type: 4, payload: { fieldname, value: event.target.checked } });
    const handleNewBlenderNumber = (event) => update2({ type: 5, payload: parseInt(event.target.value.replace(/\D/g, "")) });
    function validateProfileName(profileName) {
        const issues2 = createCustomIssues(ProfileSchema);
        if (unwrappedProfiles.reduce((acc, p2) => acc || (acc = p2.name === profileName), false)) {
            issues2.name(`Profile name ${profileName} is already in use`);
        }
        return {
            issues: issues2.toArray(),
        };
    }
    const saveProfiles = () => {
        void saveProfile(profileModel.profileForm, create ? 0 : 1, updateModel, update2);
    };
    const fieldsFromSource = (source) => {
        let fields = [source.schemaType];
        if (source.group) {
            fields = fields.concat(source.group.split("/"));
        }
        return fields.concat(source.name);
    };
    const generateSourcesTree = () => {
        const sourcesTree = [];
        let index = 0;
        sources.forEach((source) => {
            let currentTree = sourcesTree;
            const tree = [];
            fieldsFromSource(source).forEach((field) => {
                tree.push(field);
                let root2 = currentTree.find((key) => key.name == field);
                if (root2 === void 0) {
                    root2 = {
                        name: field,
                        children: [],
                        index,
                        source,
                        treeStr: tree.join("/"),
                    };
                    currentTree.push(root2);
                }
                index = index + 1;
                currentTree = root2.children;
            });
        });
        return sourcesTree;
    };
    const displayFormTree = (sourcesTree) => {
        if (!sourcesTree) {
            return;
        }
        return sourcesTree.map((source) => {
            const sourcesAccessControlList = Object.entries(profileModel.profileForm.sourcesAccessControl);
            const availableSourcesAccessControl = sourcesAccessControlList.map(([sac, _val]) => {
                return sac;
            });
            const matchingAccessControls = availableSourcesAccessControl
                .map((path) => {
                    if (source.treeStr === path || source.treeStr.startsWith(`${path}/`)) {
                        return path;
                    } else {
                        return null;
                    }
                })
                .filter((elem) => elem != null);
            let accessControlValue = null;
            if (matchingAccessControls.length > 0) {
                const matchingAccessControl = matchingAccessControls.reduce((a, b2) => {
                    return a.length >= b2.length ? a : b2;
                });
                accessControlValue = profileModel.profileForm.sourcesAccessControl[matchingAccessControl];
            }
            const value = accessControlValue ? accessControlValue : "forbidden";
            return /* @__PURE__ */ jsxRuntimeExports.jsx(
                CustomTreeItem,
                {
                    nodeId: source.treeStr,
                    label: /* @__PURE__ */ jsxRuntimeExports.jsxs(Grid$1, {
                        container: true,
                        alignItems: "center",
                        spacing: 2,
                        children: [
                            /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, {
                                item: true,
                                xs: true,
                                children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { margin: 0 }, children: source.name }),
                            }),
                            /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, {
                                item: true,
                                xs: "auto",
                                children: /* @__PURE__ */ jsxRuntimeExports.jsxs(FormControl$1, {
                                    sx: { m: 1, minWidth: 120 },
                                    size: "small",
                                    children: [
                                        /* @__PURE__ */ jsxRuntimeExports.jsx(InputLabel$1, { id: "select-sources-access-control", children: "Access Control" }),
                                        /* @__PURE__ */ jsxRuntimeExports.jsxs(Select$1, {
                                            labelId: "select-sources-access-control",
                                            id: "select-sources-access-control-select",
                                            value,
                                            label: "AccessControl",
                                            onChange: handleSourceAccessControlUpdate(source),
                                            children: [
                                                /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem$1, { value: "forbidden", children: "Forbidden" }),
                                                /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem$1, { value: "read", children: "Read" }),
                                                /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem$1, { value: "readwrite", children: "Read & Write" }),
                                            ],
                                        }),
                                    ],
                                }),
                            }),
                        ],
                    }),
                    children: displayFormTree(source.children),
                },
                source.index.toString()
            );
        });
    };
    function SourcesTreeView() {
        const treeviewSources = displayFormTree(generateSourcesTree());
        return /* @__PURE__ */ jsxRuntimeExports.jsx(TreeView$1, {
            "aria-label": "Sources access control navigator",
            id: "sources-access-treeview",
            defaultExpanded: Array.from(nodesClicked),
            onNodeToggle: (_event, nodeIds) => {
                setNodeToExpand(nodeIds);
            },
            defaultCollapseIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$2, { sx: { width: 30, height: 30 } }),
            defaultExpandIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$1, { sx: { width: 30, height: 30 } }),
            children: treeviewSources,
        });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
        children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { variant: "contained", color: "primary", onClick: handleOpen, children: create ? "Create Profile" : "Edit" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Modal$1, {
                onClose: handleClose,
                open: profileModel.modal,
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(Box$1, {
                    component: "form",
                    ref: zo.ref,
                    onSubmit: (e2) => {
                        const validation = zo.validate();
                        if (!validation.success) {
                            e2.preventDefault();
                            console.error("error", e2);
                            return;
                        }
                        e2.preventDefault();
                        saveProfiles();
                    },
                    sx: style,
                    style: { maxHeight: "100%", overflow: "auto" },
                    children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack$1, {
                        spacing: 4,
                        children: [
                            /* @__PURE__ */ jsxRuntimeExports.jsx(TextField$1, {
                                name: zo.fields.name(),
                                helperText: errorMessage(zo.errors.name),
                                fullWidth: true,
                                onChange: handleFieldUpdate("name"),
                                onBlur: () => {
                                    zo.validate();
                                    const isUniq = validateProfileName(profileModel.profileForm.name);
                                    setIssues(isUniq.issues);
                                },
                                value: profileModel.profileForm.name,
                                id: `name`,
                                label: "Name",
                                variant: "standard",
                            }),
                            /* @__PURE__ */ jsxRuntimeExports.jsx(TextField$1, {
                                name: zo.fields.blender.contextMenuActionStartLevel(),
                                helperText: errorMessage(zo.errors.blender.contextMenuActionStartLevel),
                                fullWidth: true,
                                onChange: handleNewBlenderNumber,
                                onBlur: () => zo.validate(),
                                value: profileModel.profileForm.blender.contextMenuActionStartLevel.toString(),
                                id: `blender`,
                                label: "Blender Level",
                                variant: "standard",
                            }),
                            /* @__PURE__ */ jsxRuntimeExports.jsxs(FormControl$1, {
                                children: [
                                    /* @__PURE__ */ jsxRuntimeExports.jsx(InputLabel$1, { id: "allowedSourceSchemas-label", children: "Allowed Source Schemas" }),
                                    /* @__PURE__ */ jsxRuntimeExports.jsx(Select$1, {
                                        labelId: "allowedSourceSchemas-label",
                                        id: "allowedSourceSchemas",
                                        multiple: true,
                                        value: profileModel.profileForm.allowedSourceSchemas,
                                        label: "select-groups-label",
                                        fullWidth: true,
                                        renderValue: (selected) => (typeof selected === "string" ? selected : selected.join(", ")),
                                        onChange: handleFieldUpdate("allowedSourceSchemas"),
                                        children: schemaTypes.map((schemaType, i) =>
                                            /* @__PURE__ */ jsxRuntimeExports.jsxs(
                                                MenuItem$1,
                                                {
                                                    value: schemaType,
                                                    children: [
                                                        /* @__PURE__ */ jsxRuntimeExports.jsx(Checkbox$1, {
                                                            id: zo.fields.allowedSourceSchemas(i)("id"),
                                                            name: zo.fields.allowedSourceSchemas(i)("name"),
                                                            checked: profileModel.profileForm.allowedSourceSchemas.indexOf(schemaType) > -1,
                                                        }),
                                                        schemaType,
                                                    ],
                                                },
                                                schemaType
                                            )
                                        ),
                                    }),
                                ],
                            }),
                            /* @__PURE__ */ jsxRuntimeExports.jsx(Box$1, {
                                style: { maxHeight: "300px", overflow: "auto" },
                                children: /* @__PURE__ */ jsxRuntimeExports.jsxs(FormControl$1, {
                                    children: [
                                        /* @__PURE__ */ jsxRuntimeExports.jsx(FormLabel$1, { id: "default-source-access-control-label", children: "Default source access control" }),
                                        /* @__PURE__ */ jsxRuntimeExports.jsx(SourcesTreeView, {}),
                                    ],
                                }),
                            }),
                            /* @__PURE__ */ jsxRuntimeExports.jsxs(FormGroup$1, {
                                children: [
                                    /* @__PURE__ */ jsxRuntimeExports.jsx(FormControlLabel$1, {
                                        control: /* @__PURE__ */ jsxRuntimeExports.jsx(Checkbox$1, {
                                            onChange: handleCheckedAll("allowedTools"),
                                            checked: profileModel.profileForm.allowedTools === "ALL",
                                        }),
                                        label: "Allow all tools",
                                    }),
                                    /* @__PURE__ */ jsxRuntimeExports.jsxs(FormControl$1, {
                                        style: { display: profileModel.profileForm.allowedTools === "ALL" ? "none" : "" },
                                        disabled: profileModel.profileForm.allowedTools === "ALL",
                                        children: [
                                            /* @__PURE__ */ jsxRuntimeExports.jsx(InputLabel$1, { id: "allowedTools-label", children: "Allowed tools" }),
                                            /* @__PURE__ */ jsxRuntimeExports.jsx(Select$1, {
                                                labelId: "allowedTools-label",
                                                id: "allowedTools",
                                                multiple: true,
                                                value: !Array.isArray(profileModel.profileForm.allowedTools) ? [] : profileModel.profileForm.allowedTools,
                                                label: "select-allowedTools-label",
                                                renderValue: (selected) => (typeof selected === "string" ? selected : selected.join(", ")),
                                                onChange: handleFieldUpdate("allowedTools"),
                                                children: tools.map((tool) => /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem$1, { value: tool, children: tool }, tool)),
                                            }),
                                        ],
                                    }),
                                ],
                            }),
                            /* @__PURE__ */ jsxRuntimeExports.jsxs(FormControl$1, {
                                children: [
                                    /* @__PURE__ */ jsxRuntimeExports.jsx(InputLabel$1, { id: "forbiddenTools-label", children: "Forbidden tools" }),
                                    /* @__PURE__ */ jsxRuntimeExports.jsx(Select$1, {
                                        labelId: "forbiddenTools-label",
                                        id: "forbiddenTools",
                                        multiple: true,
                                        value: !Array.isArray(profileModel.profileForm.forbiddenTools) ? [] : profileModel.profileForm.forbiddenTools,
                                        label: "select-forbiddenTools-label",
                                        fullWidth: true,
                                        renderValue: (selected) => (typeof selected === "string" ? selected : selected.join(", ")),
                                        onChange: handleFieldUpdate("forbiddenTools"),
                                        children: tools.map((tool) =>
                                            /* @__PURE__ */ jsxRuntimeExports.jsxs(
                                                MenuItem$1,
                                                {
                                                    value: tool,
                                                    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(Checkbox$1, { checked: profileModel.profileForm.forbiddenTools.indexOf(tool) > -1 }), tool],
                                                },
                                                tool
                                            )
                                        ),
                                    }),
                                ],
                            }),
                            /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, {
                                disabled: ((_a = zo.validation) == null ? void 0 : _a.success) === false || zo.customIssues.length > 0,
                                type: "submit",
                                variant: "contained",
                                color: "primary",
                                children: "Save Profile",
                            }),
                        ],
                    }),
                }),
            }),
        ],
    });
};
const CustomContent = reactExports.forwardRef(function CustomContent2(props, ref) {
    const { classes, className, label, nodeId, icon: iconProp, expansionIcon, displayIcon } = props;
    const { disabled, expanded, selected, focused, handleExpansion, handleSelection, preventSelection } = useTreeItem(nodeId);
    const icon = iconProp || expansionIcon || displayIcon;
    const handleMouseDown = (event) => {
        preventSelection(event);
    };
    const handleExpansionClick = (event) => {
        handleExpansion(event);
    };
    const handleSelectionClick = (event) => {
        handleSelection(event);
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
        className: clsx$1(className, classes.root, {
            [classes.expanded]: expanded,
            [classes.selected]: selected,
            [classes.focused]: focused,
            [classes.disabled]: disabled,
        }),
        onMouseDown: handleMouseDown,
        ref,
        children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(CustomExpansionArrow, { onClick: handleExpansionClick, className: classes.iconContainer, children: icon }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { onClick: handleSelectionClick, component: "div", className: classes.label, children: label }),
        ],
    });
});
const expansionArrowStyles = {
    "&:hover": { backgroundColor: "#E4F2FF !important" },
    padding: "1em",
};
const CustomExpansionArrow = styled$1("div")(expansionArrowStyles);
function CustomTreeItem(props) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(TreeItem$1, { ContentComponent: CustomContent, ...props });
}
var util;
(function (util2) {
    util2.assertEqual = (val) => val;
    function assertIs(_arg) {}
    util2.assertIs = assertIs;
    function assertNever(_x) {
        throw new Error();
    }
    util2.assertNever = assertNever;
    util2.arrayToEnum = (items) => {
        const obj = {};
        for (const item of items) {
            obj[item] = item;
        }
        return obj;
    };
    util2.getValidEnumValues = (obj) => {
        const validKeys = util2.objectKeys(obj).filter((k2) => typeof obj[obj[k2]] !== "number");
        const filtered = {};
        for (const k2 of validKeys) {
            filtered[k2] = obj[k2];
        }
        return util2.objectValues(filtered);
    };
    util2.objectValues = (obj) => {
        return util2.objectKeys(obj).map(function (e2) {
            return obj[e2];
        });
    };
    util2.objectKeys =
        typeof Object.keys === "function"
            ? (obj) => Object.keys(obj)
            : (object) => {
                  const keys = [];
                  for (const key in object) {
                      if (Object.prototype.hasOwnProperty.call(object, key)) {
                          keys.push(key);
                      }
                  }
                  return keys;
              };
    util2.find = (arr, checker) => {
        for (const item of arr) {
            if (checker(item)) return item;
        }
        return void 0;
    };
    util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
    function joinValues(array, separator = " | ") {
        return array.map((val) => (typeof val === "string" ? `'${val}'` : val)).join(separator);
    }
    util2.joinValues = joinValues;
    util2.jsonStringifyReplacer = (_2, value) => {
        if (typeof value === "bigint") {
            return value.toString();
        }
        return value;
    };
})(util || (util = {}));
var objectUtil;
(function (objectUtil2) {
    objectUtil2.mergeShapes = (first, second) => {
        return {
            ...first,
            ...second,
            // second overwrites first
        };
    };
})(objectUtil || (objectUtil = {}));
const ZodParsedType = util.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set",
]);
const getParsedType = (data) => {
    const t2 = typeof data;
    switch (t2) {
        case "undefined":
            return ZodParsedType.undefined;
        case "string":
            return ZodParsedType.string;
        case "number":
            return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
        case "boolean":
            return ZodParsedType.boolean;
        case "function":
            return ZodParsedType.function;
        case "bigint":
            return ZodParsedType.bigint;
        case "symbol":
            return ZodParsedType.symbol;
        case "object":
            if (Array.isArray(data)) {
                return ZodParsedType.array;
            }
            if (data === null) {
                return ZodParsedType.null;
            }
            if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
                return ZodParsedType.promise;
            }
            if (typeof Map !== "undefined" && data instanceof Map) {
                return ZodParsedType.map;
            }
            if (typeof Set !== "undefined" && data instanceof Set) {
                return ZodParsedType.set;
            }
            if (typeof Date !== "undefined" && data instanceof Date) {
                return ZodParsedType.date;
            }
            return ZodParsedType.object;
        default:
            return ZodParsedType.unknown;
    }
};
const ZodIssueCode = util.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite",
]);
const quotelessJson = (obj) => {
    const json = JSON.stringify(obj, null, 2);
    return json.replace(/"([^"]+)":/g, "$1:");
};
class ZodError extends Error {
    constructor(issues) {
        super();
        this.issues = [];
        this.addIssue = (sub) => {
            this.issues = [...this.issues, sub];
        };
        this.addIssues = (subs = []) => {
            this.issues = [...this.issues, ...subs];
        };
        const actualProto = new.target.prototype;
        if (Object.setPrototypeOf) {
            Object.setPrototypeOf(this, actualProto);
        } else {
            this.__proto__ = actualProto;
        }
        this.name = "ZodError";
        this.issues = issues;
    }
    get errors() {
        return this.issues;
    }
    format(_mapper) {
        const mapper =
            _mapper ||
            function (issue) {
                return issue.message;
            };
        const fieldErrors = { _errors: [] };
        const processError = (error) => {
            for (const issue of error.issues) {
                if (issue.code === "invalid_union") {
                    issue.unionErrors.map(processError);
                } else if (issue.code === "invalid_return_type") {
                    processError(issue.returnTypeError);
                } else if (issue.code === "invalid_arguments") {
                    processError(issue.argumentsError);
                } else if (issue.path.length === 0) {
                    fieldErrors._errors.push(mapper(issue));
                } else {
                    let curr = fieldErrors;
                    let i = 0;
                    while (i < issue.path.length) {
                        const el = issue.path[i];
                        const terminal = i === issue.path.length - 1;
                        if (!terminal) {
                            curr[el] = curr[el] || { _errors: [] };
                        } else {
                            curr[el] = curr[el] || { _errors: [] };
                            curr[el]._errors.push(mapper(issue));
                        }
                        curr = curr[el];
                        i++;
                    }
                }
            }
        };
        processError(this);
        return fieldErrors;
    }
    toString() {
        return this.message;
    }
    get message() {
        return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
    }
    get isEmpty() {
        return this.issues.length === 0;
    }
    flatten(mapper = (issue) => issue.message) {
        const fieldErrors = {};
        const formErrors = [];
        for (const sub of this.issues) {
            if (sub.path.length > 0) {
                fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
                fieldErrors[sub.path[0]].push(mapper(sub));
            } else {
                formErrors.push(mapper(sub));
            }
        }
        return { formErrors, fieldErrors };
    }
    get formErrors() {
        return this.flatten();
    }
}
ZodError.create = (issues) => {
    const error = new ZodError(issues);
    return error;
};
const errorMap = (issue, _ctx) => {
    let message;
    switch (issue.code) {
        case ZodIssueCode.invalid_type:
            if (issue.received === ZodParsedType.undefined) {
                message = "Required";
            } else {
                message = `Expected ${issue.expected}, received ${issue.received}`;
            }
            break;
        case ZodIssueCode.invalid_literal:
            message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
            break;
        case ZodIssueCode.unrecognized_keys:
            message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
            break;
        case ZodIssueCode.invalid_union:
            message = `Invalid input`;
            break;
        case ZodIssueCode.invalid_union_discriminator:
            message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
            break;
        case ZodIssueCode.invalid_enum_value:
            message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
            break;
        case ZodIssueCode.invalid_arguments:
            message = `Invalid function arguments`;
            break;
        case ZodIssueCode.invalid_return_type:
            message = `Invalid function return type`;
            break;
        case ZodIssueCode.invalid_date:
            message = `Invalid date`;
            break;
        case ZodIssueCode.invalid_string:
            if (typeof issue.validation === "object") {
                if ("includes" in issue.validation) {
                    message = `Invalid input: must include "${issue.validation.includes}"`;
                    if (typeof issue.validation.position === "number") {
                        message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
                    }
                } else if ("startsWith" in issue.validation) {
                    message = `Invalid input: must start with "${issue.validation.startsWith}"`;
                } else if ("endsWith" in issue.validation) {
                    message = `Invalid input: must end with "${issue.validation.endsWith}"`;
                } else {
                    util.assertNever(issue.validation);
                }
            } else if (issue.validation !== "regex") {
                message = `Invalid ${issue.validation}`;
            } else {
                message = "Invalid";
            }
            break;
        case ZodIssueCode.too_small:
            if (issue.type === "array") message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
            else if (issue.type === "string") message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
            else if (issue.type === "number") message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
            else if (issue.type === "date")
                message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
            else message = "Invalid input";
            break;
        case ZodIssueCode.too_big:
            if (issue.type === "array") message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
            else if (issue.type === "string") message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
            else if (issue.type === "number") message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
            else if (issue.type === "bigint") message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
            else if (issue.type === "date") message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
            else message = "Invalid input";
            break;
        case ZodIssueCode.custom:
            message = `Invalid input`;
            break;
        case ZodIssueCode.invalid_intersection_types:
            message = `Intersection results could not be merged`;
            break;
        case ZodIssueCode.not_multiple_of:
            message = `Number must be a multiple of ${issue.multipleOf}`;
            break;
        case ZodIssueCode.not_finite:
            message = "Number must be finite";
            break;
        default:
            message = _ctx.defaultError;
            util.assertNever(issue);
    }
    return { message };
};
let overrideErrorMap = errorMap;
function setErrorMap(map) {
    overrideErrorMap = map;
}
function getErrorMap() {
    return overrideErrorMap;
}
const makeIssue = (params) => {
    const { data, path, errorMaps, issueData } = params;
    const fullPath = [...path, ...(issueData.path || [])];
    const fullIssue = {
        ...issueData,
        path: fullPath,
    };
    let errorMessage2 = "";
    const maps = errorMaps
        .filter((m2) => !!m2)
        .slice()
        .reverse();
    for (const map of maps) {
        errorMessage2 = map(fullIssue, { data, defaultError: errorMessage2 }).message;
    }
    return {
        ...issueData,
        path: fullPath,
        message: issueData.message || errorMessage2,
    };
};
const EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
    const issue = makeIssue({
        issueData,
        data: ctx.data,
        path: ctx.path,
        errorMaps: [
            ctx.common.contextualErrorMap,
            ctx.schemaErrorMap,
            getErrorMap(),
            errorMap,
            // then global default map
        ].filter((x2) => !!x2),
    });
    ctx.common.issues.push(issue);
}
class ParseStatus {
    constructor() {
        this.value = "valid";
    }
    dirty() {
        if (this.value === "valid") this.value = "dirty";
    }
    abort() {
        if (this.value !== "aborted") this.value = "aborted";
    }
    static mergeArray(status, results) {
        const arrayValue = [];
        for (const s of results) {
            if (s.status === "aborted") return INVALID;
            if (s.status === "dirty") status.dirty();
            arrayValue.push(s.value);
        }
        return { status: status.value, value: arrayValue };
    }
    static async mergeObjectAsync(status, pairs) {
        const syncPairs = [];
        for (const pair of pairs) {
            syncPairs.push({
                key: await pair.key,
                value: await pair.value,
            });
        }
        return ParseStatus.mergeObjectSync(status, syncPairs);
    }
    static mergeObjectSync(status, pairs) {
        const finalObject = {};
        for (const pair of pairs) {
            const { key, value } = pair;
            if (key.status === "aborted") return INVALID;
            if (value.status === "aborted") return INVALID;
            if (key.status === "dirty") status.dirty();
            if (value.status === "dirty") status.dirty();
            if (typeof value.value !== "undefined" || pair.alwaysSet) {
                finalObject[key.value] = value.value;
            }
        }
        return { status: status.value, value: finalObject };
    }
}
const INVALID = Object.freeze({
    status: "aborted",
});
const DIRTY = (value) => ({ status: "dirty", value });
const OK = (value) => ({ status: "valid", value });
const isAborted = (x2) => x2.status === "aborted";
const isDirty = (x2) => x2.status === "dirty";
const isValid = (x2) => x2.status === "valid";
const isAsync = (x2) => typeof Promise !== "undefined" && x2 instanceof Promise;
var errorUtil;
(function (errorUtil2) {
    errorUtil2.errToObj = (message) => (typeof message === "string" ? { message } : message || {});
    errorUtil2.toString = (message) => (typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message);
})(errorUtil || (errorUtil = {}));
class ParseInputLazyPath {
    constructor(parent, value, path, key) {
        this._cachedPath = [];
        this.parent = parent;
        this.data = value;
        this._path = path;
        this._key = key;
    }
    get path() {
        if (!this._cachedPath.length) {
            if (this._key instanceof Array) {
                this._cachedPath.push(...this._path, ...this._key);
            } else {
                this._cachedPath.push(...this._path, this._key);
            }
        }
        return this._cachedPath;
    }
}
const handleResult = (ctx, result) => {
    if (isValid(result)) {
        return { success: true, data: result.value };
    } else {
        if (!ctx.common.issues.length) {
            throw new Error("Validation failed but no issues detected.");
        }
        return {
            success: false,
            get error() {
                if (this._error) return this._error;
                const error = new ZodError(ctx.common.issues);
                this._error = error;
                return this._error;
            },
        };
    }
};
function processCreateParams(params) {
    if (!params) return {};
    const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
    if (errorMap2 && (invalid_type_error || required_error)) {
        throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    }
    if (errorMap2) return { errorMap: errorMap2, description };
    const customMap = (iss, ctx) => {
        if (iss.code !== "invalid_type") return { message: ctx.defaultError };
        if (typeof ctx.data === "undefined") {
            return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };
        }
        return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };
    };
    return { errorMap: customMap, description };
}
class ZodType {
    constructor(def) {
        this.spa = this.safeParseAsync;
        this._def = def;
        this.parse = this.parse.bind(this);
        this.safeParse = this.safeParse.bind(this);
        this.parseAsync = this.parseAsync.bind(this);
        this.safeParseAsync = this.safeParseAsync.bind(this);
        this.spa = this.spa.bind(this);
        this.refine = this.refine.bind(this);
        this.refinement = this.refinement.bind(this);
        this.superRefine = this.superRefine.bind(this);
        this.optional = this.optional.bind(this);
        this.nullable = this.nullable.bind(this);
        this.nullish = this.nullish.bind(this);
        this.array = this.array.bind(this);
        this.promise = this.promise.bind(this);
        this.or = this.or.bind(this);
        this.and = this.and.bind(this);
        this.transform = this.transform.bind(this);
        this.brand = this.brand.bind(this);
        this.default = this.default.bind(this);
        this.catch = this.catch.bind(this);
        this.describe = this.describe.bind(this);
        this.pipe = this.pipe.bind(this);
        this.isNullable = this.isNullable.bind(this);
        this.isOptional = this.isOptional.bind(this);
    }
    get description() {
        return this._def.description;
    }
    _getType(input) {
        return getParsedType(input.data);
    }
    _getOrReturnCtx(input, ctx) {
        return (
            ctx || {
                common: input.parent.common,
                data: input.data,
                parsedType: getParsedType(input.data),
                schemaErrorMap: this._def.errorMap,
                path: input.path,
                parent: input.parent,
            }
        );
    }
    _processInputParams(input) {
        return {
            status: new ParseStatus(),
            ctx: {
                common: input.parent.common,
                data: input.data,
                parsedType: getParsedType(input.data),
                schemaErrorMap: this._def.errorMap,
                path: input.path,
                parent: input.parent,
            },
        };
    }
    _parseSync(input) {
        const result = this._parse(input);
        if (isAsync(result)) {
            throw new Error("Synchronous parse encountered promise.");
        }
        return result;
    }
    _parseAsync(input) {
        const result = this._parse(input);
        return Promise.resolve(result);
    }
    parse(data, params) {
        const result = this.safeParse(data, params);
        if (result.success) return result.data;
        throw result.error;
    }
    safeParse(data, params) {
        var _a;
        const ctx = {
            common: {
                issues: [],
                async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
            },
            path: (params === null || params === void 0 ? void 0 : params.path) || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data,
            parsedType: getParsedType(data),
        };
        const result = this._parseSync({ data, path: ctx.path, parent: ctx });
        return handleResult(ctx, result);
    }
    async parseAsync(data, params) {
        const result = await this.safeParseAsync(data, params);
        if (result.success) return result.data;
        throw result.error;
    }
    async safeParseAsync(data, params) {
        const ctx = {
            common: {
                issues: [],
                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
                async: true,
            },
            path: (params === null || params === void 0 ? void 0 : params.path) || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data,
            parsedType: getParsedType(data),
        };
        const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
        const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
        return handleResult(ctx, result);
    }
    refine(check, message) {
        const getIssueProperties = (val) => {
            if (typeof message === "string" || typeof message === "undefined") {
                return { message };
            } else if (typeof message === "function") {
                return message(val);
            } else {
                return message;
            }
        };
        return this._refinement((val, ctx) => {
            const result = check(val);
            const setError = () =>
                ctx.addIssue({
                    code: ZodIssueCode.custom,
                    ...getIssueProperties(val),
                });
            if (typeof Promise !== "undefined" && result instanceof Promise) {
                return result.then((data) => {
                    if (!data) {
                        setError();
                        return false;
                    } else {
                        return true;
                    }
                });
            }
            if (!result) {
                setError();
                return false;
            } else {
                return true;
            }
        });
    }
    refinement(check, refinementData) {
        return this._refinement((val, ctx) => {
            if (!check(val)) {
                ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
                return false;
            } else {
                return true;
            }
        });
    }
    _refinement(refinement) {
        return new ZodEffects({
            schema: this,
            typeName: ZodFirstPartyTypeKind.ZodEffects,
            effect: { type: "refinement", refinement },
        });
    }
    superRefine(refinement) {
        return this._refinement(refinement);
    }
    optional() {
        return ZodOptional.create(this, this._def);
    }
    nullable() {
        return ZodNullable.create(this, this._def);
    }
    nullish() {
        return this.nullable().optional();
    }
    array() {
        return ZodArray.create(this, this._def);
    }
    promise() {
        return ZodPromise.create(this, this._def);
    }
    or(option) {
        return ZodUnion.create([this, option], this._def);
    }
    and(incoming) {
        return ZodIntersection.create(this, incoming, this._def);
    }
    transform(transform) {
        return new ZodEffects({
            ...processCreateParams(this._def),
            schema: this,
            typeName: ZodFirstPartyTypeKind.ZodEffects,
            effect: { type: "transform", transform },
        });
    }
    default(def) {
        const defaultValueFunc = typeof def === "function" ? def : () => def;
        return new ZodDefault({
            ...processCreateParams(this._def),
            innerType: this,
            defaultValue: defaultValueFunc,
            typeName: ZodFirstPartyTypeKind.ZodDefault,
        });
    }
    brand() {
        return new ZodBranded({
            typeName: ZodFirstPartyTypeKind.ZodBranded,
            type: this,
            ...processCreateParams(this._def),
        });
    }
    catch(def) {
        const catchValueFunc = typeof def === "function" ? def : () => def;
        return new ZodCatch({
            ...processCreateParams(this._def),
            innerType: this,
            catchValue: catchValueFunc,
            typeName: ZodFirstPartyTypeKind.ZodCatch,
        });
    }
    describe(description) {
        const This = this.constructor;
        return new This({
            ...this._def,
            description,
        });
    }
    pipe(target) {
        return ZodPipeline.create(this, target);
    }
    isOptional() {
        return this.safeParse(void 0).success;
    }
    isNullable() {
        return this.safeParse(null).success;
    }
}
const cuidRegex = /^c[^\s-]{8,}$/i;
const cuid2Regex = /^[a-z][a-z0-9]*$/;
const ulidRegex = /[0-9A-HJKMNP-TV-Z]{26}/;
const uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
const emailRegex =
    /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\])|(\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\.[A-Za-z]{2,})+))$/;
const emojiRegex = /^(\p{Extended_Pictographic}|\p{Emoji_Component})+$/u;
const ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
const ipv6Regex =
    /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
const datetimeRegex = (args) => {
    if (args.precision) {
        if (args.offset) {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
        } else {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z$`);
        }
    } else if (args.precision === 0) {
        if (args.offset) {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
        } else {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$`);
        }
    } else {
        if (args.offset) {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
        } else {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$`);
        }
    }
};
function isValidIP(ip, version) {
    if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
        return true;
    }
    if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
        return true;
    }
    return false;
}
class ZodString extends ZodType {
    constructor() {
        super(...arguments);
        this._regex = (regex, validation, message) =>
            this.refinement((data) => regex.test(data), {
                validation,
                code: ZodIssueCode.invalid_string,
                ...errorUtil.errToObj(message),
            });
        this.nonempty = (message) => this.min(1, errorUtil.errToObj(message));
        this.trim = () =>
            new ZodString({
                ...this._def,
                checks: [...this._def.checks, { kind: "trim" }],
            });
        this.toLowerCase = () =>
            new ZodString({
                ...this._def,
                checks: [...this._def.checks, { kind: "toLowerCase" }],
            });
        this.toUpperCase = () =>
            new ZodString({
                ...this._def,
                checks: [...this._def.checks, { kind: "toUpperCase" }],
            });
    }
    _parse(input) {
        if (this._def.coerce) {
            input.data = String(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.string) {
            const ctx2 = this._getOrReturnCtx(input);
            addIssueToContext(
                ctx2,
                {
                    code: ZodIssueCode.invalid_type,
                    expected: ZodParsedType.string,
                    received: ctx2.parsedType,
                }
                //
            );
            return INVALID;
        }
        const status = new ParseStatus();
        let ctx = void 0;
        for (const check of this._def.checks) {
            if (check.kind === "min") {
                if (input.data.length < check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_small,
                        minimum: check.value,
                        type: "string",
                        inclusive: true,
                        exact: false,
                        message: check.message,
                    });
                    status.dirty();
                }
            } else if (check.kind === "max") {
                if (input.data.length > check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_big,
                        maximum: check.value,
                        type: "string",
                        inclusive: true,
                        exact: false,
                        message: check.message,
                    });
                    status.dirty();
                }
            } else if (check.kind === "length") {
                const tooBig = input.data.length > check.value;
                const tooSmall = input.data.length < check.value;
                if (tooBig || tooSmall) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    if (tooBig) {
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_big,
                            maximum: check.value,
                            type: "string",
                            inclusive: true,
                            exact: true,
                            message: check.message,
                        });
                    } else if (tooSmall) {
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_small,
                            minimum: check.value,
                            type: "string",
                            inclusive: true,
                            exact: true,
                            message: check.message,
                        });
                    }
                    status.dirty();
                }
            } else if (check.kind === "email") {
                if (!emailRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "email",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            } else if (check.kind === "emoji") {
                if (!emojiRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "emoji",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            } else if (check.kind === "uuid") {
                if (!uuidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "uuid",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            } else if (check.kind === "cuid") {
                if (!cuidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "cuid",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            } else if (check.kind === "cuid2") {
                if (!cuid2Regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "cuid2",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            } else if (check.kind === "ulid") {
                if (!ulidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "ulid",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            } else if (check.kind === "url") {
                try {
                    new URL(input.data);
                } catch (_a) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "url",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            } else if (check.kind === "regex") {
                check.regex.lastIndex = 0;
                const testResult = check.regex.test(input.data);
                if (!testResult) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "regex",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            } else if (check.kind === "trim") {
                input.data = input.data.trim();
            } else if (check.kind === "includes") {
                if (!input.data.includes(check.value, check.position)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_string,
                        validation: { includes: check.value, position: check.position },
                        message: check.message,
                    });
                    status.dirty();
                }
            } else if (check.kind === "toLowerCase") {
                input.data = input.data.toLowerCase();
            } else if (check.kind === "toUpperCase") {
                input.data = input.data.toUpperCase();
            } else if (check.kind === "startsWith") {
                if (!input.data.startsWith(check.value)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_string,
                        validation: { startsWith: check.value },
                        message: check.message,
                    });
                    status.dirty();
                }
            } else if (check.kind === "endsWith") {
                if (!input.data.endsWith(check.value)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_string,
                        validation: { endsWith: check.value },
                        message: check.message,
                    });
                    status.dirty();
                }
            } else if (check.kind === "datetime") {
                const regex = datetimeRegex(check);
                if (!regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_string,
                        validation: "datetime",
                        message: check.message,
                    });
                    status.dirty();
                }
            } else if (check.kind === "ip") {
                if (!isValidIP(input.data, check.version)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "ip",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            } else {
                util.assertNever(check);
            }
        }
        return { status: status.value, value: input.data };
    }
    _addCheck(check) {
        return new ZodString({
            ...this._def,
            checks: [...this._def.checks, check],
        });
    }
    email(message) {
        return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
    }
    url(message) {
        return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
    }
    emoji(message) {
        return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
    }
    uuid(message) {
        return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
    }
    cuid(message) {
        return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
    }
    cuid2(message) {
        return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
    }
    ulid(message) {
        return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
    }
    ip(options) {
        return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
    }
    datetime(options) {
        var _a;
        if (typeof options === "string") {
            return this._addCheck({
                kind: "datetime",
                precision: null,
                offset: false,
                message: options,
            });
        }
        return this._addCheck({
            kind: "datetime",
            precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
            offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
            ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message),
        });
    }
    regex(regex, message) {
        return this._addCheck({
            kind: "regex",
            regex,
            ...errorUtil.errToObj(message),
        });
    }
    includes(value, options) {
        return this._addCheck({
            kind: "includes",
            value,
            position: options === null || options === void 0 ? void 0 : options.position,
            ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message),
        });
    }
    startsWith(value, message) {
        return this._addCheck({
            kind: "startsWith",
            value,
            ...errorUtil.errToObj(message),
        });
    }
    endsWith(value, message) {
        return this._addCheck({
            kind: "endsWith",
            value,
            ...errorUtil.errToObj(message),
        });
    }
    min(minLength, message) {
        return this._addCheck({
            kind: "min",
            value: minLength,
            ...errorUtil.errToObj(message),
        });
    }
    max(maxLength, message) {
        return this._addCheck({
            kind: "max",
            value: maxLength,
            ...errorUtil.errToObj(message),
        });
    }
    length(len, message) {
        return this._addCheck({
            kind: "length",
            value: len,
            ...errorUtil.errToObj(message),
        });
    }
    get isDatetime() {
        return !!this._def.checks.find((ch) => ch.kind === "datetime");
    }
    get isEmail() {
        return !!this._def.checks.find((ch) => ch.kind === "email");
    }
    get isURL() {
        return !!this._def.checks.find((ch) => ch.kind === "url");
    }
    get isEmoji() {
        return !!this._def.checks.find((ch) => ch.kind === "emoji");
    }
    get isUUID() {
        return !!this._def.checks.find((ch) => ch.kind === "uuid");
    }
    get isCUID() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid");
    }
    get isCUID2() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid2");
    }
    get isULID() {
        return !!this._def.checks.find((ch) => ch.kind === "ulid");
    }
    get isIP() {
        return !!this._def.checks.find((ch) => ch.kind === "ip");
    }
    get minLength() {
        let min2 = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "min") {
                if (min2 === null || ch.value > min2) min2 = ch.value;
            }
        }
        return min2;
    }
    get maxLength() {
        let max2 = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "max") {
                if (max2 === null || ch.value < max2) max2 = ch.value;
            }
        }
        return max2;
    }
}
ZodString.create = (params) => {
    var _a;
    return new ZodString({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodString,
        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
        ...processCreateParams(params),
    });
};
function floatSafeRemainder(val, step) {
    const valDecCount = (val.toString().split(".")[1] || "").length;
    const stepDecCount = (step.toString().split(".")[1] || "").length;
    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
    const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
    const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
    return (valInt % stepInt) / Math.pow(10, decCount);
}
class ZodNumber extends ZodType {
    constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
        this.step = this.multipleOf;
    }
    _parse(input) {
        if (this._def.coerce) {
            input.data = Number(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.number) {
            const ctx2 = this._getOrReturnCtx(input);
            addIssueToContext(ctx2, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.number,
                received: ctx2.parsedType,
            });
            return INVALID;
        }
        let ctx = void 0;
        const status = new ParseStatus();
        for (const check of this._def.checks) {
            if (check.kind === "int") {
                if (!util.isInteger(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_type,
                        expected: "integer",
                        received: "float",
                        message: check.message,
                    });
                    status.dirty();
                }
            } else if (check.kind === "min") {
                const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
                if (tooSmall) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_small,
                        minimum: check.value,
                        type: "number",
                        inclusive: check.inclusive,
                        exact: false,
                        message: check.message,
                    });
                    status.dirty();
                }
            } else if (check.kind === "max") {
                const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
                if (tooBig) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_big,
                        maximum: check.value,
                        type: "number",
                        inclusive: check.inclusive,
                        exact: false,
                        message: check.message,
                    });
                    status.dirty();
                }
            } else if (check.kind === "multipleOf") {
                if (floatSafeRemainder(input.data, check.value) !== 0) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.not_multiple_of,
                        multipleOf: check.value,
                        message: check.message,
                    });
                    status.dirty();
                }
            } else if (check.kind === "finite") {
                if (!Number.isFinite(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.not_finite,
                        message: check.message,
                    });
                    status.dirty();
                }
            } else {
                util.assertNever(check);
            }
        }
        return { status: status.value, value: input.data };
    }
    gte(value, message) {
        return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
        return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
        return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
        return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
        return new ZodNumber({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind,
                    value,
                    inclusive,
                    message: errorUtil.toString(message),
                },
            ],
        });
    }
    _addCheck(check) {
        return new ZodNumber({
            ...this._def,
            checks: [...this._def.checks, check],
        });
    }
    int(message) {
        return this._addCheck({
            kind: "int",
            message: errorUtil.toString(message),
        });
    }
    positive(message) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: false,
            message: errorUtil.toString(message),
        });
    }
    negative(message) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: false,
            message: errorUtil.toString(message),
        });
    }
    nonpositive(message) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: true,
            message: errorUtil.toString(message),
        });
    }
    nonnegative(message) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: true,
            message: errorUtil.toString(message),
        });
    }
    multipleOf(value, message) {
        return this._addCheck({
            kind: "multipleOf",
            value,
            message: errorUtil.toString(message),
        });
    }
    finite(message) {
        return this._addCheck({
            kind: "finite",
            message: errorUtil.toString(message),
        });
    }
    safe(message) {
        return this._addCheck({
            kind: "min",
            inclusive: true,
            value: Number.MIN_SAFE_INTEGER,
            message: errorUtil.toString(message),
        })._addCheck({
            kind: "max",
            inclusive: true,
            value: Number.MAX_SAFE_INTEGER,
            message: errorUtil.toString(message),
        });
    }
    get minValue() {
        let min2 = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "min") {
                if (min2 === null || ch.value > min2) min2 = ch.value;
            }
        }
        return min2;
    }
    get maxValue() {
        let max2 = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "max") {
                if (max2 === null || ch.value < max2) max2 = ch.value;
            }
        }
        return max2;
    }
    get isInt() {
        return !!this._def.checks.find((ch) => ch.kind === "int" || (ch.kind === "multipleOf" && util.isInteger(ch.value)));
    }
    get isFinite() {
        let max2 = null,
            min2 = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
                return true;
            } else if (ch.kind === "min") {
                if (min2 === null || ch.value > min2) min2 = ch.value;
            } else if (ch.kind === "max") {
                if (max2 === null || ch.value < max2) max2 = ch.value;
            }
        }
        return Number.isFinite(min2) && Number.isFinite(max2);
    }
}
ZodNumber.create = (params) => {
    return new ZodNumber({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodNumber,
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        ...processCreateParams(params),
    });
};
class ZodBigInt extends ZodType {
    constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
    }
    _parse(input) {
        if (this._def.coerce) {
            input.data = BigInt(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.bigint) {
            const ctx2 = this._getOrReturnCtx(input);
            addIssueToContext(ctx2, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.bigint,
                received: ctx2.parsedType,
            });
            return INVALID;
        }
        let ctx = void 0;
        const status = new ParseStatus();
        for (const check of this._def.checks) {
            if (check.kind === "min") {
                const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
                if (tooSmall) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_small,
                        type: "bigint",
                        minimum: check.value,
                        inclusive: check.inclusive,
                        message: check.message,
                    });
                    status.dirty();
                }
            } else if (check.kind === "max") {
                const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
                if (tooBig) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_big,
                        type: "bigint",
                        maximum: check.value,
                        inclusive: check.inclusive,
                        message: check.message,
                    });
                    status.dirty();
                }
            } else if (check.kind === "multipleOf") {
                if (input.data % check.value !== BigInt(0)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.not_multiple_of,
                        multipleOf: check.value,
                        message: check.message,
                    });
                    status.dirty();
                }
            } else {
                util.assertNever(check);
            }
        }
        return { status: status.value, value: input.data };
    }
    gte(value, message) {
        return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
        return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
        return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
        return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
        return new ZodBigInt({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind,
                    value,
                    inclusive,
                    message: errorUtil.toString(message),
                },
            ],
        });
    }
    _addCheck(check) {
        return new ZodBigInt({
            ...this._def,
            checks: [...this._def.checks, check],
        });
    }
    positive(message) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: false,
            message: errorUtil.toString(message),
        });
    }
    negative(message) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: false,
            message: errorUtil.toString(message),
        });
    }
    nonpositive(message) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: true,
            message: errorUtil.toString(message),
        });
    }
    nonnegative(message) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: true,
            message: errorUtil.toString(message),
        });
    }
    multipleOf(value, message) {
        return this._addCheck({
            kind: "multipleOf",
            value,
            message: errorUtil.toString(message),
        });
    }
    get minValue() {
        let min2 = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "min") {
                if (min2 === null || ch.value > min2) min2 = ch.value;
            }
        }
        return min2;
    }
    get maxValue() {
        let max2 = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "max") {
                if (max2 === null || ch.value < max2) max2 = ch.value;
            }
        }
        return max2;
    }
}
ZodBigInt.create = (params) => {
    var _a;
    return new ZodBigInt({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodBigInt,
        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
        ...processCreateParams(params),
    });
};
class ZodBoolean extends ZodType {
    _parse(input) {
        if (this._def.coerce) {
            input.data = Boolean(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.boolean) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.boolean,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return OK(input.data);
    }
}
ZodBoolean.create = (params) => {
    return new ZodBoolean({
        typeName: ZodFirstPartyTypeKind.ZodBoolean,
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        ...processCreateParams(params),
    });
};
class ZodDate extends ZodType {
    _parse(input) {
        if (this._def.coerce) {
            input.data = new Date(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.date) {
            const ctx2 = this._getOrReturnCtx(input);
            addIssueToContext(ctx2, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.date,
                received: ctx2.parsedType,
            });
            return INVALID;
        }
        if (isNaN(input.data.getTime())) {
            const ctx2 = this._getOrReturnCtx(input);
            addIssueToContext(ctx2, {
                code: ZodIssueCode.invalid_date,
            });
            return INVALID;
        }
        const status = new ParseStatus();
        let ctx = void 0;
        for (const check of this._def.checks) {
            if (check.kind === "min") {
                if (input.data.getTime() < check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_small,
                        message: check.message,
                        inclusive: true,
                        exact: false,
                        minimum: check.value,
                        type: "date",
                    });
                    status.dirty();
                }
            } else if (check.kind === "max") {
                if (input.data.getTime() > check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_big,
                        message: check.message,
                        inclusive: true,
                        exact: false,
                        maximum: check.value,
                        type: "date",
                    });
                    status.dirty();
                }
            } else {
                util.assertNever(check);
            }
        }
        return {
            status: status.value,
            value: new Date(input.data.getTime()),
        };
    }
    _addCheck(check) {
        return new ZodDate({
            ...this._def,
            checks: [...this._def.checks, check],
        });
    }
    min(minDate, message) {
        return this._addCheck({
            kind: "min",
            value: minDate.getTime(),
            message: errorUtil.toString(message),
        });
    }
    max(maxDate, message) {
        return this._addCheck({
            kind: "max",
            value: maxDate.getTime(),
            message: errorUtil.toString(message),
        });
    }
    get minDate() {
        let min2 = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "min") {
                if (min2 === null || ch.value > min2) min2 = ch.value;
            }
        }
        return min2 != null ? new Date(min2) : null;
    }
    get maxDate() {
        let max2 = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "max") {
                if (max2 === null || ch.value < max2) max2 = ch.value;
            }
        }
        return max2 != null ? new Date(max2) : null;
    }
}
ZodDate.create = (params) => {
    return new ZodDate({
        checks: [],
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        typeName: ZodFirstPartyTypeKind.ZodDate,
        ...processCreateParams(params),
    });
};
class ZodSymbol extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.symbol) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.symbol,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return OK(input.data);
    }
}
ZodSymbol.create = (params) => {
    return new ZodSymbol({
        typeName: ZodFirstPartyTypeKind.ZodSymbol,
        ...processCreateParams(params),
    });
};
class ZodUndefined extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.undefined) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.undefined,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return OK(input.data);
    }
}
ZodUndefined.create = (params) => {
    return new ZodUndefined({
        typeName: ZodFirstPartyTypeKind.ZodUndefined,
        ...processCreateParams(params),
    });
};
class ZodNull extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.null) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.null,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return OK(input.data);
    }
}
ZodNull.create = (params) => {
    return new ZodNull({
        typeName: ZodFirstPartyTypeKind.ZodNull,
        ...processCreateParams(params),
    });
};
class ZodAny extends ZodType {
    constructor() {
        super(...arguments);
        this._any = true;
    }
    _parse(input) {
        return OK(input.data);
    }
}
ZodAny.create = (params) => {
    return new ZodAny({
        typeName: ZodFirstPartyTypeKind.ZodAny,
        ...processCreateParams(params),
    });
};
class ZodUnknown extends ZodType {
    constructor() {
        super(...arguments);
        this._unknown = true;
    }
    _parse(input) {
        return OK(input.data);
    }
}
ZodUnknown.create = (params) => {
    return new ZodUnknown({
        typeName: ZodFirstPartyTypeKind.ZodUnknown,
        ...processCreateParams(params),
    });
};
class ZodNever extends ZodType {
    _parse(input) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.never,
            received: ctx.parsedType,
        });
        return INVALID;
    }
}
ZodNever.create = (params) => {
    return new ZodNever({
        typeName: ZodFirstPartyTypeKind.ZodNever,
        ...processCreateParams(params),
    });
};
class ZodVoid extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.undefined) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.void,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return OK(input.data);
    }
}
ZodVoid.create = (params) => {
    return new ZodVoid({
        typeName: ZodFirstPartyTypeKind.ZodVoid,
        ...processCreateParams(params),
    });
};
class ZodArray extends ZodType {
    _parse(input) {
        const { ctx, status } = this._processInputParams(input);
        const def = this._def;
        if (ctx.parsedType !== ZodParsedType.array) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.array,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        if (def.exactLength !== null) {
            const tooBig = ctx.data.length > def.exactLength.value;
            const tooSmall = ctx.data.length < def.exactLength.value;
            if (tooBig || tooSmall) {
                addIssueToContext(ctx, {
                    code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
                    minimum: tooSmall ? def.exactLength.value : void 0,
                    maximum: tooBig ? def.exactLength.value : void 0,
                    type: "array",
                    inclusive: true,
                    exact: true,
                    message: def.exactLength.message,
                });
                status.dirty();
            }
        }
        if (def.minLength !== null) {
            if (ctx.data.length < def.minLength.value) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.too_small,
                    minimum: def.minLength.value,
                    type: "array",
                    inclusive: true,
                    exact: false,
                    message: def.minLength.message,
                });
                status.dirty();
            }
        }
        if (def.maxLength !== null) {
            if (ctx.data.length > def.maxLength.value) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.too_big,
                    maximum: def.maxLength.value,
                    type: "array",
                    inclusive: true,
                    exact: false,
                    message: def.maxLength.message,
                });
                status.dirty();
            }
        }
        if (ctx.common.async) {
            return Promise.all(
                [...ctx.data].map((item, i) => {
                    return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
                })
            ).then((result2) => {
                return ParseStatus.mergeArray(status, result2);
            });
        }
        const result = [...ctx.data].map((item, i) => {
            return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
        });
        return ParseStatus.mergeArray(status, result);
    }
    get element() {
        return this._def.type;
    }
    min(minLength, message) {
        return new ZodArray({
            ...this._def,
            minLength: { value: minLength, message: errorUtil.toString(message) },
        });
    }
    max(maxLength, message) {
        return new ZodArray({
            ...this._def,
            maxLength: { value: maxLength, message: errorUtil.toString(message) },
        });
    }
    length(len, message) {
        return new ZodArray({
            ...this._def,
            exactLength: { value: len, message: errorUtil.toString(message) },
        });
    }
    nonempty(message) {
        return this.min(1, message);
    }
}
ZodArray.create = (schema, params) => {
    return new ZodArray({
        type: schema,
        minLength: null,
        maxLength: null,
        exactLength: null,
        typeName: ZodFirstPartyTypeKind.ZodArray,
        ...processCreateParams(params),
    });
};
function deepPartialify(schema) {
    if (schema instanceof ZodObject) {
        const newShape = {};
        for (const key in schema.shape) {
            const fieldSchema = schema.shape[key];
            newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
        }
        return new ZodObject({
            ...schema._def,
            shape: () => newShape,
        });
    } else if (schema instanceof ZodArray) {
        return new ZodArray({
            ...schema._def,
            type: deepPartialify(schema.element),
        });
    } else if (schema instanceof ZodOptional) {
        return ZodOptional.create(deepPartialify(schema.unwrap()));
    } else if (schema instanceof ZodNullable) {
        return ZodNullable.create(deepPartialify(schema.unwrap()));
    } else if (schema instanceof ZodTuple) {
        return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
    } else {
        return schema;
    }
}
class ZodObject extends ZodType {
    constructor() {
        super(...arguments);
        this._cached = null;
        this.nonstrict = this.passthrough;
        this.augment = this.extend;
    }
    _getCached() {
        if (this._cached !== null) return this._cached;
        const shape2 = this._def.shape();
        const keys = util.objectKeys(shape2);
        return (this._cached = { shape: shape2, keys });
    }
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.object) {
            const ctx2 = this._getOrReturnCtx(input);
            addIssueToContext(ctx2, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.object,
                received: ctx2.parsedType,
            });
            return INVALID;
        }
        const { status, ctx } = this._processInputParams(input);
        const { shape: shape2, keys: shapeKeys } = this._getCached();
        const extraKeys = [];
        if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
            for (const key in ctx.data) {
                if (!shapeKeys.includes(key)) {
                    extraKeys.push(key);
                }
            }
        }
        const pairs = [];
        for (const key of shapeKeys) {
            const keyValidator = shape2[key];
            const value = ctx.data[key];
            pairs.push({
                key: { status: "valid", value: key },
                value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
                alwaysSet: key in ctx.data,
            });
        }
        if (this._def.catchall instanceof ZodNever) {
            const unknownKeys = this._def.unknownKeys;
            if (unknownKeys === "passthrough") {
                for (const key of extraKeys) {
                    pairs.push({
                        key: { status: "valid", value: key },
                        value: { status: "valid", value: ctx.data[key] },
                    });
                }
            } else if (unknownKeys === "strict") {
                if (extraKeys.length > 0) {
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.unrecognized_keys,
                        keys: extraKeys,
                    });
                    status.dirty();
                }
            } else if (unknownKeys === "strip");
            else {
                throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
            }
        } else {
            const catchall = this._def.catchall;
            for (const key of extraKeys) {
                const value = ctx.data[key];
                pairs.push({
                    key: { status: "valid", value: key },
                    value: catchall._parse(
                        new ParseInputLazyPath(ctx, value, ctx.path, key)
                        //, ctx.child(key), value, getParsedType(value)
                    ),
                    alwaysSet: key in ctx.data,
                });
            }
        }
        if (ctx.common.async) {
            return Promise.resolve()
                .then(async () => {
                    const syncPairs = [];
                    for (const pair of pairs) {
                        const key = await pair.key;
                        syncPairs.push({
                            key,
                            value: await pair.value,
                            alwaysSet: pair.alwaysSet,
                        });
                    }
                    return syncPairs;
                })
                .then((syncPairs) => {
                    return ParseStatus.mergeObjectSync(status, syncPairs);
                });
        } else {
            return ParseStatus.mergeObjectSync(status, pairs);
        }
    }
    get shape() {
        return this._def.shape();
    }
    strict(message) {
        errorUtil.errToObj;
        return new ZodObject({
            ...this._def,
            unknownKeys: "strict",
            ...(message !== void 0
                ? {
                      errorMap: (issue, ctx) => {
                          var _a, _b, _c, _d;
                          const defaultError =
                              (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
                          if (issue.code === "unrecognized_keys")
                              return {
                                  message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError,
                              };
                          return {
                              message: defaultError,
                          };
                      },
                  }
                : {}),
        });
    }
    strip() {
        return new ZodObject({
            ...this._def,
            unknownKeys: "strip",
        });
    }
    passthrough() {
        return new ZodObject({
            ...this._def,
            unknownKeys: "passthrough",
        });
    }
    // const AugmentFactory =
    //   <Def extends ZodObjectDef>(def: Def) =>
    //   <Augmentation extends ZodRawShape>(
    //     augmentation: Augmentation
    //   ): ZodObject<
    //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
    //     Def["unknownKeys"],
    //     Def["catchall"]
    //   > => {
    //     return new ZodObject({
    //       ...def,
    //       shape: () => ({
    //         ...def.shape(),
    //         ...augmentation,
    //       }),
    //     }) as any;
    //   };
    extend(augmentation) {
        return new ZodObject({
            ...this._def,
            shape: () => ({
                ...this._def.shape(),
                ...augmentation,
            }),
        });
    }
    /**
     * Prior to zod@1.0.12 there was a bug in the
     * inferred type of merged objects. Please
     * upgrade if you are experiencing issues.
     */
    merge(merging) {
        const merged = new ZodObject({
            unknownKeys: merging._def.unknownKeys,
            catchall: merging._def.catchall,
            shape: () => ({
                ...this._def.shape(),
                ...merging._def.shape(),
            }),
            typeName: ZodFirstPartyTypeKind.ZodObject,
        });
        return merged;
    }
    // merge<
    //   Incoming extends AnyZodObject,
    //   Augmentation extends Incoming["shape"],
    //   NewOutput extends {
    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
    //       ? Augmentation[k]["_output"]
    //       : k extends keyof Output
    //       ? Output[k]
    //       : never;
    //   },
    //   NewInput extends {
    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
    //       ? Augmentation[k]["_input"]
    //       : k extends keyof Input
    //       ? Input[k]
    //       : never;
    //   }
    // >(
    //   merging: Incoming
    // ): ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"],
    //   NewOutput,
    //   NewInput
    // > {
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    setKey(key, schema) {
        return this.augment({ [key]: schema });
    }
    // merge<Incoming extends AnyZodObject>(
    //   merging: Incoming
    // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
    // ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"]
    // > {
    //   // const mergedShape = objectUtil.mergeShapes(
    //   //   this._def.shape(),
    //   //   merging._def.shape()
    //   // );
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    catchall(index) {
        return new ZodObject({
            ...this._def,
            catchall: index,
        });
    }
    pick(mask) {
        const shape2 = {};
        util.objectKeys(mask).forEach((key) => {
            if (mask[key] && this.shape[key]) {
                shape2[key] = this.shape[key];
            }
        });
        return new ZodObject({
            ...this._def,
            shape: () => shape2,
        });
    }
    omit(mask) {
        const shape2 = {};
        util.objectKeys(this.shape).forEach((key) => {
            if (!mask[key]) {
                shape2[key] = this.shape[key];
            }
        });
        return new ZodObject({
            ...this._def,
            shape: () => shape2,
        });
    }
    /**
     * @deprecated
     */
    deepPartial() {
        return deepPartialify(this);
    }
    partial(mask) {
        const newShape = {};
        util.objectKeys(this.shape).forEach((key) => {
            const fieldSchema = this.shape[key];
            if (mask && !mask[key]) {
                newShape[key] = fieldSchema;
            } else {
                newShape[key] = fieldSchema.optional();
            }
        });
        return new ZodObject({
            ...this._def,
            shape: () => newShape,
        });
    }
    required(mask) {
        const newShape = {};
        util.objectKeys(this.shape).forEach((key) => {
            if (mask && !mask[key]) {
                newShape[key] = this.shape[key];
            } else {
                const fieldSchema = this.shape[key];
                let newField = fieldSchema;
                while (newField instanceof ZodOptional) {
                    newField = newField._def.innerType;
                }
                newShape[key] = newField;
            }
        });
        return new ZodObject({
            ...this._def,
            shape: () => newShape,
        });
    }
    keyof() {
        return createZodEnum(util.objectKeys(this.shape));
    }
}
ZodObject.create = (shape2, params) => {
    return new ZodObject({
        shape: () => shape2,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params),
    });
};
ZodObject.strictCreate = (shape2, params) => {
    return new ZodObject({
        shape: () => shape2,
        unknownKeys: "strict",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params),
    });
};
ZodObject.lazycreate = (shape2, params) => {
    return new ZodObject({
        shape: shape2,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params),
    });
};
class ZodUnion extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        const options = this._def.options;
        function handleResults(results) {
            for (const result of results) {
                if (result.result.status === "valid") {
                    return result.result;
                }
            }
            for (const result of results) {
                if (result.result.status === "dirty") {
                    ctx.common.issues.push(...result.ctx.common.issues);
                    return result.result;
                }
            }
            const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_union,
                unionErrors,
            });
            return INVALID;
        }
        if (ctx.common.async) {
            return Promise.all(
                options.map(async (option) => {
                    const childCtx = {
                        ...ctx,
                        common: {
                            ...ctx.common,
                            issues: [],
                        },
                        parent: null,
                    };
                    return {
                        result: await option._parseAsync({
                            data: ctx.data,
                            path: ctx.path,
                            parent: childCtx,
                        }),
                        ctx: childCtx,
                    };
                })
            ).then(handleResults);
        } else {
            let dirty = void 0;
            const issues = [];
            for (const option of options) {
                const childCtx = {
                    ...ctx,
                    common: {
                        ...ctx.common,
                        issues: [],
                    },
                    parent: null,
                };
                const result = option._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: childCtx,
                });
                if (result.status === "valid") {
                    return result;
                } else if (result.status === "dirty" && !dirty) {
                    dirty = { result, ctx: childCtx };
                }
                if (childCtx.common.issues.length) {
                    issues.push(childCtx.common.issues);
                }
            }
            if (dirty) {
                ctx.common.issues.push(...dirty.ctx.common.issues);
                return dirty.result;
            }
            const unionErrors = issues.map((issues2) => new ZodError(issues2));
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_union,
                unionErrors,
            });
            return INVALID;
        }
    }
    get options() {
        return this._def.options;
    }
}
ZodUnion.create = (types, params) => {
    return new ZodUnion({
        options: types,
        typeName: ZodFirstPartyTypeKind.ZodUnion,
        ...processCreateParams(params),
    });
};
const getDiscriminator = (type) => {
    if (type instanceof ZodLazy) {
        return getDiscriminator(type.schema);
    } else if (type instanceof ZodEffects) {
        return getDiscriminator(type.innerType());
    } else if (type instanceof ZodLiteral) {
        return [type.value];
    } else if (type instanceof ZodEnum) {
        return type.options;
    } else if (type instanceof ZodNativeEnum) {
        return Object.keys(type.enum);
    } else if (type instanceof ZodDefault) {
        return getDiscriminator(type._def.innerType);
    } else if (type instanceof ZodUndefined) {
        return [void 0];
    } else if (type instanceof ZodNull) {
        return [null];
    } else {
        return null;
    }
};
class ZodDiscriminatedUnion extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.object) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.object,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const discriminator = this.discriminator;
        const discriminatorValue = ctx.data[discriminator];
        const option = this.optionsMap.get(discriminatorValue);
        if (!option) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_union_discriminator,
                options: Array.from(this.optionsMap.keys()),
                path: [discriminator],
            });
            return INVALID;
        }
        if (ctx.common.async) {
            return option._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            });
        } else {
            return option._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            });
        }
    }
    get discriminator() {
        return this._def.discriminator;
    }
    get options() {
        return this._def.options;
    }
    get optionsMap() {
        return this._def.optionsMap;
    }
    /**
     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
     * have a different value for each object in the union.
     * @param discriminator the name of the discriminator property
     * @param types an array of object schemas
     * @param params
     */
    static create(discriminator, options, params) {
        const optionsMap = /* @__PURE__ */ new Map();
        for (const type of options) {
            const discriminatorValues = getDiscriminator(type.shape[discriminator]);
            if (!discriminatorValues) {
                throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
            }
            for (const value of discriminatorValues) {
                if (optionsMap.has(value)) {
                    throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
                }
                optionsMap.set(value, type);
            }
        }
        return new ZodDiscriminatedUnion({
            typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
            discriminator,
            options,
            optionsMap,
            ...processCreateParams(params),
        });
    }
}
function mergeValues(a, b2) {
    const aType = getParsedType(a);
    const bType = getParsedType(b2);
    if (a === b2) {
        return { valid: true, data: a };
    } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
        const bKeys = util.objectKeys(b2);
        const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
        const newObj = { ...a, ...b2 };
        for (const key of sharedKeys) {
            const sharedValue = mergeValues(a[key], b2[key]);
            if (!sharedValue.valid) {
                return { valid: false };
            }
            newObj[key] = sharedValue.data;
        }
        return { valid: true, data: newObj };
    } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
        if (a.length !== b2.length) {
            return { valid: false };
        }
        const newArray = [];
        for (let index = 0; index < a.length; index++) {
            const itemA = a[index];
            const itemB = b2[index];
            const sharedValue = mergeValues(itemA, itemB);
            if (!sharedValue.valid) {
                return { valid: false };
            }
            newArray.push(sharedValue.data);
        }
        return { valid: true, data: newArray };
    } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b2) {
        return { valid: true, data: a };
    } else {
        return { valid: false };
    }
}
class ZodIntersection extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const handleParsed = (parsedLeft, parsedRight) => {
            if (isAborted(parsedLeft) || isAborted(parsedRight)) {
                return INVALID;
            }
            const merged = mergeValues(parsedLeft.value, parsedRight.value);
            if (!merged.valid) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_intersection_types,
                });
                return INVALID;
            }
            if (isDirty(parsedLeft) || isDirty(parsedRight)) {
                status.dirty();
            }
            return { status: status.value, value: merged.data };
        };
        if (ctx.common.async) {
            return Promise.all([
                this._def.left._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                }),
                this._def.right._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                }),
            ]).then(([left2, right2]) => handleParsed(left2, right2));
        } else {
            return handleParsed(
                this._def.left._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                }),
                this._def.right._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                })
            );
        }
    }
}
ZodIntersection.create = (left2, right2, params) => {
    return new ZodIntersection({
        left: left2,
        right: right2,
        typeName: ZodFirstPartyTypeKind.ZodIntersection,
        ...processCreateParams(params),
    });
};
class ZodTuple extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.array) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.array,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        if (ctx.data.length < this._def.items.length) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: this._def.items.length,
                inclusive: true,
                exact: false,
                type: "array",
            });
            return INVALID;
        }
        const rest = this._def.rest;
        if (!rest && ctx.data.length > this._def.items.length) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: this._def.items.length,
                inclusive: true,
                exact: false,
                type: "array",
            });
            status.dirty();
        }
        const items = [...ctx.data]
            .map((item, itemIndex) => {
                const schema = this._def.items[itemIndex] || this._def.rest;
                if (!schema) return null;
                return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
            })
            .filter((x2) => !!x2);
        if (ctx.common.async) {
            return Promise.all(items).then((results) => {
                return ParseStatus.mergeArray(status, results);
            });
        } else {
            return ParseStatus.mergeArray(status, items);
        }
    }
    get items() {
        return this._def.items;
    }
    rest(rest) {
        return new ZodTuple({
            ...this._def,
            rest,
        });
    }
}
ZodTuple.create = (schemas, params) => {
    if (!Array.isArray(schemas)) {
        throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    }
    return new ZodTuple({
        items: schemas,
        typeName: ZodFirstPartyTypeKind.ZodTuple,
        rest: null,
        ...processCreateParams(params),
    });
};
class ZodRecord extends ZodType {
    get keySchema() {
        return this._def.keyType;
    }
    get valueSchema() {
        return this._def.valueType;
    }
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.object) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.object,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const pairs = [];
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        for (const key in ctx.data) {
            pairs.push({
                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
                value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
            });
        }
        if (ctx.common.async) {
            return ParseStatus.mergeObjectAsync(status, pairs);
        } else {
            return ParseStatus.mergeObjectSync(status, pairs);
        }
    }
    get element() {
        return this._def.valueType;
    }
    static create(first, second, third) {
        if (second instanceof ZodType) {
            return new ZodRecord({
                keyType: first,
                valueType: second,
                typeName: ZodFirstPartyTypeKind.ZodRecord,
                ...processCreateParams(third),
            });
        }
        return new ZodRecord({
            keyType: ZodString.create(),
            valueType: first,
            typeName: ZodFirstPartyTypeKind.ZodRecord,
            ...processCreateParams(second),
        });
    }
}
class ZodMap extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.map) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.map,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        const pairs = [...ctx.data.entries()].map(([key, value], index) => {
            return {
                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
                value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"])),
            };
        });
        if (ctx.common.async) {
            const finalMap = /* @__PURE__ */ new Map();
            return Promise.resolve().then(async () => {
                for (const pair of pairs) {
                    const key = await pair.key;
                    const value = await pair.value;
                    if (key.status === "aborted" || value.status === "aborted") {
                        return INVALID;
                    }
                    if (key.status === "dirty" || value.status === "dirty") {
                        status.dirty();
                    }
                    finalMap.set(key.value, value.value);
                }
                return { status: status.value, value: finalMap };
            });
        } else {
            const finalMap = /* @__PURE__ */ new Map();
            for (const pair of pairs) {
                const key = pair.key;
                const value = pair.value;
                if (key.status === "aborted" || value.status === "aborted") {
                    return INVALID;
                }
                if (key.status === "dirty" || value.status === "dirty") {
                    status.dirty();
                }
                finalMap.set(key.value, value.value);
            }
            return { status: status.value, value: finalMap };
        }
    }
}
ZodMap.create = (keyType, valueType, params) => {
    return new ZodMap({
        valueType,
        keyType,
        typeName: ZodFirstPartyTypeKind.ZodMap,
        ...processCreateParams(params),
    });
};
class ZodSet extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.set) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.set,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const def = this._def;
        if (def.minSize !== null) {
            if (ctx.data.size < def.minSize.value) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.too_small,
                    minimum: def.minSize.value,
                    type: "set",
                    inclusive: true,
                    exact: false,
                    message: def.minSize.message,
                });
                status.dirty();
            }
        }
        if (def.maxSize !== null) {
            if (ctx.data.size > def.maxSize.value) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.too_big,
                    maximum: def.maxSize.value,
                    type: "set",
                    inclusive: true,
                    exact: false,
                    message: def.maxSize.message,
                });
                status.dirty();
            }
        }
        const valueType = this._def.valueType;
        function finalizeSet(elements2) {
            const parsedSet = /* @__PURE__ */ new Set();
            for (const element of elements2) {
                if (element.status === "aborted") return INVALID;
                if (element.status === "dirty") status.dirty();
                parsedSet.add(element.value);
            }
            return { status: status.value, value: parsedSet };
        }
        const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
        if (ctx.common.async) {
            return Promise.all(elements).then((elements2) => finalizeSet(elements2));
        } else {
            return finalizeSet(elements);
        }
    }
    min(minSize, message) {
        return new ZodSet({
            ...this._def,
            minSize: { value: minSize, message: errorUtil.toString(message) },
        });
    }
    max(maxSize, message) {
        return new ZodSet({
            ...this._def,
            maxSize: { value: maxSize, message: errorUtil.toString(message) },
        });
    }
    size(size, message) {
        return this.min(size, message).max(size, message);
    }
    nonempty(message) {
        return this.min(1, message);
    }
}
ZodSet.create = (valueType, params) => {
    return new ZodSet({
        valueType,
        minSize: null,
        maxSize: null,
        typeName: ZodFirstPartyTypeKind.ZodSet,
        ...processCreateParams(params),
    });
};
class ZodFunction extends ZodType {
    constructor() {
        super(...arguments);
        this.validate = this.implement;
    }
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.function) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.function,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        function makeArgsIssue(args, error) {
            return makeIssue({
                data: args,
                path: ctx.path,
                errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), errorMap].filter((x2) => !!x2),
                issueData: {
                    code: ZodIssueCode.invalid_arguments,
                    argumentsError: error,
                },
            });
        }
        function makeReturnsIssue(returns, error) {
            return makeIssue({
                data: returns,
                path: ctx.path,
                errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), errorMap].filter((x2) => !!x2),
                issueData: {
                    code: ZodIssueCode.invalid_return_type,
                    returnTypeError: error,
                },
            });
        }
        const params = { errorMap: ctx.common.contextualErrorMap };
        const fn2 = ctx.data;
        if (this._def.returns instanceof ZodPromise) {
            return OK(async (...args) => {
                const error = new ZodError([]);
                const parsedArgs = await this._def.args.parseAsync(args, params).catch((e2) => {
                    error.addIssue(makeArgsIssue(args, e2));
                    throw error;
                });
                const result = await fn2(...parsedArgs);
                const parsedReturns = await this._def.returns._def.type.parseAsync(result, params).catch((e2) => {
                    error.addIssue(makeReturnsIssue(result, e2));
                    throw error;
                });
                return parsedReturns;
            });
        } else {
            return OK((...args) => {
                const parsedArgs = this._def.args.safeParse(args, params);
                if (!parsedArgs.success) {
                    throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
                }
                const result = fn2(...parsedArgs.data);
                const parsedReturns = this._def.returns.safeParse(result, params);
                if (!parsedReturns.success) {
                    throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
                }
                return parsedReturns.data;
            });
        }
    }
    parameters() {
        return this._def.args;
    }
    returnType() {
        return this._def.returns;
    }
    args(...items) {
        return new ZodFunction({
            ...this._def,
            args: ZodTuple.create(items).rest(ZodUnknown.create()),
        });
    }
    returns(returnType) {
        return new ZodFunction({
            ...this._def,
            returns: returnType,
        });
    }
    implement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
    }
    strictImplement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
    }
    static create(args, returns, params) {
        return new ZodFunction({
            args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
            returns: returns || ZodUnknown.create(),
            typeName: ZodFirstPartyTypeKind.ZodFunction,
            ...processCreateParams(params),
        });
    }
}
class ZodLazy extends ZodType {
    get schema() {
        return this._def.getter();
    }
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        const lazySchema = this._def.getter();
        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
    }
}
ZodLazy.create = (getter, params) => {
    return new ZodLazy({
        getter,
        typeName: ZodFirstPartyTypeKind.ZodLazy,
        ...processCreateParams(params),
    });
};
class ZodLiteral extends ZodType {
    _parse(input) {
        if (input.data !== this._def.value) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                received: ctx.data,
                code: ZodIssueCode.invalid_literal,
                expected: this._def.value,
            });
            return INVALID;
        }
        return { status: "valid", value: input.data };
    }
    get value() {
        return this._def.value;
    }
}
ZodLiteral.create = (value, params) => {
    return new ZodLiteral({
        value,
        typeName: ZodFirstPartyTypeKind.ZodLiteral,
        ...processCreateParams(params),
    });
};
function createZodEnum(values2, params) {
    return new ZodEnum({
        values: values2,
        typeName: ZodFirstPartyTypeKind.ZodEnum,
        ...processCreateParams(params),
    });
}
class ZodEnum extends ZodType {
    _parse(input) {
        if (typeof input.data !== "string") {
            const ctx = this._getOrReturnCtx(input);
            const expectedValues = this._def.values;
            addIssueToContext(ctx, {
                expected: util.joinValues(expectedValues),
                received: ctx.parsedType,
                code: ZodIssueCode.invalid_type,
            });
            return INVALID;
        }
        if (this._def.values.indexOf(input.data) === -1) {
            const ctx = this._getOrReturnCtx(input);
            const expectedValues = this._def.values;
            addIssueToContext(ctx, {
                received: ctx.data,
                code: ZodIssueCode.invalid_enum_value,
                options: expectedValues,
            });
            return INVALID;
        }
        return OK(input.data);
    }
    get options() {
        return this._def.values;
    }
    get enum() {
        const enumValues = {};
        for (const val of this._def.values) {
            enumValues[val] = val;
        }
        return enumValues;
    }
    get Values() {
        const enumValues = {};
        for (const val of this._def.values) {
            enumValues[val] = val;
        }
        return enumValues;
    }
    get Enum() {
        const enumValues = {};
        for (const val of this._def.values) {
            enumValues[val] = val;
        }
        return enumValues;
    }
    extract(values2) {
        return ZodEnum.create(values2);
    }
    exclude(values2) {
        return ZodEnum.create(this.options.filter((opt) => !values2.includes(opt)));
    }
}
ZodEnum.create = createZodEnum;
class ZodNativeEnum extends ZodType {
    _parse(input) {
        const nativeEnumValues = util.getValidEnumValues(this._def.values);
        const ctx = this._getOrReturnCtx(input);
        if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
            const expectedValues = util.objectValues(nativeEnumValues);
            addIssueToContext(ctx, {
                expected: util.joinValues(expectedValues),
                received: ctx.parsedType,
                code: ZodIssueCode.invalid_type,
            });
            return INVALID;
        }
        if (nativeEnumValues.indexOf(input.data) === -1) {
            const expectedValues = util.objectValues(nativeEnumValues);
            addIssueToContext(ctx, {
                received: ctx.data,
                code: ZodIssueCode.invalid_enum_value,
                options: expectedValues,
            });
            return INVALID;
        }
        return OK(input.data);
    }
    get enum() {
        return this._def.values;
    }
}
ZodNativeEnum.create = (values2, params) => {
    return new ZodNativeEnum({
        values: values2,
        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
        ...processCreateParams(params),
    });
};
class ZodPromise extends ZodType {
    unwrap() {
        return this._def.type;
    }
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.promise,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
        return OK(
            promisified.then((data) => {
                return this._def.type.parseAsync(data, {
                    path: ctx.path,
                    errorMap: ctx.common.contextualErrorMap,
                });
            })
        );
    }
}
ZodPromise.create = (schema, params) => {
    return new ZodPromise({
        type: schema,
        typeName: ZodFirstPartyTypeKind.ZodPromise,
        ...processCreateParams(params),
    });
};
class ZodEffects extends ZodType {
    innerType() {
        return this._def.schema;
    }
    sourceType() {
        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
    }
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const effect2 = this._def.effect || null;
        if (effect2.type === "preprocess") {
            const processed = effect2.transform(ctx.data);
            if (ctx.common.async) {
                return Promise.resolve(processed).then((processed2) => {
                    return this._def.schema._parseAsync({
                        data: processed2,
                        path: ctx.path,
                        parent: ctx,
                    });
                });
            } else {
                return this._def.schema._parseSync({
                    data: processed,
                    path: ctx.path,
                    parent: ctx,
                });
            }
        }
        const checkCtx = {
            addIssue: (arg) => {
                addIssueToContext(ctx, arg);
                if (arg.fatal) {
                    status.abort();
                } else {
                    status.dirty();
                }
            },
            get path() {
                return ctx.path;
            },
        };
        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
        if (effect2.type === "refinement") {
            const executeRefinement = (acc) => {
                const result = effect2.refinement(acc, checkCtx);
                if (ctx.common.async) {
                    return Promise.resolve(result);
                }
                if (result instanceof Promise) {
                    throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
                }
                return acc;
            };
            if (ctx.common.async === false) {
                const inner = this._def.schema._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                });
                if (inner.status === "aborted") return INVALID;
                if (inner.status === "dirty") status.dirty();
                executeRefinement(inner.value);
                return { status: status.value, value: inner.value };
            } else {
                return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
                    if (inner.status === "aborted") return INVALID;
                    if (inner.status === "dirty") status.dirty();
                    return executeRefinement(inner.value).then(() => {
                        return { status: status.value, value: inner.value };
                    });
                });
            }
        }
        if (effect2.type === "transform") {
            if (ctx.common.async === false) {
                const base = this._def.schema._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                });
                if (!isValid(base)) return base;
                const result = effect2.transform(base.value, checkCtx);
                if (result instanceof Promise) {
                    throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
                }
                return { status: status.value, value: result };
            } else {
                return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
                    if (!isValid(base)) return base;
                    return Promise.resolve(effect2.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
                });
            }
        }
        util.assertNever(effect2);
    }
}
ZodEffects.create = (schema, effect2, params) => {
    return new ZodEffects({
        schema,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect: effect2,
        ...processCreateParams(params),
    });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
    return new ZodEffects({
        schema,
        effect: { type: "preprocess", transform: preprocess },
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        ...processCreateParams(params),
    });
};
class ZodOptional extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === ZodParsedType.undefined) {
            return OK(void 0);
        }
        return this._def.innerType._parse(input);
    }
    unwrap() {
        return this._def.innerType;
    }
}
ZodOptional.create = (type, params) => {
    return new ZodOptional({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodOptional,
        ...processCreateParams(params),
    });
};
class ZodNullable extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === ZodParsedType.null) {
            return OK(null);
        }
        return this._def.innerType._parse(input);
    }
    unwrap() {
        return this._def.innerType;
    }
}
ZodNullable.create = (type, params) => {
    return new ZodNullable({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodNullable,
        ...processCreateParams(params),
    });
};
class ZodDefault extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        let data = ctx.data;
        if (ctx.parsedType === ZodParsedType.undefined) {
            data = this._def.defaultValue();
        }
        return this._def.innerType._parse({
            data,
            path: ctx.path,
            parent: ctx,
        });
    }
    removeDefault() {
        return this._def.innerType;
    }
}
ZodDefault.create = (type, params) => {
    return new ZodDefault({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodDefault,
        defaultValue: typeof params.default === "function" ? params.default : () => params.default,
        ...processCreateParams(params),
    });
};
class ZodCatch extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        const newCtx = {
            ...ctx,
            common: {
                ...ctx.common,
                issues: [],
            },
        };
        const result = this._def.innerType._parse({
            data: newCtx.data,
            path: newCtx.path,
            parent: {
                ...newCtx,
            },
        });
        if (isAsync(result)) {
            return result.then((result2) => {
                return {
                    status: "valid",
                    value:
                        result2.status === "valid"
                            ? result2.value
                            : this._def.catchValue({
                                  get error() {
                                      return new ZodError(newCtx.common.issues);
                                  },
                                  input: newCtx.data,
                              }),
                };
            });
        } else {
            return {
                status: "valid",
                value:
                    result.status === "valid"
                        ? result.value
                        : this._def.catchValue({
                              get error() {
                                  return new ZodError(newCtx.common.issues);
                              },
                              input: newCtx.data,
                          }),
            };
        }
    }
    removeCatch() {
        return this._def.innerType;
    }
}
ZodCatch.create = (type, params) => {
    return new ZodCatch({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodCatch,
        catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
        ...processCreateParams(params),
    });
};
class ZodNaN extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.nan) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.nan,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return { status: "valid", value: input.data };
    }
}
ZodNaN.create = (params) => {
    return new ZodNaN({
        typeName: ZodFirstPartyTypeKind.ZodNaN,
        ...processCreateParams(params),
    });
};
const BRAND = Symbol("zod_brand");
class ZodBranded extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        const data = ctx.data;
        return this._def.type._parse({
            data,
            path: ctx.path,
            parent: ctx,
        });
    }
    unwrap() {
        return this._def.type;
    }
}
class ZodPipeline extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.common.async) {
            const handleAsync = async () => {
                const inResult = await this._def.in._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                });
                if (inResult.status === "aborted") return INVALID;
                if (inResult.status === "dirty") {
                    status.dirty();
                    return DIRTY(inResult.value);
                } else {
                    return this._def.out._parseAsync({
                        data: inResult.value,
                        path: ctx.path,
                        parent: ctx,
                    });
                }
            };
            return handleAsync();
        } else {
            const inResult = this._def.in._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            });
            if (inResult.status === "aborted") return INVALID;
            if (inResult.status === "dirty") {
                status.dirty();
                return {
                    status: "dirty",
                    value: inResult.value,
                };
            } else {
                return this._def.out._parseSync({
                    data: inResult.value,
                    path: ctx.path,
                    parent: ctx,
                });
            }
        }
    }
    static create(a, b2) {
        return new ZodPipeline({
            in: a,
            out: b2,
            typeName: ZodFirstPartyTypeKind.ZodPipeline,
        });
    }
}
const custom = (check, params = {}, fatal) => {
    if (check)
        return ZodAny.create().superRefine((data, ctx) => {
            var _a, _b;
            if (!check(data)) {
                const p2 = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
                const _fatal = (_b = (_a = p2.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
                const p22 = typeof p2 === "string" ? { message: p2 } : p2;
                ctx.addIssue({ code: "custom", ...p22, fatal: _fatal });
            }
        });
    return ZodAny.create();
};
const late = {
    object: ZodObject.lazycreate,
};
var ZodFirstPartyTypeKind;
(function (ZodFirstPartyTypeKind2) {
    ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
    ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
    ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
    ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
    ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
    ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
    ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
    ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
    ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
    ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
    ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
    ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
    ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
    ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
    ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
    ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
    ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
    ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
    ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
    ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
    ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
    ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
    ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
    ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
    ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
    ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
    ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
    ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
    ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
    ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
    ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
    ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
    ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
    ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
    ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
const instanceOfType = (
    cls,
    params = {
        message: `Input not instance of ${cls.name}`,
    }
) => custom((data) => data instanceof cls, params);
const stringType = ZodString.create;
const numberType = ZodNumber.create;
const nanType = ZodNaN.create;
const bigIntType = ZodBigInt.create;
const booleanType = ZodBoolean.create;
const dateType = ZodDate.create;
const symbolType = ZodSymbol.create;
const undefinedType = ZodUndefined.create;
const nullType = ZodNull.create;
const anyType = ZodAny.create;
const unknownType = ZodUnknown.create;
const neverType = ZodNever.create;
const voidType = ZodVoid.create;
const arrayType = ZodArray.create;
const objectType = ZodObject.create;
const strictObjectType = ZodObject.strictCreate;
const unionType = ZodUnion.create;
const discriminatedUnionType = ZodDiscriminatedUnion.create;
const intersectionType = ZodIntersection.create;
const tupleType = ZodTuple.create;
const recordType = ZodRecord.create;
const mapType = ZodMap.create;
const setType = ZodSet.create;
const functionType = ZodFunction.create;
const lazyType = ZodLazy.create;
const literalType = ZodLiteral.create;
const enumType = ZodEnum.create;
const nativeEnumType = ZodNativeEnum.create;
const promiseType = ZodPromise.create;
const effectsType = ZodEffects.create;
const optionalType = ZodOptional.create;
const nullableType = ZodNullable.create;
const preprocessType = ZodEffects.createWithPreprocess;
const pipelineType = ZodPipeline.create;
const ostring = () => stringType().optional();
const onumber = () => numberType().optional();
const oboolean = () => booleanType().optional();
const coerce = {
    string: (arg) => ZodString.create({ ...arg, coerce: true }),
    number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
    boolean: (arg) =>
        ZodBoolean.create({
            ...arg,
            coerce: true,
        }),
    bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
    date: (arg) => ZodDate.create({ ...arg, coerce: true }),
};
const NEVER = INVALID;
var z = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    defaultErrorMap: errorMap,
    setErrorMap,
    getErrorMap,
    makeIssue,
    EMPTY_PATH,
    addIssueToContext,
    ParseStatus,
    INVALID,
    DIRTY,
    OK,
    isAborted,
    isDirty,
    isValid,
    isAsync,
    get util() {
        return util;
    },
    get objectUtil() {
        return objectUtil;
    },
    ZodParsedType,
    getParsedType,
    ZodType,
    ZodString,
    ZodNumber,
    ZodBigInt,
    ZodBoolean,
    ZodDate,
    ZodSymbol,
    ZodUndefined,
    ZodNull,
    ZodAny,
    ZodUnknown,
    ZodNever,
    ZodVoid,
    ZodArray,
    ZodObject,
    ZodUnion,
    ZodDiscriminatedUnion,
    ZodIntersection,
    ZodTuple,
    ZodRecord,
    ZodMap,
    ZodSet,
    ZodFunction,
    ZodLazy,
    ZodLiteral,
    ZodEnum,
    ZodNativeEnum,
    ZodPromise,
    ZodEffects,
    ZodTransformer: ZodEffects,
    ZodOptional,
    ZodNullable,
    ZodDefault,
    ZodCatch,
    ZodNaN,
    BRAND,
    ZodBranded,
    ZodPipeline,
    custom,
    Schema: ZodType,
    ZodSchema: ZodType,
    late,
    get ZodFirstPartyTypeKind() {
        return ZodFirstPartyTypeKind;
    },
    coerce,
    any: anyType,
    array: arrayType,
    bigint: bigIntType,
    boolean: booleanType,
    date: dateType,
    discriminatedUnion: discriminatedUnionType,
    effect: effectsType,
    enum: enumType,
    function: functionType,
    instanceof: instanceOfType,
    intersection: intersectionType,
    lazy: lazyType,
    literal: literalType,
    map: mapType,
    nan: nanType,
    nativeEnum: nativeEnumType,
    never: neverType,
    null: nullType,
    nullable: nullableType,
    number: numberType,
    object: objectType,
    oboolean,
    onumber,
    optional: optionalType,
    ostring,
    pipeline: pipelineType,
    preprocess: preprocessType,
    promise: promiseType,
    record: recordType,
    set: setType,
    strictObject: strictObjectType,
    string: stringType,
    symbol: symbolType,
    transformer: effectsType,
    tuple: tupleType,
    undefined: undefinedType,
    union: unionType,
    unknown: unknownType,
    void: voidType,
    NEVER,
    ZodIssueCode,
    quotelessJson,
    ZodError,
});
const endpoint$2 = "/api/v1/profiles";
async function getProfiles() {
    const response = await fetch(endpoint$2);
    const json = await response.json();
    return mapProfiles(json.resources);
}
function mapProfiles(resources) {
    const profiles = Object.entries(resources);
    const mapped_profiles = profiles
        .map(([key, val]) => {
            return decodeProfile(key, val);
        })
        .sort((profile1, profile2) => {
            const name1 = profile1.name.toUpperCase();
            const name2 = profile2.name.toUpperCase();
            if (name1 < name2) {
                return -1;
            }
            if (name1 > name2) {
                return 1;
            }
            return 0;
        });
    return mapped_profiles;
}
async function saveProfile(body, mode, updateModel, updateLocal) {
    try {
        let response = null;
        if (mode === Mode$1.Edition) {
            response = await fetch(endpoint$2 + "/" + body.name, {
                method: "put",
                body: JSON.stringify(body, null, "	"),
                headers: { "Content-Type": "application/json" },
            });
        } else {
            response = await fetch(endpoint$2, {
                method: "post",
                body: JSON.stringify({ [body.name]: body }, null, "	"),
                headers: { "Content-Type": "application/json" },
            });
        }
        const { message, resources } = await response.json();
        if (response.status === 200) {
            if (mode === Mode$1.Edition) {
                const profiles = await getProfiles();
                updateModel({ type: "ServerRespondedWithProfiles", payload: success(mapProfiles(profiles)) });
            } else {
                updateModel({ type: "ServerRespondedWithProfiles", payload: success(mapProfiles(resources)) });
            }
            updateLocal({ type: Type$1.UserClickedModal, payload: false });
        } else {
            updateModel({ type: "ServerRespondedWithProfiles", payload: failure(`${response.status}, ${message}`) });
        }
    } catch (e2) {
        updateModel({ type: "ServerRespondedWithProfiles", payload: failure(`Uncatched : ${e2}`) });
    }
}
async function deleteProfile(profile, updateModel) {
    try {
        const response = await fetch(`${endpoint$2}/${profile.name}`, { method: "delete" });
        const { message, resources } = await response.json();
        if (response.status === 200) {
            updateModel({ type: "ServerRespondedWithProfiles", payload: success(mapProfiles(resources)) });
        } else {
            updateModel({ type: "ServerRespondedWithProfiles", payload: failure(`${response.status}, ${message}`) });
        }
    } catch (e2) {
        updateModel({ type: "ServerRespondedWithProfiles", payload: failure(`Uncatched Error : ${e2}`) });
    }
}
const decodeProfile = (key, profile) => {
    return {
        name: profile.name ? profile.name : key,
        _type: "profile",
        id: profile.id ? profile.id : ulid(),
        allowedSourceSchemas: profile.allowedSourceSchemas,
        sourcesAccessControl: profile.sourcesAccessControl,
        allowedTools: profile.allowedTools,
        forbiddenTools: profile.forbiddenTools,
        blender: { contextMenuActionStartLevel: profile.blender.contextMenuActionStartLevel },
    };
};
const BlenderSchema = z.object({
    contextMenuActionStartLevel: z.coerce.number(),
});
const SourceAccessControlSchema = z.union([z.literal("forbidden"), z.literal("read"), z.literal("readwrite")]);
const ProfileSchema = z.object({
    name: z
        .string()
        .refine((val) => val !== "admin", { message: "Name can't be admin" })
        .refine((val) => val.match(/^[a-z0-9][a-z0-9-_]{1,253}$/i), { message: "Name can only contain alphanum and - or _ chars" }),
    _type: z.string().optional(),
    id: z.string().default(ulid()),
    allowedSourceSchemas: z
        .array(z.string().nullish())
        .nullish()
        .transform((a) => (a ?? []).flatMap((item) => (item ? item : []))),
    sourcesAccessControl: z.record(SourceAccessControlSchema).default({}),
    allowedTools: z.union([z.string(), z.array(z.string())]).default("ALL"),
    forbiddenTools: z.array(z.string()).default([]),
    blender: BlenderSchema.default({ contextMenuActionStartLevel: 0 }),
});
const defaultProfile = (uuid) => {
    return {
        name: "",
        _type: "profile",
        id: uuid,
        allowedSourceSchemas: [],
        sourcesAccessControl: {},
        allowedTools: "ALL",
        forbiddenTools: [],
        blender: { contextMenuActionStartLevel: 0 },
    };
};
const endpoint$1 = "/api/v1/sources";
const indicesEndpoint = "/api/v1/elasticsearch/indices";
const graphsEndpoint = "/api/v1/sparql/graphs";
async function getSources() {
    const response = await fetch(endpoint$1);
    const json = await response.json();
    return mapSources(json.resources);
}
async function getIndices() {
    const response = await fetch(indicesEndpoint);
    const json = await response.json();
    return json;
}
async function getGraphs() {
    const response = await fetch(graphsEndpoint);
    const json = await response.json();
    return json;
}
function mapSources(resources) {
    const sources = Object.entries(resources);
    const mapped_sources = sources
        .map(([key, val]) => decodeSource(key, val))
        .sort((source1, source2) => {
            const name1 = source1.name.toUpperCase();
            const name2 = source2.name.toUpperCase();
            if (name1 < name2) {
                return -1;
            }
            if (name1 > name2) {
                return 1;
            }
            return 0;
        });
    return mapped_sources;
}
async function saveSource(body, mode, updateModel, updateLocal) {
    try {
        let response = null;
        if (mode === Mode.Edition) {
            response = await fetch(endpoint$1 + "/" + body.name, {
                method: "put",
                body: JSON.stringify(body, null, "	"),
                headers: { "Content-Type": "application/json" },
            });
        } else {
            response = await fetch(endpoint$1, {
                method: "post",
                body: JSON.stringify({ [body.name]: body }, null, "	"),
                headers: { "Content-Type": "application/json" },
            });
        }
        const { message, resources } = await response.json();
        if (response.status === 200) {
            if (mode === Mode.Edition) {
                const sources = await getSources();
                updateModel({ type: "ServerRespondedWithSources", payload: success(mapSources(sources)) });
            } else {
                updateModel({ type: "ServerRespondedWithSources", payload: success(mapSources(resources)) });
            }
            updateLocal({ type: Type.UserClickedModal, payload: false });
            updateLocal({ type: Type.ResetSource, payload: mode });
        } else {
            updateModel({ type: "ServerRespondedWithSources", payload: failure(`${response.status}, ${message}`) });
        }
    } catch (e2) {
        updateModel({ type: "ServerRespondedWithSources", payload: failure(`Uncatched : ${e2}`) });
    }
}
async function deleteSource(source, updateModel) {
    try {
        const response = await fetch(`${endpoint$1}/${source.name}`, { method: "delete" });
        const { message, resources } = await response.json();
        if (response.status === 200) {
            updateModel({ type: "ServerRespondedWithSources", payload: success(mapSources(resources)) });
        } else {
            updateModel({ type: "ServerRespondedWithSources", payload: failure(`${response.status}, ${message}`) });
        }
    } catch (e2) {
        updateModel({ type: "ServerRespondedWithSources", payload: failure(`Unhandled Error : ${e2}`) });
    }
}
const decodeSource = (key, source) => {
    return ServerSourceSchema.parse({ ...source, name: source.name ?? key });
};
const SparqlServerSchema = objectType({
    url: stringType().default("_default"),
    method: stringType().default("POST"),
    headers: recordType(stringType(), stringType()).default({}),
}).default({ url: "", method: "", headers: {} });
const SourcePredicatesSchema = objectType({
    broaderPredicate: stringType().default(""),
    lang: stringType().default(""),
}).default({ broaderPredicate: "", lang: "" });
const LocalDictionarySchema = objectType({
    table: stringType().default(""),
    idColumn: stringType().default(""),
    labelColumn: stringType().default(""),
});
const defaultDataSource = {
    type: "",
    connection: "_default",
    dbName: "",
    table_schema: "",
    local_dictionary: { table: "", idColumn: "", labelColumn: "" },
};
const dataSourceSchema = objectType({
    type: stringType().default(""),
    connection: stringType().default("_default"),
    dbName: stringType().default(""),
    table_schema: stringType().default(""),
    local_dictionary: LocalDictionarySchema.nullable(),
}).default(defaultDataSource);
const ServerSourceSchema = objectType({
    id: stringType().default(ulid()),
    name: stringType().default(""),
    _type: stringType().optional(),
    graphUri: stringType().optional(),
    sparql_server: SparqlServerSchema,
    controller: stringType().default("Sparql_OWL"),
    topClassFilter: stringType().default("?topConcept rdf:type owl:Class ."),
    schemaType: stringType().default("OWL"),
    dataSource: dataSourceSchema.nullable(),
    schema: unknownType().nullable(),
    editable: booleanType().default(true),
    color: stringType().default(""),
    isDraft: booleanType().default(false),
    allowIndividuals: booleanType().default(false),
    predicates: SourcePredicatesSchema,
    group: stringType().default(""),
    imports: arrayType(stringType()).default([]),
    taxonomyPredicates: arrayType(stringType()).default(["rdfs:subClassOf"]),
});
const InputSourceSchema = objectType({
    id: stringType().default(ulid()),
    name: stringType()
        .nonempty({ message: "Required" })
        .refine((val) => val !== "admin", { message: "Name can't be admin" })
        .refine((val) => val.match(/.{2,254}/i), { message: "Name can only contain between 2 and 255 chars" })
        .refine((val) => val.match(/^[a-z0-9]/i), { message: "Name have to start with alphanum char" })
        .refine((val) => val.match(/^[a-z0-9][a-z0-9-_]{1,253}$/i), { message: "Name can only contain alphanum and - or _ chars" }),
    _type: stringType().optional(),
    graphUri: stringType().optional(),
    sparql_server: SparqlServerSchema,
    controller: stringType().optional(),
    topClassFilter: stringType().optional(),
    schemaType: stringType().optional(),
    dataSource: dataSourceSchema.nullable(),
    schema: unknownType().nullable(),
    editable: booleanType().optional(),
    color: stringType().default(""),
    isDraft: booleanType().default(false),
    allowIndividuals: booleanType().default(false),
    predicates: SourcePredicatesSchema,
    group: stringType().min(3, { message: "Required, 3 chars min" }),
    imports: arrayType(stringType()).default([]),
    taxonomyPredicates: arrayType(stringType()).default(["rdfs:subClassOf"]),
});
const defaultSource = (id) => {
    return ServerSourceSchema.parse({
        _type: "source",
        id,
        sparql_server: SparqlServerSchema.parse({ headers: {} }),
    });
};
var Circle = {};
var _interopRequireDefault = interopRequireDefaultExports;
Object.defineProperty(Circle, "__esModule", {
    value: true,
});
var default_1 = (Circle.default = void 0);
var _createSvgIcon = _interopRequireDefault(requireCreateSvgIcon());
var _jsxRuntime = jsxRuntimeExports;
var _default = (0, _createSvgIcon.default)(
    /* @__PURE__ */ (0, _jsxRuntime.jsx)("path", {
        d: "M12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2z",
    }),
    "Circle"
);
default_1 = Circle.default = _default;
const SourcesTable = () => {
    const { model, updateModel } = useModel();
    const [filteringChars, setFilteringChars] = reactExports.useState("");
    const [orderBy, setOrderBy] = reactExports.useState("name");
    const [order2, setOrder] = reactExports.useState("asc");
    function handleRequestSort(property) {
        const isAsc = orderBy === property && order2 === "asc";
        setOrder(isAsc ? "desc" : "asc");
        setOrderBy(property);
    }
    const indices = SRD.withDefault(null, model.indices);
    const graphs = SRD.withDefault(null, model.graphs);
    const renderSources = SRD.match(
        {
            notAsked: () => /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Let&aposs fetch some data!" }),
            loading: () =>
                /* @__PURE__ */ jsxRuntimeExports.jsx(Box$1, { sx: { display: "flex", justifyContent: "center", p: 4 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress$1, {}) }),
            failure: (msg) =>
                /* @__PURE__ */ jsxRuntimeExports.jsx(Box$1, {
                    sx: { display: "flex", justifyContent: "center", p: 4 },
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: `I stumbled into this error when I tried to fetch data: ${msg}. Please, reload this page.` }),
                }),
            success: (gotSources) => {
                const datas = gotSources.map((source) => {
                    const { sparql_server, dataSource, predicates, imports, taxonomyPredicates, isDraft, editable, allowIndividuals, ...restOfProperties } = source;
                    const processedData = {
                        ...restOfProperties,
                        editable: editable ? "Editable" : "Not Editable",
                        isDraft: isDraft ? "IsDraft" : "Not a draft",
                        allowIndividuals: allowIndividuals ? "allowIndividuals" : "Not allowIndividuals",
                        imports: joinWhenArray(imports),
                        taxonomyPredicates: joinWhenArray(taxonomyPredicates),
                    };
                    const dataWithoutCarriageReturns = Object.fromEntries(
                        Object.entries(processedData).map(([key, value]) => {
                            if (typeof value === "string") {
                                return [key, value.replace("\n", " ")];
                            }
                            return [key, value];
                        })
                    );
                    return { ...dataWithoutCarriageReturns };
                });
                const sortedSources = gotSources.slice().sort((a, b2) => {
                    const left2 = a[orderBy];
                    const right2 = b2[orderBy];
                    return order2 === "asc" ? left2.localeCompare(right2) : right2.localeCompare(left2);
                });
                return /* @__PURE__ */ jsxRuntimeExports.jsx(Box$1, {
                    sx: { display: "flex", justifyContent: "center", p: 4 },
                    children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack$1, {
                        children: [
                            /* @__PURE__ */ jsxRuntimeExports.jsx(CsvDownload, { separator: "	", filename: "sources", extension: ".tsv", datas }),
                            /* @__PURE__ */ jsxRuntimeExports.jsx(Autocomplete$1, {
                                disablePortal: true,
                                id: "search-sources",
                                options: gotSources.map((source) => source.name),
                                sx: { width: 300 },
                                onInputChange: (event, newInputValue) => {
                                    setFilteringChars(newInputValue);
                                },
                                renderInput: (params) => /* @__PURE__ */ jsxRuntimeExports.jsx(TextField$1, { ...params, label: "Search Sources by name" }),
                            }),
                            " ",
                            /* @__PURE__ */ jsxRuntimeExports.jsx(Box$1, {
                                id: "table-container",
                                sx: { justifyContent: "center", height: "400px", display: "flex" },
                                children: /* @__PURE__ */ jsxRuntimeExports.jsx(TableContainer$1, {
                                    sx: { height: "400px" },
                                    component: Paper$1,
                                    children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Table$1, {
                                        children: [
                                            /* @__PURE__ */ jsxRuntimeExports.jsx(TableHead$1, {
                                                children: /* @__PURE__ */ jsxRuntimeExports.jsxs(TableRow$1, {
                                                    children: [
                                                        /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell$1, {
                                                            style: { fontWeight: "bold" },
                                                            children: /* @__PURE__ */ jsxRuntimeExports.jsx(TableSortLabel$1, {
                                                                active: orderBy === "name",
                                                                direction: order2,
                                                                onClick: () => handleRequestSort("name"),
                                                                children: "Name",
                                                            }),
                                                        }),
                                                        /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell$1, { style: { fontWeight: "bold" }, children: "graphUri" }),
                                                        /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell$1, { style: { fontWeight: "bold" }, children: "Actions" }),
                                                        /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell$1, { style: { fontWeight: "bold" }, children: "Data" }),
                                                    ],
                                                }),
                                            }),
                                            /* @__PURE__ */ jsxRuntimeExports.jsx(TableBody$1, {
                                                sx: { width: "100%", overflow: "visible" },
                                                children: sortedSources
                                                    .filter((source) => source.name.includes(filteringChars))
                                                    .map((source) => {
                                                        const haveIndices = indices ? indices.includes(source.name.toLowerCase()) : false;
                                                        const haveGraphs = graphs ? graphs.includes(source.graphUri || "") : false;
                                                        console.log();
                                                        return /* @__PURE__ */ jsxRuntimeExports.jsxs(
                                                            TableRow$1,
                                                            {
                                                                children: [
                                                                    /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell$1, { children: source.name }),
                                                                    /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell$1, { children: source.graphUri }),
                                                                    /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell$1, {
                                                                        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box$1, {
                                                                            sx: { display: "flex" },
                                                                            children: [
                                                                                /* @__PURE__ */ jsxRuntimeExports.jsx(SourceForm, { source }),
                                                                                /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonWithConfirmation, {
                                                                                    label: "Delete",
                                                                                    msg: () => deleteSource(source, updateModel),
                                                                                }),
                                                                            ],
                                                                        }),
                                                                    }),
                                                                    /* @__PURE__ */ jsxRuntimeExports.jsxs(TableCell$1, {
                                                                        children: [
                                                                            /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip$1, {
                                                                                title: "RDF Graph",
                                                                                children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1, {
                                                                                    sx: { color: graphs !== null ? (haveGraphs ? green$1[500] : pink$1[500]) : grey$1[500] },
                                                                                }),
                                                                            }),
                                                                            /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip$1, {
                                                                                title: "ElasticSearch indices",
                                                                                children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1, {
                                                                                    sx: { color: indices !== null ? (haveIndices ? green$1[500] : pink$1[500]) : grey$1[500] },
                                                                                }),
                                                                            }),
                                                                        ],
                                                                    }),
                                                                ],
                                                            },
                                                            source.name
                                                        );
                                                    }),
                                            }),
                                        ],
                                    }),
                                }),
                            }),
                            /* @__PURE__ */ jsxRuntimeExports.jsx(Box$1, {
                                sx: { display: "flex", justifyContent: "center", p: 4 },
                                children: /* @__PURE__ */ jsxRuntimeExports.jsx(SourceForm, { create: true }),
                            }),
                        ],
                    }),
                });
            },
        },
        model.sources
    );
    return renderSources;
};
function toFormData(source) {
    return {
        ...source,
        sparql_server: {
            ...source.sparql_server,
            headers: Object.entries(source.sparql_server.headers).map(([key, value]) => ({ key, value })),
        },
    };
}
function fromFormData(source) {
    return {
        ...source,
        sparql_server: {
            ...source.sparql_server,
            headers: Object.fromEntries(source.sparql_server.headers.map(({ key, value }) => [key, value])),
        },
    };
}
var Type = /* @__PURE__ */ ((Type2) => {
    Type2[(Type2["UserClickedModal"] = 0)] = "UserClickedModal";
    Type2[(Type2["UserUpdatedField"] = 1)] = "UserUpdatedField";
    Type2[(Type2["ResetSource"] = 2)] = "ResetSource";
    Type2[(Type2["UserAddedGraphUri"] = 3)] = "UserAddedGraphUri";
    Type2[(Type2["UserClickedCheckBox"] = 4)] = "UserClickedCheckBox";
    Type2[(Type2["UserUpdatedPredicates"] = 5)] = "UserUpdatedPredicates";
    Type2[(Type2["UserClickedAddDataSource"] = 6)] = "UserClickedAddDataSource";
    Type2[(Type2["UserUpdatedDataSource"] = 7)] = "UserUpdatedDataSource";
    Type2[(Type2["UserUpdatedsparql_server"] = 8)] = "UserUpdatedsparql_server";
    return Type2;
})(Type || {});
var Mode = /* @__PURE__ */ ((Mode2) => {
    Mode2[(Mode2["Creation"] = 0)] = "Creation";
    Mode2[(Mode2["Edition"] = 1)] = "Edition";
    return Mode2;
})(Mode || {});
const updateSource = (sourceEditionState, msg) => {
    const { model } = useModel();
    const unwrappedSources = SRD.unwrap([], identity, model.sources);
    const getUnmodifiedSources = unwrappedSources.reduce((acc, value) => (sourceEditionState.sourceForm.id === value.id ? toFormData(value) : acc), toFormData(defaultSource(ulid())));
    const resetSourceForm = msg.payload ? sourceEditionState.sourceForm : getUnmodifiedSources;
    const fieldToUpdate = msg.type === 1 ? msg.payload.fieldname : null;
    switch (msg.type) {
        case 0:
            return { ...sourceEditionState, modal: msg.payload };
        case 1:
            return { ...sourceEditionState, sourceForm: { ...sourceEditionState.sourceForm, [fieldToUpdate]: msg.payload.newValue } };
        case 3:
            return { ...sourceEditionState, sourceForm: { ...sourceEditionState.sourceForm, graphUri: msg.payload } };
        case 6:
            return {
                ...sourceEditionState,
                sourceForm: {
                    ...sourceEditionState.sourceForm,
                    dataSource: msg.payload ? { type: "", table_schema: "", connection: "", dbName: "", local_dictionary: { table: "", labelColumn: "", idColumn: "" } } : null,
                },
            };
        case 4:
            return { ...sourceEditionState, sourceForm: { ...sourceEditionState.sourceForm, [msg.payload.checkboxName]: msg.payload.value } };
        case 5:
            return { ...sourceEditionState, sourceForm: { ...sourceEditionState.sourceForm, predicates: msg.payload } };
        case 7:
            return { ...sourceEditionState, sourceForm: { ...sourceEditionState.sourceForm, dataSource: msg.payload } };
        case 8:
            return { ...sourceEditionState, sourceForm: { ...sourceEditionState.sourceForm, sparql_server: msg.payload } };
        case 2:
            switch (msg.payload) {
                case 0:
                    return { ...sourceEditionState, sourceForm: toFormData(defaultSource(ulid())) };
                case 1:
                    return { ...sourceEditionState, sourceForm: msg.payload ? sourceEditionState.sourceForm : resetSourceForm };
            }
    }
};
const SourceForm = ({ source = defaultSource(ulid()), create = false }) => {
    var _a;
    const { model, updateModel } = useModel();
    const unwrappedSources = SRD.unwrap([], identity, model.sources);
    const sources = reactExports.useMemo(() => unwrappedSources, [unwrappedSources]);
    const [sourceModel, update2] = reactExports.useReducer(updateSource, { modal: false, sourceForm: toFormData(source) });
    const [issues, setIssues] = reactExports.useState([]);
    const schemaTypes = [...new Set(sources.map((source2) => source2.schemaType))];
    const zo = useZorm("source-form", InputSourceSchema, { setupListeners: false, customIssues: issues });
    const [isAfterSubmission, setIsAfterSubmission] = reactExports.useState(false);
    const handleOpen = () => update2({ type: 0, payload: true });
    const handleClose = () => update2({ type: 0, payload: false });
    const handleFieldUpdate = (fieldname) => (event) => {
        update2({ type: 1, payload: { fieldname, newValue: event.target.value } });
    };
    const handleTaxonomyPredicatesUpdate = (value) => {
        update2({ type: 1, payload: { fieldname: "taxonomyPredicates", newValue: value } });
    };
    const _handleFieldUpdate = (event) => update2({ type: 3, payload: event.target.value });
    const handleSparql_serverUpdate = (fieldName) => (event) => {
        update2({
            type: 8,
            payload: { ...sourceModel.sourceForm.sparql_server, [fieldName]: fieldName === "headers" ? [] : event.target.value },
        });
    };
    const handleSparql_serverHeadersUpdate = (updater) => {
        update2({
            type: 8,
            payload: { ...sourceModel.sourceForm.sparql_server, headers: updater(sourceModel.sourceForm.sparql_server.headers) },
        });
    };
    const addHeader = () => {
        handleSparql_serverHeadersUpdate((prevHeaders) => [...prevHeaders, { key: "", value: "" }]);
    };
    const removeHeader = (idx) => {
        handleSparql_serverHeadersUpdate((prevHeaders) => {
            const newHeaders = [...prevHeaders];
            newHeaders.splice(idx, 1);
            return newHeaders;
        });
    };
    const updateHeaderKey = (idx) => (event) =>
        handleSparql_serverHeadersUpdate((prevHeaders) => {
            const newHeaders = [...prevHeaders];
            newHeaders[idx] = { ...prevHeaders[idx], key: event.currentTarget.value };
            return newHeaders;
        });
    const updateHeaderValue = (idx) => (event) =>
        handleSparql_serverHeadersUpdate((prevHeaders) => {
            const newHeaders = [...prevHeaders];
            newHeaders[idx] = { ...prevHeaders[idx], value: event.currentTarget.value };
            return newHeaders;
        });
    const handleCheckbox = (checkboxName) => (event) => update2({ type: 4, payload: { checkboxName, value: event.target.checked } });
    const knownTaxonomyPredicates = [
        ...new Set(
            sources.flatMap((source2) => {
                return source2.taxonomyPredicates;
            })
        ),
    ];
    function validateSourceName(sourceName) {
        const issues2 = createCustomIssues(InputSourceSchema);
        if (sources.reduce((acc, s) => acc || (acc = s.name === sourceName), false)) {
            issues2.name(`Source's name ${sourceName} is already in use`);
        }
        return {
            issues: issues2.toArray(),
        };
    }
    const saveSources = () => {
        void saveSource(fromFormData(sourceModel.sourceForm), create ? 0 : 1, updateModel, update2);
    };
    const createIssues = (issue) => setIssues(issue);
    const validateAfterSubmission = () => {
        if (isAfterSubmission) {
            zo.validate();
        }
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
        children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { color: "primary", variant: "contained", onClick: handleOpen, children: create ? "Create Source" : "Edit" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Modal$1, {
                onClose: handleClose,
                open: sourceModel.modal,
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(Box$1, {
                    component: "form",
                    ref: zo.ref,
                    onSubmit: (e2) => {
                        const validation = zo.validate();
                        if (!validation.success) {
                            e2.preventDefault();
                            console.error("error", e2);
                            setIsAfterSubmission(true);
                            return;
                        }
                        e2.preventDefault();
                        saveSources();
                        setIsAfterSubmission(false);
                    },
                    sx: style,
                    children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Grid$1, {
                        container: true,
                        spacing: 4,
                        children: [
                            /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, {
                                item: true,
                                xs: 3,
                                children: /* @__PURE__ */ jsxRuntimeExports.jsx(FormControlLabel$1, {
                                    control: /* @__PURE__ */ jsxRuntimeExports.jsx(Checkbox$1, { checked: sourceModel.sourceForm.editable, onChange: handleCheckbox("editable") }),
                                    label: "Is this source editable?",
                                }),
                            }),
                            /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, {
                                item: true,
                                xs: 3,
                                children: /* @__PURE__ */ jsxRuntimeExports.jsx(FormControlLabel$1, {
                                    control: /* @__PURE__ */ jsxRuntimeExports.jsx(Checkbox$1, { checked: sourceModel.sourceForm.isDraft, onChange: handleCheckbox("isDraft") }),
                                    label: "Is it a draft?",
                                }),
                            }),
                            /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, {
                                item: true,
                                xs: 3,
                                children: /* @__PURE__ */ jsxRuntimeExports.jsx(FormControlLabel$1, {
                                    control: /* @__PURE__ */ jsxRuntimeExports.jsx(Checkbox$1, { checked: sourceModel.sourceForm.allowIndividuals, onChange: handleCheckbox("allowIndividuals") }),
                                    label: "Allow individuals?",
                                }),
                            }),
                            /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, {
                                item: true,
                                xs: 6,
                                children: /* @__PURE__ */ jsxRuntimeExports.jsx(TextField$1, {
                                    name: zo.fields.name(),
                                    helperText: errorMessage(zo.errors.name),
                                    onBlur: () => {
                                        const isUniq = validateSourceName(sourceModel.sourceForm.name);
                                        createIssues(isUniq.issues);
                                        validateAfterSubmission();
                                    },
                                    fullWidth: true,
                                    onChange: handleFieldUpdate("name"),
                                    value: sourceModel.sourceForm.name,
                                    id: `name`,
                                    label: "Name",
                                    variant: "standard",
                                }),
                            }),
                            /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, {
                                item: true,
                                xs: 6,
                                children: /* @__PURE__ */ jsxRuntimeExports.jsx(TextField$1, {
                                    fullWidth: true,
                                    helperText: errorMessage(zo.errors.graphUri),
                                    name: zo.fields.graphUri(),
                                    onBlur: validateAfterSubmission,
                                    onChange: _handleFieldUpdate,
                                    value: sourceModel.sourceForm.graphUri,
                                    id: `graphUris`,
                                    label: "graph' Uris",
                                    variant: "standard",
                                }),
                            }),
                            /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, {
                                item: true,
                                xs: 6,
                                children: /* @__PURE__ */ jsxRuntimeExports.jsx(TextField$1, {
                                    fullWidth: true,
                                    onChange: handleSparql_serverUpdate("method"),
                                    value: sourceModel.sourceForm.sparql_server.method,
                                    id: `sparql_server_Method`,
                                    label: "Sparql server method",
                                    variant: "standard",
                                }),
                            }),
                            /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, {
                                item: true,
                                xs: 6,
                                children: /* @__PURE__ */ jsxRuntimeExports.jsx(TextField$1, {
                                    fullWidth: true,
                                    onChange: handleSparql_serverUpdate("url"),
                                    value: sourceModel.sourceForm.sparql_server.url,
                                    id: `sparql_server_url`,
                                    label: "Sparql server url",
                                    variant: "standard",
                                }),
                            }),
                            /* @__PURE__ */ jsxRuntimeExports.jsxs(Grid$1, {
                                container: true,
                                item: true,
                                xs: 6,
                                children: [
                                    sourceModel.sourceForm.sparql_server.headers.map((header, headerIdx) =>
                                        /* @__PURE__ */ jsxRuntimeExports.jsx(
                                            reactExports.Fragment,
                                            {
                                                children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Grid$1, {
                                                    container: true,
                                                    spacing: 4,
                                                    children: [
                                                        /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, {
                                                            item: true,
                                                            xs: 6,
                                                            children: /* @__PURE__ */ jsxRuntimeExports.jsx(TextField$1, {
                                                                fullWidth: true,
                                                                onChange: updateHeaderKey(headerIdx),
                                                                value: header.key,
                                                                id: `sparql_server_headers`,
                                                                label: "Header key",
                                                                variant: "standard",
                                                            }),
                                                        }),
                                                        /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, {
                                                            item: true,
                                                            xs: 6,
                                                            children: /* @__PURE__ */ jsxRuntimeExports.jsx(TextField$1, {
                                                                fullWidth: true,
                                                                onChange: updateHeaderValue(headerIdx),
                                                                value: header.value,
                                                                id: `sparql_server_headers`,
                                                                label: "Header value",
                                                                variant: "standard",
                                                                InputProps: {
                                                                    endAdornment: /* @__PURE__ */ jsxRuntimeExports.jsx(InputAdornment$1, {
                                                                        position: "end",
                                                                        children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton$1, {
                                                                            color: "secondary",
                                                                            onClick: () => removeHeader(headerIdx),
                                                                            children: /* @__PURE__ */ jsxRuntimeExports.jsx(Remove, {}),
                                                                        }),
                                                                    }),
                                                                },
                                                            }),
                                                        }),
                                                    ],
                                                }),
                                            },
                                            headerIdx
                                        )
                                    ),
                                    /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { onClick: addHeader, startIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(Add, {}), children: "Add header" }),
                                ],
                            }),
                            /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, {
                                item: true,
                                xs: 6,
                                children: /* @__PURE__ */ jsxRuntimeExports.jsx(TextField$1, {
                                    fullWidth: true,
                                    multiline: true,
                                    rows: 4,
                                    onChange: handleFieldUpdate("topClassFilter"),
                                    value: sourceModel.sourceForm.topClassFilter,
                                    id: `topClassFilter`,
                                    label: "Top Class filter",
                                    variant: "standard",
                                }),
                            }),
                            /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, {
                                item: true,
                                xs: 6,
                                children: /* @__PURE__ */ jsxRuntimeExports.jsxs(FormControl$1, {
                                    children: [
                                        /* @__PURE__ */ jsxRuntimeExports.jsx(InputLabel$1, { id: "controller", children: "Controller" }),
                                        /* @__PURE__ */ jsxRuntimeExports.jsx(Select$1, {
                                            labelId: "controller",
                                            id: "controller-select",
                                            value: sourceModel.sourceForm.controller,
                                            label: "select-controller",
                                            fullWidth: true,
                                            style: { width: "400px" },
                                            renderValue: (selected) => (typeof selected === "string" ? selected : selected.join(", ")),
                                            onChange: handleFieldUpdate("controller"),
                                            children: ["Sparql_OWL", "Sparql_SKOS", "Sparql_INDIVIDUALS"].map((schemaType) =>
                                                /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem$1, { value: schemaType, children: schemaType }, schemaType)
                                            ),
                                        }),
                                    ],
                                }),
                            }),
                            /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, {
                                item: true,
                                xs: 6,
                                children: /* @__PURE__ */ jsxRuntimeExports.jsx(TextField$1, {
                                    fullWidth: true,
                                    helperText: errorMessage(zo.errors.group),
                                    onBlur: validateAfterSubmission,
                                    onChange: handleFieldUpdate("group"),
                                    value: sourceModel.sourceForm.group,
                                    id: `group`,
                                    name: zo.fields.group(),
                                    label: "Group",
                                    variant: "standard",
                                }),
                            }),
                            /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, {
                                item: true,
                                xs: 6,
                                children: /* @__PURE__ */ jsxRuntimeExports.jsxs(FormControl$1, {
                                    children: [
                                        /* @__PURE__ */ jsxRuntimeExports.jsx(InputLabel$1, { id: "imports-label", children: "Imports" }),
                                        /* @__PURE__ */ jsxRuntimeExports.jsx(Select$1, {
                                            labelId: "imports-label",
                                            id: "imports",
                                            value: sourceModel.sourceForm.imports,
                                            label: "imports-label",
                                            fullWidth: true,
                                            multiple: true,
                                            style: { width: "400px" },
                                            renderValue: (selected) => (typeof selected === "string" ? selected : selected.join(", ")),
                                            onChange: handleFieldUpdate("imports"),
                                            children: sources.map((source2) =>
                                                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                                                    MenuItem$1,
                                                    {
                                                        value: source2.name,
                                                        children: [
                                                            /* @__PURE__ */ jsxRuntimeExports.jsx(Checkbox$1, { checked: sourceModel.sourceForm.imports.indexOf(source2.name) > -1 }),
                                                            source2.name,
                                                        ],
                                                    },
                                                    source2.name
                                                )
                                            ),
                                        }),
                                    ],
                                }),
                            }),
                            /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, {
                                item: true,
                                xs: 6,
                                children: /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl$1, {
                                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Autocomplete$1, {
                                        multiple: true,
                                        limitTags: 2,
                                        id: "taxonomy-predicates",
                                        options: knownTaxonomyPredicates,
                                        value: sourceModel.sourceForm.taxonomyPredicates,
                                        freeSolo: true,
                                        onChange: (e2, value) => handleTaxonomyPredicatesUpdate(value),
                                        style: { width: "400px" },
                                        renderInput: (params) => /* @__PURE__ */ jsxRuntimeExports.jsx(TextField$1, { ...params, variant: "filled", label: "Taxonomy Predicates" }),
                                    }),
                                }),
                            }),
                            /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, {
                                item: true,
                                xs: 6,
                                children: /* @__PURE__ */ jsxRuntimeExports.jsxs(FormControl$1, {
                                    children: [
                                        /* @__PURE__ */ jsxRuntimeExports.jsx(InputLabel$1, { id: "schemaType-label", children: "Schema type" }),
                                        /* @__PURE__ */ jsxRuntimeExports.jsx(Select$1, {
                                            labelId: "schemaType-label",
                                            id: "schemaType",
                                            value: sourceModel.sourceForm.schemaType,
                                            label: "select-schemaTyoe-label",
                                            fullWidth: true,
                                            style: { width: "400px" },
                                            renderValue: (selected) => (typeof selected === "string" ? selected : selected.join(", ")),
                                            onChange: handleFieldUpdate("schemaType"),
                                            children: schemaTypes.map((schemaType) =>
                                                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                                                    MenuItem$1,
                                                    {
                                                        value: schemaType,
                                                        children: [
                                                            /* @__PURE__ */ jsxRuntimeExports.jsx(Checkbox$1, { checked: sourceModel.sourceForm.schemaType.indexOf(schemaType) > -1 }),
                                                            schemaType,
                                                        ],
                                                    },
                                                    schemaType
                                                )
                                            ),
                                        }),
                                    ],
                                }),
                            }),
                            /* @__PURE__ */ jsxRuntimeExports.jsx(FormGivenSchemaType, { update: update2, model: sourceModel }),
                            /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, {
                                item: true,
                                xs: 12,
                                style: { textAlign: "center" },
                                children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, {
                                    disabled: ((_a = zo.validation) == null ? void 0 : _a.success) === false || zo.customIssues.length > 0,
                                    color: "primary",
                                    type: "submit",
                                    variant: "contained",
                                    children: "Save Source",
                                }),
                            }),
                        ],
                    }),
                }),
            }),
        ],
    });
};
const FormGivenSchemaType = (props) => {
    const handlePredicateUpdate = (fieldName) => (event) => props.update({ type: 5, payload: { ...props.model.sourceForm.predicates, [fieldName]: event.target.value } });
    const handleDataSourceUpdate = (fieldName) => (event) =>
        props.update({
            type: 7,
            payload: props.model.sourceForm.dataSource
                ? { ...props.model.sourceForm.dataSource, [fieldName]: event.target.value }
                : { type: "", table_schema: "string", connection: "string", dbName: "string", local_dictionary: { table: "string", labelColumn: "string", idColumn: "string" } },
        });
    const handleAddDataSource = (event) => props.update({ type: 6, payload: event.target.checked });
    const dataSource = props.model.sourceForm.dataSource;
    switch (props.model.sourceForm.schemaType) {
        case "SKOS":
            return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
                children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, {
                        item: true,
                        xs: 6,
                        children: /* @__PURE__ */ jsxRuntimeExports.jsx(TextField$1, {
                            fullWidth: true,
                            onChange: handlePredicateUpdate("broaderPredicate"),
                            value: props.model.sourceForm.predicates.broaderPredicate,
                            id: `broaderPredicate`,
                            label: "Broader Predicate",
                            variant: "standard",
                        }),
                    }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, {
                        item: true,
                        xs: 6,
                        children: /* @__PURE__ */ jsxRuntimeExports.jsx(TextField$1, {
                            fullWidth: true,
                            onChange: handlePredicateUpdate("lang"),
                            value: props.model.sourceForm.predicates.lang,
                            id: `predicateLang`,
                            label: "Language",
                            variant: "standard",
                        }),
                    }),
                ],
            });
        case "KNOWLEDGE_GRAPH":
            return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
                children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, {
                        item: true,
                        xs: 3,
                        children: /* @__PURE__ */ jsxRuntimeExports.jsx(FormControlLabel$1, {
                            control: /* @__PURE__ */ jsxRuntimeExports.jsx(Checkbox$1, { checked: props.model.sourceForm.dataSource ? true : false, onChange: handleAddDataSource }),
                            label: "Do you want to add a data source ?",
                        }),
                    }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, {
                        item: true,
                        xs: 6,
                        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(FormControl$1, {
                            children: [
                                /* @__PURE__ */ jsxRuntimeExports.jsx(InputLabel$1, { id: "dataSource-type", children: "DataSource&aposs type" }),
                                /* @__PURE__ */ jsxRuntimeExports.jsx(Select$1, {
                                    labelId: "dataSource-type",
                                    id: "dataSource",
                                    value: props.model.sourceForm.dataSource ? props.model.sourceForm.dataSource.type : "",
                                    label: "Data source's type",
                                    fullWidth: true,
                                    multiple: true,
                                    style: { width: "400px" },
                                    onChange: handleDataSourceUpdate("type"),
                                    children: ["sql.sqlserver"].map((type) => /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem$1, { value: type, children: type }, type)),
                                }),
                            ],
                        }),
                    }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, {
                        item: true,
                        xs: 6,
                        children: /* @__PURE__ */ jsxRuntimeExports.jsx(TextField$1, {
                            fullWidth: true,
                            onChange: handleDataSourceUpdate("connection"),
                            value: props.model.sourceForm.dataSource ? props.model.sourceForm.dataSource.connection : "",
                            id: `connection`,
                            label: "Connection",
                            variant: "standard",
                            style: { display: !dataSource ? "none" : "" },
                        }),
                    }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, {
                        item: true,
                        xs: 6,
                        children: /* @__PURE__ */ jsxRuntimeExports.jsx(TextField$1, {
                            fullWidth: true,
                            onChange: handleDataSourceUpdate("dbName"),
                            value: props.model.sourceForm.dataSource ? props.model.sourceForm.dataSource.dbName : "",
                            id: `dbName`,
                            label: "Data Base's Name",
                            variant: "standard",
                            style: { display: !dataSource ? "none" : "" },
                        }),
                    }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, {
                        item: true,
                        xs: 6,
                        children: /* @__PURE__ */ jsxRuntimeExports.jsx(TextField$1, {
                            fullWidth: true,
                            onChange: handleDataSourceUpdate("table_schema"),
                            value: props.model.sourceForm.dataSource ? props.model.sourceForm.dataSource.table_schema : "",
                            id: `table_schema`,
                            label: "Table Schema",
                            style: { display: !dataSource ? "none" : "" },
                            variant: "standard",
                        }),
                    }),
                ],
            });
        default:
            return /* @__PURE__ */ jsxRuntimeExports.jsx("div", {});
    }
};
const LogsTable = () => {
    const { model } = useModel();
    const [filteringChars, setFilteringChars] = reactExports.useState("");
    const [orderBy, setOrderBy] = reactExports.useState("timestamp");
    const [order2, setOrder] = reactExports.useState("desc");
    function handleRequestSort(property) {
        const isAsc = orderBy === property && order2 === "asc";
        setOrder(isAsc ? "desc" : "asc");
        setOrderBy(property);
    }
    const renderLogs = SRD.match(
        {
            notAsked: () => /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Let&aposs fetch some data!" }),
            loading: () =>
                /* @__PURE__ */ jsxRuntimeExports.jsx(Box$1, { sx: { display: "flex", justifyContent: "center", p: 4 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress$1, {}) }),
            failure: (msg) =>
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Box$1, {
                    sx: { display: "flex", justifyContent: "center", p: 4 },
                    children: [",", /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: `I stumbled into this error when I tried to fetch data: ${msg}. Please, reload this page.` })],
                }),
            success: (gotLogs) => {
                const sortedLogs = () =>
                    gotLogs
                        .map((item, index) => ({ ...item, key: index }))
                        .slice()
                        .sort((a, b2) => {
                            const left2 = a[orderBy];
                            const right2 = b2[orderBy];
                            if (orderBy === "timestamp") {
                                return order2 === "asc" ? Number(new Date(left2).getTime() > new Date(right2).getTime()) : Number(new Date(left2) < new Date(right2));
                            }
                            return order2 === "asc" ? left2.localeCompare(right2) : right2.localeCompare(left2);
                        });
                const memoizedLogs = reactExports.useMemo(() => sortedLogs(), [gotLogs, orderBy, order2]);
                const getOptions = () =>
                    memoizedLogs.filter(function ({ user }) {
                        return !this.has(user) && this.add(user);
                    }, /* @__PURE__ */ new Set());
                const memoizedOptions = reactExports.useMemo(() => getOptions(), [gotLogs]);
                return /* @__PURE__ */ jsxRuntimeExports.jsx(Box$1, {
                    sx: { display: "flex", justifyContent: "center", p: 4 },
                    children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack$1, {
                        children: [
                            /* @__PURE__ */ jsxRuntimeExports.jsx(CsvDownload, { filename: "logs.csv", datas: gotLogs }),
                            /* @__PURE__ */ jsxRuntimeExports.jsx(Autocomplete$1, {
                                disablePortal: true,
                                id: "search-logs",
                                options: memoizedOptions,
                                sx: { width: 300 },
                                onInputChange: (event, newInputValue) => {
                                    setFilteringChars(newInputValue);
                                },
                                getOptionLabel: (option) => option.user,
                                renderOption: (props, option) => /* @__PURE__ */ reactExports.createElement("li", { ...props, key: option.key }, option.user),
                                renderInput: (params) => /* @__PURE__ */ jsxRuntimeExports.jsx(TextField$1, { ...params, label: "Search logs by username" }),
                            }),
                            " ",
                            /* @__PURE__ */ jsxRuntimeExports.jsx(Box$1, {
                                id: "table-container",
                                sx: { justifyContent: "center", height: "400px", display: "flex" },
                                children: /* @__PURE__ */ jsxRuntimeExports.jsx(TableContainer$1, {
                                    sx: { height: "400px" },
                                    component: Paper$1,
                                    children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Table$1, {
                                        children: [
                                            /* @__PURE__ */ jsxRuntimeExports.jsx(TableHead$1, {
                                                children: /* @__PURE__ */ jsxRuntimeExports.jsxs(TableRow$1, {
                                                    children: [
                                                        /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell$1, { style: { fontWeight: "bold" }, children: "User" }),
                                                        /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell$1, { style: { fontWeight: "bold" }, children: "Tool" }),
                                                        /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell$1, { style: { fontWeight: "bold" }, children: "Source" }),
                                                        /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell$1, {
                                                            style: { fontWeight: "bold" },
                                                            children: /* @__PURE__ */ jsxRuntimeExports.jsx(TableSortLabel$1, {
                                                                active: orderBy === "timestamp",
                                                                direction: order2,
                                                                onClick: () => handleRequestSort("timestamp"),
                                                                children: "at",
                                                            }),
                                                        }),
                                                    ],
                                                }),
                                            }),
                                            /* @__PURE__ */ jsxRuntimeExports.jsx(TableBody$1, {
                                                sx: { width: "100%", overflow: "visible" },
                                                children: memoizedLogs
                                                    .filter((log) => log.user.includes(filteringChars))
                                                    .map((log) => {
                                                        return /* @__PURE__ */ jsxRuntimeExports.jsxs(
                                                            TableRow$1,
                                                            {
                                                                children: [
                                                                    /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell$1, { children: log.user }),
                                                                    /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell$1, { children: log.tool }),
                                                                    /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell$1, { children: log.source }),
                                                                    /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell$1, { children: log.timestamp }),
                                                                ],
                                                            },
                                                            log.key
                                                        );
                                                    }),
                                            }),
                                        ],
                                    }),
                                }),
                            }),
                        ],
                    }),
                });
            },
        },
        model.logs
    );
    return renderLogs;
};
async function getConfig() {
    const response = await fetch("/api/v1/config");
    const json = await response.json();
    return json;
}
const endpoint = "/api/v1/logs";
async function getLogs() {
    const response = await fetch(endpoint);
    const json = await response.json();
    return json;
}
const editionTabToNumber = (editionTab) => {
    switch (editionTab) {
        case "UsersEdition":
            return 0;
        case "ProfilesEdition":
            return 1;
        case "SourcesEdition":
            return 2;
        case "Logs":
            return 3;
    }
};
const editionTabToString = (editionTab) => {
    switch (editionTab) {
        case 0:
            return "UsersEdition";
        case 1:
            return "ProfilesEdition";
        case 2:
            return "SourcesEdition";
        case 3:
            return "Logs";
        default:
            return "UsersEdition";
    }
};
const initialModel = {
    users: loading(),
    profiles: loading(),
    sources: loading(),
    indices: loading(),
    graphs: loading(),
    logs: loading(),
    config: loading(),
    isModalOpen: false,
    currentEditionTab: "SourcesEdition",
};
const ModelContext = reactExports.createContext(null);
function useModel() {
    const modelContext = reactExports.useContext(ModelContext);
    if (modelContext === null) {
        throw new Error("I can't initialize model and updateModel for some reason");
    }
    return modelContext;
}
function update(model, msg) {
    const unwrappedUsers = SRD.unwrap([], identity, model.users);
    switch (msg.type) {
        case "ServerRespondedWithUsers":
            return { ...model, users: msg.payload };
        case "ServerRespondedWithProfiles":
            return { ...model, profiles: msg.payload };
        case "ServerRespondedWithIndices":
            return { ...model, indices: msg.payload };
        case "ServerRespondedWithGraphs":
            return { ...model, graphs: msg.payload };
        case "ServerRespondedWithSources":
            return { ...model, sources: msg.payload };
        case "ServerRespondedWithConfig":
            return { ...model, config: msg.payload };
        case "ServerRespondedWithLogs":
            return { ...model, logs: msg.payload };
        case "UserClickedSaveChanges":
            return { ...model, isModalOpen: false };
        case "UserClickedAddUser":
            return { ...model, users: SRD.of([...unwrappedUsers, newUser(msg.payload)]) };
        case "UserUpdatedField": {
            const fieldToUpdate = msg.payload.fieldName;
            const updatedUsers = unwrappedUsers.map((u2) => (u2.id === msg.payload.id ? { ...u2, [fieldToUpdate]: msg.payload.newValue } : u2));
            return { ...model, users: SRD.of(updatedUsers) };
        }
        case "UserClickedNewTab":
            return { ...model, currentEditionTab: editionTabToString(msg.payload) };
        default:
            return model;
    }
}
const Admin = () => {
    const [model, updateModel] = reactExports.useReducer(update, initialModel);
    reactExports.useEffect(() => {
        getProfiles()
            .then((profiles) => updateModel({ type: "ServerRespondedWithProfiles", payload: success(profiles) }))
            .catch((err) => updateModel({ type: "ServerRespondedWithProfiles", payload: failure(err.message) }));
    }, []);
    reactExports.useEffect(() => {
        getUsers()
            .then((person) => updateModel({ type: "ServerRespondedWithUsers", payload: success(person) }))
            .catch((err) => updateModel({ type: "ServerRespondedWithUsers", payload: failure(err.message) }));
    }, []);
    reactExports.useEffect(() => {
        getSources()
            .then((sources) => {
                updateModel({ type: "ServerRespondedWithSources", payload: success(sources) });
            })
            .catch((err) => updateModel({ type: "ServerRespondedWithSources", payload: failure(err.message) }));
        getIndices()
            .then((indices) => {
                updateModel({ type: "ServerRespondedWithIndices", payload: success(indices) });
            })
            .catch((err) => updateModel({ type: "ServerRespondedWithIndices", payload: failure(err.message) }));
        getGraphs()
            .then((graphs) => {
                updateModel({ type: "ServerRespondedWithGraphs", payload: success(graphs) });
            })
            .catch((err) => updateModel({ type: "ServerRespondedWithIndices", payload: failure(err.message) }));
    }, []);
    reactExports.useEffect(() => {
        getConfig()
            .then((config) => updateModel({ type: "ServerRespondedWithConfig", payload: success(config) }))
            .catch((err) => updateModel({ type: "ServerRespondedWithConfig", payload: failure(err.message) }));
    }, []);
    reactExports.useEffect(() => {
        getLogs()
            .then((logs) => updateModel({ type: "ServerRespondedWithLogs", payload: success(logs) }))
            .catch((err) => failure(err.message));
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(ModelContext.Provider, {
        value: { model, updateModel },
        children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Box$1, {
                sx: { width: "100%", bgcolor: "Background.paper" },
                children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Tabs$1, {
                    onChange: (event, newValue) => updateModel({ type: "UserClickedNewTab", payload: newValue }),
                    value: editionTabToNumber(model.currentEditionTab),
                    centered: true,
                    children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Tab$1, { label: "Users" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Tab$1, { label: "Profiles" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Tab$1, { label: "Sources" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Tab$1, { label: "Logs" }),
                    ],
                }),
            }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Dispatcher, { model }),
        ],
    });
};
const Dispatcher = (props) => {
    switch (props.model.currentEditionTab) {
        case "UsersEdition":
            return /* @__PURE__ */ jsxRuntimeExports.jsx(UsersTable, {});
        case "ProfilesEdition":
            return /* @__PURE__ */ jsxRuntimeExports.jsx(ProfilesTable, {});
        case "SourcesEdition":
            return /* @__PURE__ */ jsxRuntimeExports.jsx(SourcesTable, {});
        case "Logs":
            return /* @__PURE__ */ jsxRuntimeExports.jsx(LogsTable, {});
        default:
            return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "Problem" });
    }
};
const container = document.getElementById("mount-app-here");
const root = createRoot(container);
root.render(/* @__PURE__ */ jsxRuntimeExports.jsx(Admin, {}));
